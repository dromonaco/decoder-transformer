     /*-                                                                            +
      * Copyright (c) 2005-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * CCSIDR4 -- routines to ASCII/EBCDIC translation
      */

     H NOMAIN
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT)
      /endif

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy private_h
      /copy errno_h

     D ToASCII         DS
     D   ICORV_A                     10I 0
     D   ICOC_A                      10I 0 dim(12)

     D ToEBCDIC        DS
     D   ICORV_E                     10I 0
     D   ICOC_E                      10I 0 dim(12)

     D xmlEBCDIC       DS
     D   ICORV_X                     10I 0
     D   ICOC_X                      10I 0 dim(12)

     D pToASCII        DS
     D   ICORV_PA                    10I 0
     D   ICOC_PA                     10I 0 dim(12)

     D pToEBCDIC       DS
     D   ICORV_PE                    10I 0
     D   ICOC_PE                     10I 0 dim(12)

     D dsFROM          DS
     D   from_ccsid                  10I 0
     D   from_ca                     10I 0  INZ(0)
     D   from_sa                     10I 0  INZ(0)
     D   from_ss                     10I 0  INZ(0)
     D   from_il                     10I 0  INZ(0)
     D   from_eo                     10I 0  INZ(0)
     D   from_r                       8A    INZ(*allx'00')

     D dsTO            DS
     D   to_ccsid                    10I 0
     D   to_ca                       10I 0  INZ(0)
     D   to_sa                       10I 0  INZ(0)
     D   to_ss                       10I 0  INZ(0)
     D   to_il                       10I 0  INZ(0)
     D   to_eo                       10I 0  INZ(0)
     D   to_r                         8A    INZ(*allx'00')

     D iconv_open      PR                  ExtProc('QtqIconvOpen')
     D                                     like(ToASCII)
     D   ToCode                            like(dsFrom)
     D   FromCode                          like(dsTo)

     D iconv           PR            10U 0 ExtProc('iconv')
     D   Descriptor                        like(ToASCII) value
     D   p_inbuf                       *
     D   in_left                     10U 0
     D   p_outbuf                      *
     D   out_left                    10U 0

     D iconv_close     PR            10I 0 extproc('iconv_close')
     D   cd                                like(ToASCII) value

     D EBCDIC          s             10I 0 inz(-1)
     D ASCII           s             10I 0 inz(-1)

     D xml_EBCDIC      s             10I 0 inz(-1)
     D xml_ASCII       s             10I 0 inz(-1)

     D TblXlate        PR            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D CCSIDxlate      PR            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D TblXlateDyn     PR            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D   peOutput                      *
     D CCSIDXlateDyn   PR            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D   peOutbuf                      *
     D xlate_symbols   PR            25a
     D BinaryCopy      PR            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peOutbuf                      *

     D CCSIDs_Set      s              1A   inz(*OFF)
     D Xml_CCSID_Set   s              1A   inz(*OFF)
     D BinaryData      s              1A   inz(*OFF)


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_SetCCSIDs():  Set the CCSIDs used for ASCII/EBCDIC
      *                    translation
      *
      *     pePostRem = (input) Remote CCSID of POST data
      *     pePostLoc = (input) Local CCSID of POST data
      *     peProtRem = (input) Remote CCSID of Protocol data
      *     peProtLoc = (input) Local CCSID of Protocol data
      *
      * Returns 0 if successful, -1 otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_SetCCSIDs  B                   export
     D HTTP_SetCCSIDs  PI            10I 0
     D   pePostRem                   10I 0 value
     D   pePostLoc                   10I 0 value
     D   peProtRem                   10I 0 value options(*nopass)
     D   peProtLoc                   10I 0 value options(*nopass)

     D wwProtRem       s             10I 0
     D wwProtLoc       s             10I 0

     c                   if        %parms >= 3
     c                   eval      wwProtRem = peProtRem
     c                   else
     c                   eval      wwProtRem = HTTP_ASCII
     c                   endif

     c                   if        %parms >= 4
     c                   eval      wwProtLoc = peProtLoc
     c                   else
     c                   eval      wwProtLoc = HTTP_EBCDIC
     c                   endif

     c                   eval      p_global = getGlobalPtr()
     c                   eval      global.net_ccsid = pePostRem
     c                   eval      global.local_ccsid = pePostLoc

     c                   if        CCSIDs_Set = *ON
     c                   callp     iconv_close(PToASCII)
     c                   callp     iconv_close(PToEBCDIC)
     c                   callp     iconv_close(ToEBCDIC)
     c                   callp     iconv_close(ToASCII)
     c                   endif

     c                   eval      BinaryData = *off
     c                   if        pePostRem = pePostLoc
     c                   eval      BinaryData = *on
     c                   endif

     c                   if        BinaryData = *Off
     c                   eval      from_ccsid = pePostRem
     c                   eval      to_ccsid   = pePostLoc
     c                   eval      pToEBCDIC = iconv_open(dsTo: dsFrom)
     c                   if        ICORV_PE < 0
     c                   return    -1
     c                   endif
     c                   endif

     c                   if        BinaryData = *off
     c                   eval      from_ccsid = pePostLoc
     c                   eval      to_ccsid   = pePostRem
     c                   eval      pToASCII  = iconv_open(dsTo: dsFrom)
     c                   if        ICORV_PA < 0
     c                   callp     iconv_close(pToEBCDIC)
     c                   return    -1
     c                   endif
     c                   endif

     c                   eval      from_ccsid = wwProtRem
     c                   eval      to_ccsid   = wwProtLoc
     c                   eval      toEBCDIC = iconv_open(dsTo: dsFrom)

     c                   if        ICORV_E < 0
     c                   if        BinaryData = *off
     c                   callp     iconv_close(pToEBCDIC)
     c                   callp     iconv_close(pToASCII)
     c                   endif
     c                   return    -1
     c                   endif

     c                   eval      from_ccsid = wwProtLoc
     c                   eval      to_ccsid   = wwProtRem
     c                   eval      toASCII  = iconv_open(dsTo: dsFrom)

     c                   if        ICORV_A < 0
     c                   if        BinaryData = *off
     c                   callp     iconv_close(pToEBCDIC)
     c                   callp     iconv_close(pToASCII)
     c                   endif
     c                   callp     iconv_close(toEBCDIC)
     c                   return    -1
     c                   endif

     c                   eval      CCSIDs_set = *ON

     c                   eval      EBCDIC = wwProtLoc
     c                   eval      ASCII  = wwProtRem

     c                   callp     http_dmsg('New iconv() objects set, '
     c                                  + 'PostRem='
     c                                  + %trim(%editc(pePostRem:'L'))
     c                                  + '. PostLoc='
     c                                  + %trim(%editc(pePostLoc:'L'))
     c                                  + '. ProtRem='
     c                                  + %trim(%editc(wwProtRem:'L'))
     c                                  + '. ProtLoc='
     c                                  + %trim(%editc(wwProtLoc:'L')))

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_SetFileCCSID(): Set the CCSID that downloaded stream
      *                      files get tagged with
      *
      *     peCCSID  = (input) New CCSID to assign
      *
      * NOTE: HTTPAPI does not do *any* translation of downloaded
      *       data. It only sets this number as part of the file's
      *       attributes.  You can change it with the CHGATR CL
      *       command.
      *
      * NOTE: The IFS did not support CCSIDs in V4R5 and earlier.
      *       On those releases, this API will be used to set the
      *       codepage rather than the CCSID.
      *
      * Returns 0 if successful, -1 otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_SetfileCCSID...
     P                 B                   export
     D HTTP_SetfileCCSID...
     D                 PI
     D   peCCSID                     10I 0 value
     c                   eval      p_global = getGlobalPtr()
     c                   eval      global.file_ccsid = peCCSID
     c                   callp     http_dmsg('File CCSID changed to '
     c                                      + %trim(%editc(peCCSID:'L')))
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_xlate():  Translate data from ASCII <--> EBCDIC
      *
      *       peSize = (input) Size of data to translate
      *       peData = (i/o)   Data
      *  peDirection = (input) can be set to the TO_ASCII or
      *                         TO_EBCDIC constant.
      *
      * Returns 0 if successful, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_xlate      B                   export
     D HTTP_xlate      PI            10I 0
     D   peSize                      10I 0 value
     D   peData                   32766A   options(*varsize)
     D   peDirection                  1A   const

     c                   return    CCSIDxlate( peSize
     c                                       : %addr(peData)
     c                                       : peDirection)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_xlatep(): Translate data from ASCII <--> EBCDIC
      *                (using a pointer instead of a variable)
      *
      *       peSize = (input) Size of data to translate
      *       peData = (input) Data
      *  peDirection = (input) can be set to the TO_ASCII or
      *                         TO_EBCDIC constant.
      *
      * Returns 0 if successful, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_xlatep     B                   export
     D HTTP_xlatep     PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const

     c                   return    CCSIDxlate( peSize
     c                                       : peData
     c                                       : peDirection)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * CCSIDxlate():  Translate data from ASCII <--> EBCDIC
      *                using a pointer to the data.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CCSIDxlate      B
     D CCSIDxlate      PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const

     D Size            s             10U 0
     D OutSize         s             10U 0

     c                   if        CCSIDs_Set = *OFF
     c                   if        HTTP_SetCCSIDs( HTTP_ASCII
     c                                           : HTTP_EBCDIC ) < 0
     c                   return    -1
     c                   endif
     c                   endif

     c                   eval      Size = peSize
     c                   eval      OutSize = peSize

     c                   if        peDirection = TO_ASCII
     c                   callp     iconv( ToASCII
     c                                  : peData
     c                                  : Size
     c                                  : peData
     c                                  : OutSize )
     c                   else
     c                   callp     iconv( ToEBCDIC
     c                                  : peData
     c                                  : Size
     c                                  : peData
     c                                  : OutSize )
     c                   endif

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * FILE_CCSID(): Get the CCSID that stream files should be
      *               tagged with.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P FILE_CCSID      B                   export
     D FILE_CCSID      PI            10I 0
     c                   eval      p_global = getGlobalPtr()
     c                   return    global.file_ccsid
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_xml_SetCCSIDs():  Set the CCSIDs used for ASCII/EBCDIC
      *                    translation for XML documents
      *
      *     peRemote = (input) remote CCSID
      *     peLocal  = (input) local CCSID (can be 0 if you want
      *                 to use the CCSID of the current job)
      *
      * Returns 0 if successful, -1 otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_xml_SetCCSIDs...
     P                 B                   export
     D HTTP_xml_SetCCSIDs...
     D                 PI            10I 0
     D   peRemote                    10I 0 value
     D   peLocal                     10I 0 value

     c                   if        Xml_CCSID_Set = *ON
     c                   callp     iconv_close(xmlEBCDIC)
     c                   endif

     c                   eval      from_ccsid = peRemote
     c                   eval      to_ccsid   = peLocal
     c                   eval      xmlEBCDIC = iconv_open(dsTo: dsFrom)

     c                   if        ICORV_X < 0
     c                   return    -1
     c                   endif

     c                   eval      Xml_CCSID_set = *ON

     c                   eval      xml_EBCDIC = peLocal
     c                   eval      xml_ASCII  = peRemote

     c                   callp     http_dmsg('New XML iconv() objects set, '
     c                                  + 'xml_Remote='
     c                                  + %trim(%editc(peRemote:'L'))
     c                                  + '. xml_Local='
     c                                  + %trim(%editc(peLocal:'L')))

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * xml_xlate():  Translate data from UTF-8 to EBCDIC for
      *               XML data conversations.
      *
      *    peSize = (input) size of data to translate
      *    peData = (input) pointer to data to translate
      *  peOutBuf = (output) pointer to dynamically allocated
      *                      buffer containing translated data
      *
      *  returns the length of the data after the translation
      *       or -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P xml_xlate       B                   export
     D xml_xlate       PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peOutBuf                      *

     c                   if        Xml_CCSID_Set = *OFF
     c                   if        HTTP_xml_SetCCSIDs( 819 : 1208 ) < 0
     c                   return    -1
     c                   endif
     c                   endif

     c                   return    iconvdyn( peSize
     c                                     : peData
     c                                     : xmlEBCDIC
     c                                     : peOutbuf )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_xlatedyn: Translate data from ASCII <--> EBCDIC
      *                using a dynamically sized output buffer
      *
      *      peSize = (input) size of data to translate
      *      peData = (input) pointer to data to translate
      * peDirection = (input) TO_ASCII or TO_EBCDIC
      *    peOutput = (output) address of newly allocated memory
      *
      * returns the length of the translated data or -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_xlatedyn   B                   export
     D HTTP_xlatedyn   PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D   peOutput                      *
     c                   if        BinaryData = *on
     c                   return    BinaryCopy( peSize
     c                                       : peData
     c                                       : peOutput )
     c                   else
     c                   return    CCSIDXLateDyn( peSize
     c                                          : peData
     c                                          : peDirection
     c                                          : peOutput )
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * CCSIDXlateDyn(): Translate using CCSID. Translate input
      *                  to a dynamically allocated output buffer.
      *
      *      peSize = (input) size of data to translate
      *      peData = (input) pointer to data to translate
      * peDirection = (input) TO_ASCII or TO_EBCDIC
      *    peOutput = (output) address of newly allocated memory
      *
      * returns the length of the translated data or -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CCSIDXlateDyn   B
     D CCSIDXlateDyn   PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDirection                  1A   const
     D   peOutbuf                      *

     D desc            s                   like(ToAscii)

     c                   if        CCSIDs_Set = *OFF
     c                   if        HTTP_SetCCSIDs( HTTP_ASCII
     c                                           : HTTP_EBCDIC ) < 0
     c                   return    -1
     c                   endif
     c                   endif

     c                   if        peDirection = TO_ASCII
     c                   eval      desc = pToAscii
     c                   else
     c                   eval      desc = pToEbcdic
     c                   endif

     c                   return    iconvdyn( peSize
     c                                     : peData
     c                                     : desc
     c                                     : peOutBuf )

     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * new_iconv(): Create a new character converter
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P new_iconv       b                   export
     D new_iconv       PI            52a
     D   peFrom                      10i 0 value
     D   peTo                        10i 0 value

     D Result          DS
     D   RC                          10I 0
     D   Xlate                       10I 0 dim(12)

     c                   eval      from_ccsid = peFrom
     c                   eval      to_ccsid   = peTo

     c                   eval      Result = iconv_open(dsTo: dsFrom)

     c                   if        RC < 0
     c                   callp     SetError( HTTP_CONVERR
     c                                     : 'iconv_open failed: '
     c                                     + %str(strerror(errno)) )
     c                   callp     http_crash
     c                   return    *blanks
     c                   endif

     c                   return    Result
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * iconvdyn():  Run the iconv() API and output to a dynamic
      *              memory buffer
      *
      *  NOTE: Output buffer is increased dynamically as needed.
      *        FIX: Original formula was to start the output buffer
      *             double the input buffer, this was a problem
      *             because max input size was effectively 8MB,
      *             since the 16MB output couldn't be allocated.
      *        FIX: When running out of memory, this routine used
      *             to increase the buffer by (peSize*4).. this
      *             meant that a 4MB input could also run out of
      *             memory.
      *
      *        New algorithm is start with same size as input
      *        buffer. If it needs to be increased, increase
      *        in 64k chunks.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P iconvdyn        B                   export
     D iconvdyn        PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peDesc                      52a
     D   peOutbuf                      *

     D len             s             10I 0

     D insize          s             10U 0
     D desc            s                   like(ToAscii)
     D p_outbuf        s               *
     D size            s             10U 0
     D spaceleft       s             10U 0
     D GROW_CHUNK      C                   const(65536)

     D                 ds
     D rcU                           10U 0
     D rcI                           10I 0 overlay(rcU)

     c                   eval      insize    = peSize
     c                   eval      size      = insize
     c                   eval      peOutbuf  = xalloc(size)
     c                   eval      p_outbuf  = peOutbuf
     c                   eval      spaceleft = size

     c                   dow       '1'

     c                   eval      rcU = iconv( peDesc
     c                                        : peData
     c                                        : insize
     c                                        : p_outbuf
     c                                        : spaceleft )

     c                   if        rcI >= 0
     c                   leave
     c                   endif

     c                   if        errno <> E2BIG
     c                   callp     SetError( HTTP_CONVERR
     c                                     : 'CCSID conversion failed: '
     c                                     + %str(strerror(errno)) )
     c                   callp     xdealloc(peOutbuf)
     c                   return    -1
     c                   endif

     c                   eval      size      = size + GROW_CHUNK
     c                   eval      len       = p_outbuf - peOutbuf
     c                   eval      peOutbuf  = xrealloc(peOutbuf:size)
     c                   eval      p_outbuf  = peOutbuf + len
     c                   eval      spaceleft = size - len

     c                   enddo

     c                   eval      len = size - spaceleft

     c                   return    len
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * close_iconv(): Close iconv converter
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P close_iconv     b                   export
     D close_iconv     PI
     D   This                        52a   value
     C                   callp     iconv_close(This)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * xlate_symbols(): Translates symbols to current job's CCSID
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P xlate_symbols   B
     D xlate_symbols   PI            25a

     D Ucs2Symbols     ds
     D  Slash                         2a   inz(x'002F')
     D  Lt                            2a   inz(x'003C')
     D  Gt                            2a   inz(x'003E')
     D  Amp                           2a   inz(x'0026')
     D  Question                      2a   inz(x'003F')
     D  Plus                          2a   inz(x'002B')
     D  Pct                           2a   inz(x'0025')
     D  Equal                         2a   inz(x'003D')
     D  At                            2a   inz(x'0040')
     D  DblQuote                      2a   inz(x'0022')
     D  SngQuote                      2a   inz(x'0027')
     D  Comma                         2a   inz(x'002C')
     D  SemiColon                     2a   inz(x'003B')
     D  Colon                         2a   inz(x'003A')
     D  Dollar                        2a   inz(x'0024')
     D  Pound                         2a   inz(x'0023')
     D  BackSlash                     2a   inz(x'005C')
     D  LSQB                          2a   inz(x'005B')
     D  RSQB                          2a   inz(x'005D')
     D  LBRACE                        2a   inz(x'007B')
     D  RBRACE                        2a   inz(x'007D')
     D  Caret                         2a   inz(x'005E')
     D  BackTick                      2a   inz(x'0060')
     D  Pipe                          2a   inz(x'007C')
     D  Tilde                         2a   inz(x'007E')

     D Table           DS
     D   RC                          10I 0
     D   Xlate                       10I 0 dim(12)

     D Result          s             25a   inz('/<>&?+%=@"'',;:$#\[]{}^`|~')
     D Temp            s             25a   based(p_Temp)
     D Len             s             10i 0

     c                   eval      from_ccsid = 13488
     c                   eval      to_ccsid   = 0

     c                   eval      Table = iconv_open(dsTo: dsFrom)
     c                   if        RC < 0
     c                   return    Result
     c                   endif

     C                   eval      Len   = iconvdyn( %size(Ucs2Symbols)
     C                                             : %addr(Ucs2Symbols)
     C                                             : Table
     C                                             : p_Temp )
     C                   eval      Result = Temp
     c                   callp     xdealloc(p_Temp)

     C                   callp     iconv_close(Table)

     C                   return    Result
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * get_symbols(): Gets special HTTP symbols in current job's
      *                CCSID.  (Translated from Unicode)
      *
      *    Returns the list of symbols
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P get_symbols     b                   export
     D get_symbols     PI            25a
     D done            s              1n   static inz(*OFF)
     D symbols         s             25a   static
     C                   if        not done
     c                   eval      symbols = xlate_symbols
     c                   eval      done = *on
     c                   endif
     c                   return    symbols
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * BinaryCopy(): Allocate an buffer containing a copy of the
      *               input buffer.
      *
      *      peSize = (input) size of data to copy
      *      peData = (input) pointer to data to copy
      *    peOutput = (output) address of newly allocated memory
      *
      * returns the length of the copied data or -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P BinaryCopy      B
     D                 PI            10I 0
     D   peSize                      10I 0 value
     D   peData                        *   value
     D   peOutbuf                      *

     c                   if        peSize < 1
     c                   return    -1
     c                   endif

     c                   eval      peOutbuf = xalloc(peSize)
     c                   callp     memcpy(peOutBuf: peData: peSize)
     c                   return    peSize

     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy errno_h
     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      */                                                                            +
      *
      *
      * COMMSSLR4: Comm driver for TLS (Transport Layer Security)
      *
      *
      *> ign: DLTMOD &O/&ON
      *>      CRTRPGMOD MODULE(&O/&ON) SRCFILE(&L/&F) DBGVIEW(&DV)
      *>      UPDSRVPGM SRVPGM(&O/HTTPAPIR4) MODULE((&O/&ON))
      *> ign: DLTMOD &O/&ON
      *
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT: *NOSHOWCPY)
      /endif
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy socket_h
      /copy gskssl_h
      /copy errno_h
      /copy private_h

     D p_CommSSL       s               *
     D CommSSL         ds                  based(p_CommSSL)
     D    p_Resolve...
     D                                 *   procptr
     D    p_Connect...
     D                                 *   procptr
     D    p_Upgrade...
     D                                 *   procptr
     D    p_Read...
     D                                 *   procptr
     D    p_BlockRead...
     D                                 *   procptr
     D    p_BlockWrite...
     D                                 *   procptr
     D    p_LineRead...
     D                                 *   procptr
     D    p_LineWrite...
     D                                 *   procptr
     D    p_Hangup...
     D                                 *   procptr
     D    p_Cleanup...
     D                                 *   procptr
     D    fd                         10I 0
     D    bufSize                    10u 0
     D    bufLen                     10u 0
     D    sslmode                     1n
     D                                3a
     D    bufBase                      *
     D    bufCurr                      *
     D    sslh                         *


     D CommSSL_New     PR              *

     D CommSSL_Resolve...
     D                 PR              *
     D   peHandle                      *   value
     D   peHost                        *   value options(*string)
     D   peService                     *   value options(*string)
     D   pePort                      10I 0 value
     D   peForced                     1N   const

     D CommSSL_Connect...
     D                 PR             1N
     D   peHandle                      *   value
     D   peSockaddr                    *   value
     D   peTimeout                   10P 3 value

     D CommSSL_Upgrade...
     D                 PR             1N
     D   peHandle                      *   value
     D   peTimeout                   10P 3 value
     D   peEndHost                     *   value options(*string)

     D CommSSL_Read...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommSSL_BlockRead...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommSSL_BlockWrite...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommSSL_LineRead...
     D                 PR            10I 0
     D   handle                        *   value
     D   buffer                        *   value
     D   bufsize                     10I 0 value
     D   peTimeout                   10P 3 value

     D CommSSL_LineWrite...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peBufSize                   10I 0 value
     D   peTimeout                   10P 3 value

     D CommSSL_Hangup...
     D                 PR             1N
     D   peHandle                      *   value

     D CommSSL_Cleanup...
     D                 PR             1N
     D   peHandle                      *   value

     D ssl_error       PR           256A
     D   peErr                       10I 0 value

     D SSL_protocol    PR            20A   varying
     D    peHandle                         like(gsk_handle) value
     D    peVersion                        like(GSK_ENUM_ID)
     D                                     options(*omit)

     D SSL_force_protocol...
     D                 PR             1N
     D    peHandle                         like(gsk_handle) value
     D    peSSLv2                     1N   const
     D    peSSLv3                     1N   const
     D    peTLSv10                    1N   const

     D TLS_force_protocol...
     D                 PR             1N
     D    peHandle                         like(gsk_handle) value
     D    peTLSv10                    1N   const
     D    peTLSv11                    1N   const
     D    peTLSv12                    1N   const
     D    peTLSv13                    1N   const

     D TLS_set_version...
     D                 PR             1N
     D    peHandle                         like(gsk_handle) value
     D    peVersion                        like(GSK_ENUM_ID) value
     D    peValue                     1N   const

     D gskit_cleanup   PR
     D   peAgMark                    10U 0
     D   peReason                    10U 0
     D   peResult                    10U 0
     D   peUserRc                    10U 0

     D https_connect   PR            10I 0
     D   peSockAddr                    *   value
     D   peTimeout                   10I 0 value
     D   peSSLh                        *

     D https_close     PR            10I 0
     D  peSSLh                             like(gsk_handle) value

     D SSL_debug_cert_info...
     D                 PR
     D   peSSLh                            like(GSK_HANDLE) value
     D   peInfoID                    10I 0 value
     D SSL_debug_cert_body...
     D                 PR
     d    peBody                       *   value
     D    peLen                      10I 0 value
     D SSL_debug_cert_elem...
     D                 PR
     D    peElemNo                   10I 0 value
     D    peData                       *   value
     D    peLen                      10I 0 value
     D SSL_validate_cert...
     D                 PR            10i 0
     D   peSSLh                            like(GSK_HANDLE) value
     D SSL_get_proto   PR
     D   peValue                     10a   dim(10)

     D refill          PR            10i 0
     D   peTimeout                   10P 3 value

     D wkEnvH          s               *   inz(*NULL)
     D wkFullAuth      s              1n   inz(*OFF)
     D wkValProc       s               *   inz(*null) procptr
     D wkValUsrDta     s               *   inz(*null)
     D wkGskValProc    s               *   inz(*null) procptr
     D wkGskValUsrDta  s               *   inz(*null)
     D HTTP_DEBUG_LEVEL...
     D                 s             10i 0 inz(1)

     D Kdb             ds                  qualified
     D   Override                     1n   inz(*off)
     D   Path                       256a   varying inz('')
     D   Label                      256a   varying inz('')
     D   Password                   256a   varying inz('')

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Build a new TCP communications driver
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_New     B                   export
     D CommSSL_New     PI              *

     C                   eval      p_CommSSL = xalloc(%size(CommSSL))

     c                   eval      CommSSL = *ALLx'00'
      * Initially, the connection is in plain text mode,
      * so the CommTCP driver is used for most things.
      * (The Upgrade() function will change this, however)
     c                   eval      p_Read      =%paddr('COMMTCP_READ')
     c                   eval      p_BlockRead =%paddr('COMMTCP_BLOCKREAD')
     c                   eval      p_BlockWrite=%paddr('COMMTCP_BLOCKWRITE')
     c                   eval      p_LineRead  =%paddr('COMMTCP_LINEREAD')
     c                   eval      p_LineWrite =%paddr('COMMTCP_LINEWRITE')
     c                   eval      p_Hangup    =%paddr('COMMTCP_HANGUP')
      * Some functions, however, are SSL-specific:
     c                   eval      p_Resolve   =%paddr('COMMSSL_RESOLVE')
     c                   eval      p_Connect   =%paddr('COMMSSL_CONNECT')
     c                   eval      p_Upgrade   =%paddr('COMMSSL_UPGRADE')
     c                   eval      p_Cleanup   =%paddr('COMMSSL_CLEANUP')
     c                   eval      fd = -1
     c                   eval      sslh = *NULL
     c                   eval      sslmode = *off

     c                   eval      bufSize = 131072
     c                   eval      bufBase = xalloc(bufSize)
     c                   eval      bufLen  = 0
     c                   eval      bufCurr = bufBase

     c                   eval      HTTP_DEBUG_LEVEL = getDebugLevel()
     c                   return    p_CommSSL
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Resolve host name
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Resolve...
     P                 B                   export
     D                 PI              *
     D   peHandle                      *   value
     D   peHost                        *   value options(*string)
     D   peService                     *   value options(*string)
     D   pePort                      10I 0 value
     D   peForced                     1N   const

      * Use the standard TCP/IP resolver... nothing SSL-specific here.
     c                   return    CommTcp_Resolve( peHandle
     c                                            : peHost
     c                                            : peService
     c                                            : pePort
     c                                            : peForced )
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * connect to a server
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Connect...
     P                 B                   export
     D CommSSL_Connect...
     D                 PI             1N
     D   peHandle                      *   value
     D   peSockaddr                    *   value
     D   peTimeout                   10P 3 value

     D s               S             10I 0

     c                   eval      p_CommSSL = peHandle

     C*********************************************************
     C* If SSL has not yet been initialized, initialize it
     C* with default values.
     C*********************************************************
     c                   if        wkEnvH = *NULL
     c                   if        https_init(*blanks) = -1
     c                   return    *OFF
     c                   endif
     c                   endif

     C*********************************************************
     C* We "Borrow" the connect() functionality from CommTCPR4
     C*********************************************************
     c                   eval      s = CommTCP_ConnectNonBlock( peSockAddr
     c                                                        : peTimeout )
     C                   if        s < 0
     c                   return    *OFF
     c                   endif

     c                   eval      fd = s
     C                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Upgrade socket to SSL
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Upgrade...
     P                 B                   export
     D CommSSL_Upgrade...
     D                 PI             1N
     D   peHandle                      *   value
     D   peTimeout                   10P 3 value
     D   peEndHost                     *   value options(*string)

     D s               S             10I 0
     D wwfds           S                   like(fdset)
     D wwFlags         S             10U 0
     D wwBufSize       s             10I 0
     D wwTV            s                   like(timeval)
     D wwSSLh          s               *
     D rc              S             10I 0
     D wwValCode       s             10I 0
     D wwSniHost       s            256a   inz(*blanks)

     c                   eval      p_CommSSL = peHandle
     c                   eval      s = fd

      *********************************************************
      *  Get endpoint host name if provided as a parameter
      *  this is used for server name indication (SNI) later
      *********************************************************
     c                   if        %parms >= 3 and peEndHost <> *null
     c                   eval      wwSniHost = %str(peEndHost)
     c                   endif

     C*********************************************************
     C* create a secure socket from the environment handle,
     C*   associate it with our socket, and initialize it.
     C*********************************************************
     c                   eval      rc = gsk_secure_soc_open(wkEnvH: wwSSLh)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSOPEN: 'gsk_sec_soc_open: ' +
     c                               ssl_error(rc))
     c                   callp     close(s)
     c                   return    *OFF
     c                   endif

     c                   eval      rc = gsk_attribute_set_numeric_value(
     c                             wwSSLh: GSK_HANDSHAKE_TIMEOUT: peTimeout)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSSNTO: 'Setting timeout: ' +
     c                               ssl_error(rc))
     c                   callp     close(s)
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif

     c                   eval      rc = gsk_attribute_set_numeric_value(
     c                             wwSSLh: GSK_IBMI_READ_TIMEOUT:
     c                             peTimeout * 1000 )
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSSNTO: 'Setting timeout: ' +
     c                               ssl_error(rc))
     c                   callp     close(s)
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif

     c                   eval      rc = gsk_attribute_set_numeric_value(
     c                              wwSslh: GSK_FD: s)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSSNFD: 'Setting fd: ' +
     c                               ssl_error(rc))
     c                   callp     close(s)
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif

     c                   if        wwSniHost <> *blanks
     c                   eval      rc = gsk_attribute_set_buffer( wwSSLh
     c                                : GSK_SSL_EXTN_SERVERNAME_REQUEST
     c                                : %trim(wwSniHost)
     c                                : %len(%trim(wwSniHost)) )
     c                   if        rc = GSK_OK
     c                   callp     http_dmsg('SNI hostname set to: '
     c                              + %trim(wwSniHost))
     c                   else
     c                   callp     http_dmsg('SNI hostname error: '
     c                              + ssl_error(rc))
     c                   callp     http_dmsg('NOTE: SNI errors are not '
     c                              + 'usually fatal.')
     c                   endif
     c                   endif

     c                   eval      rc = gsk_secure_soc_init(wwSslh)
     c                   if        rc <> GSK_OK
     c                   if        rc = GSK_IBMI_ERROR_TIMED_OUT
     c                   callp     SetError(HTTP_SSTIMO: 'Time out during '+
     c                               'SSL handshake')
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif
     c                   callp     SetError(HTTP_SSSNFD: 'SSL Handshake: ' +
     c                               ssl_error(rc))
     c                   return    *OFF
     c                   endif

     C*********************************************************
     C* Write certificate information to debugging log:
     C*********************************************************
     c                   callp     http_dmsg('---------------------------'+
     c                                       '---------------------------'+
     c                                       '---------------------------'+
     c                                       '----')

     c                   callp     http_dmsg('Dump of server-side certifi'+
     c                                       'cate information:')

     c                   callp     http_dmsg('---------------------------'+
     c                                       '---------------------------'+
     c                                       '---------------------------'+
     c                                       '----')

     c                   callp     gsk_attribute_get_numeric_value(
     c                               wwSSlh                          :
     c                               GSK_CERTIFICATE_VALIDATION_CODE :
     c                               wwValCode                       )

     c                   callp     http_dmsg('Cert Validation Code = '
     c                                      + %trim(%editc(wwValCode:'L')))

     c                   callp     SSL_debug_cert_info(wwSslh
     c                                           : GSK_PARTNER_CERT_INFO )

     c                   if        rc <> GSK_OK
     c                   callp     close(s)
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif

     c                   callp     http_dmsg('Protocol Used: ' +
     c                                SSL_protocol(wwSSLh: *OMIT))


      *********************************************************
      * Validate SSL certificate against user-supplied
      * certificate verification routine
      *********************************************************
     c                   if        SSL_validate_cert(wwSSLh) <> 0
     c                   callp     close(s)
     c                   callp     gsk_secure_soc_close(wwsslh)
     c                   return    *OFF
     c                   endif

     C*********************************************************
     C* Since SSL is now active, use the SSL routines instead
     C* of the plain TCP ones.
     C*********************************************************
     c                   eval      p_Read      =%paddr('COMMSSL_READ')
     c                   eval      p_BlockRead =%paddr('COMMSSL_BLOCKREAD')
     c                   eval      p_BlockWrite=%paddr('COMMSSL_BLOCKWRITE')
     c                   eval      p_LineRead  =%paddr('COMMSSL_LINEREAD')
     c                   eval      p_LineWrite =%paddr('COMMSSL_LINEWRITE')
     c                   eval      p_Hangup    =%paddr('COMMSSL_HANGUP')
     c                   eval      sslh = wwSSLh

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket w/a timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Read...
     P                 B                   export
     D CommSSL_Read...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwLen           S             10I 0

     c                   eval      p_CommSSL = pehandle

     c                   if        refill(peTimeout) = -1
     c                   return    -1
     c                   endif

     c                   eval      wwLen = peSize
     c                   if        wwLen > bufLen
     c                   eval      wwLen = bufLen
     c                   endif

     c                   callp     memcpy(peBuffer: bufCurr: wwLen)
     c                   eval      bufLen = bufLen - wwLen
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + wwLen
     c                   endif

     c                   callp     http_dwrite(peBuffer: wwLen)
     c                   return    wwLen
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket in a fixed-length block
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_BlockRead...
     P                 B                   export
     D CommSSL_BlockRead...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwLen           s             10I 0
     D wwRec           s             10I 0

     c                   eval      wwLen = 0

     c                   dow       peSize > 0

     c                   eval      wwRec = CommSSL_read( peHandle
     c                                                 : peBuffer
     c                                                 : peSize
     c                                                 : peTimeout )
     c                   if        wwRec < 1
     c                   if        wwLen = 0
     c                   return    -1
     c                   else
     c                   return    wwLen
     c                   endif
     c                   endif

     c                   eval      wwLen = wwLen + wwRec
     c                   eval      peBuffer = peBuffer + wwRec
     c                   eval      peSize = peSize - wwRec
     c                   enddo

     c                   return    wwLen
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Write data to socket in a fixed-length block
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_BlockWrite...
     P                 B                   export
     D CommSSL_BlockWrite...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwPos           S               *
     D wwDeref         S              1A   based(wwPos)
     D wwLeft          S             10I 0
     D rc              S             10I 0
     D wwSent          S             10I 0
     D wwLen           S             10I 0

      /if defined(USE_POLL)
     D pfd             ds                  likeds(pollfd_t) dim(1)
      /else
     D wwFds           S                   like(fdset)
     D wwTimeout       S              8A
      /endif

     c                   eval      wwPos = peBuffer
     c                   eval      wwLeft = peSize

     c                   dow       wwLeft > 0

     c                   if        HTTP_DEBUG_LEVEL > 1
     c                   callp     socket_status('CommSSL_BlockWrite'
     c                              : 'gsk_secure_soc_write'
     c                              : fd )
     c                   endif

     c                   eval      rc = gsk_secure_soc_write(sslh:
     c                                wwPos: wwLeft: wwLen )

     c                   if        HTTP_DEBUG_LEVEL > 1
     c                   callp     http_dmsg('CommSSL_BlockWrite(): +
     c                              gsk_secure_soc_write rc=' +
     c                              %char(rc) + ', len=' + %char(wwLen))
     c                   endif

     c                   if        rc <> GSK_OK

     c                   if        rc <> GSK_WOULD_BLOCK
     c                   callp     SetError(HTTP_BWSEND
     c                                     : 'CommSSL_BlockWrite: send: '
     c                                     +  ssl_error(rc) )
     c                   return    -1
     c                   endif

      /if defined(USE_POLL)
     c                   eval      pfd(1) = *ALLx'00'
     c                   eval      pfd(1).fd = fd
     c                   eval      pfd(1).events = POLLOUT

     c                   eval      rc = poll( pfd: 1: peTimeout * 1000)

     c                   if        rc < 0
     c                   callp     SetError(HTTP_BWSELE
     c                                     : 'CommSSL_BlockWrite: poll: '
     c                                     +  %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        rc = 0
     c                   callp     SetError(HTTP_BWTIMO
     c                                     : 'CommSSL_BlockWrite: '
     c                                     +  'timeout!')
     c                   return    -1
     c                   endif

      /else
     c                   eval      p_timeval = %addr(wwTimeout)
     c                   eval      tv_sec = peTimeout
     c                   eval      tv_usec = (peTimeout-tv_sec)*1000000

     c                   callp     CommTCP_FD_ZERO(wwfds)
     c                   callp     CommTCP_FD_SET(fd: wwfds)

     c                   if        HTTP_DEBUG_LEVEL > 1
     c                   callp     select_status( 'CommSSL_BlockWrite'
     c                                          : 'before select'
     c                                          : fd
     c                                          : *null
     c                                          : %addr(wwfds)
     c                                          : *null
     c                                          : %addr(wwTimeout))
     c                   endif


     c                   eval      rc = select(fd+1: *NULL: %addr(wwFds):
     c                               *NULL: %addr(wwTimeout))

     c                   if        HTTP_DEBUG_LEVEL > 1
     c                   callp     select_status( 'CommSSL_BlockWrite'
     c                                          : 'after select'
     c                                          : fd
     c                                          : *null
     c                                          : %addr(wwfds)
     c                                          : *null
     c                                          : %addr(wwTimeout)
     c                                          : rc )
     c                   endif

     c                   if        rc < 0
     c                   callp     SetError(HTTP_BWSELE
     c                                     : 'CommSSL_BlockWrite: select: '
     c                                     +  %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        CommTCP_FD_IsSet(fd: wwfds) = *Off
     c                   callp     SetError(HTTP_BWTIMO
     c                                     : 'CommSSL_BlockWrite: '
     c                                     +  'timeout!')
     c                   return    -1
     c                   endif
      /endif

     c                   iter
     c                   endif

     c                   callp     http_dwrite(wwPos: wwLen)

     c                   eval      wwLeft = wwLeft - wwLen
     c                   eval      wwSent = wwSent + wwLen

     c                   if        wwLeft > 0
     c                   eval      wwPos = wwPos + wwLen
     c                   endif

     c                   enddo

     c                   return    wwSent
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket as a CR/LF terminated line
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_LineRead...
     P                 B                   export
     D CommSSL_LineRead...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     d EOL             c                   const(x'0a')
     d len             s             10I 0
     D left            s             10i 0
     D bufPos          s               *
     D Pos             s               *

     c                   if        peSize <= 0
     c                   return    0
     c                   endif

     c                   eval      p_commSSL = peHandle
     c                   eval      len  = 0
     c                   eval      left = peSize
     c                   eval      bufPos = peBuffer

      *************************************************
      * keep receiving as long as there is space to
      * receive the data into.
      *************************************************
     c                   dow       left > 0

     c                   if        refill(peTimeout) = -1
     c                   return    -1
     c                   endif

     c                   eval      len = bufLen
     c                   if        len > left
     c                   eval      len = left
     c                   endif

      *************************************
      * if linefeed found, copy it and all
      * preceding characters to return buf
      *************************************
     c                   eval      pos = memchr(bufCurr: EOL: len)
     c                   if        pos <> *null
     c                   eval      len = (pos - bufCurr) + 1
     c                   callp     memcpy(bufPos: bufCurr: len)
     c                   eval      bufLen = bufLen - len
     c                   eval      left = left - len
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + len
     c                   endif
     c                   leave
     c                   endif

      *************************************
      * linefeed not found in buffer, so
      * copy everything over to buffer and
      * refill from the socket
      *************************************
     c                   callp     memcpy(bufPos: bufCurr: len)
     c                   eval      bufLen  = bufLen - len
     c                   eval      bufPos = bufPos + len
     c                   eval      left = left - len
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + len
     c                   endif

     c                   enddo

     c                   callp     http_dwrite(peBuffer: peSize - left)
     c                   return    peSize - left
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Write data to socket as a CR/LF terminated line
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_LineWrite...
     P                 B                   export
     D CommSSL_LineWrite...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peBufSize                   10I 0 value
     D   peTimeout                   10P 3 value

     D p_Buf           s               *
     D p_EOL           s               *
     D wwEOL           s              2A   based(p_EOL)
     D rc              s             10I 0

     c                   eval      p_Buf = xalloc(peBufSize+%size(wwEOL))
     c                   callp     memcpy(p_Buf: peBuffer: peBufSize)

     c                   eval      p_EOL = p_Buf + peBufSize
     c                   eval      wwEOL = x'0d0a'

     c                   eval      rc = CommSSL_BlockWrite( peHandle
     c                                            : p_buf
     c                                            : peBufSize+%size(wwEOL)
     c                                            : peTimeout )

     c                   callp     xdealloc(p_buf)
     c                   return    rc
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Disconnect session
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Hangup...
     P                 B                   export
     D CommSSL_Hangup...
     D                 PI             1N
     D   peHandle                      *   value
     c                   eval      p_CommSSL = peHandle
     c                   callp     gsk_secure_soc_close(sslh)
     c                   callp     close(fd)
     c                   return    *ON
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Cleanup module
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommSSL_Cleanup...
     P                 B                   export
     D CommSSL_Cleanup...
     D                 PI             1N
     D   peHandle                      *   value
     c                   eval      p_CommSSL = peHandle
     c                   callp     xdealloc(bufBase)
     c
     c                   callp(e)  xdealloc(peHandle)
     c                   if        %error
     c                   return    *OFF
     c                   else
     c                   return    *ON
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * https_certStore(): Access an alternate certificate store
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_certStore...
     P                 B                   export
     D                 PI
     D  KdbPath                    5000a   varying const
     D  KdbPassword                 256a   varying const
     D  KdbLabel                   5000a   varying const

     c                   if        wkEnvH <> *null
     c                   callp     https_cleanup
     c                   endif

     C                   if        KdbPath = '*CLEAR'
     c                   eval      Kdb = *ALLx'00'
     c                   eval      Kdb.Override = *off
     c                   else
     C                   eval      Kdb.Path     = KdbPath
     C                   eval      Kdb.Password = KdbPassword
     C                   eval      Kdb.Label    = KdbLabel
     C                   eval      Kdb.Override = *On
     c                   endif

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * https_init():  Initialize https (HTTP over SSL/TLS) protocol
      *
      *     peAppID = application ID that you registered program as
      *        in the Digital Certificate Manager
      *         NOTE: You can pass *BLANKS for this parameter if you
      *               you do not wish to register your application
      *               with the digital certificate manager.
      *     peSSLv2 = (optional) Turn SSL version 2 *ON or *OFF
      *     peSSLv3 = (optional) Turn SSL version 3 *ON or *OFF
      *    peTLSv10 = (optional) Turn TLS version 1.0 *ON or *OFF
      *    peTLSv11 = (optional) Turn TLS version 1.1 *ON or *OFF
      *    peTLSv12 = (optional) Turn TLS version 1.2 *ON or *OFF
      *    peTLSv13 = (optional) Turn TLS version 1.3 *ON or *OFF
      *
      *   You must pass all of the SSL/TLS flags or none.  If you
      *   do not pass all three flags, they are ignored.
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_init      B                   export
     D https_init      PI            10I 0
     D  peAppID                     100A   const
     D  peSSLv2                       1N   const options(*nopass)
     D  peSSLv3                       1N   const options(*nopass)
     D  peTLSv10                      1N   const options(*nopass)
     D  peTLSv11                      1N   const options(*nopass)
     D  peTLSv12                      1N   const options(*nopass)
     D  peTLSv13                      1N   const options(*nopass)

     D LastAppId       s            100A   static inz(*blanks)

     D FdBk            ds                  inz
     D    sev                         5u 0
     D    msgno                       5u 0
     D    flags                       1a
     D    facid                       3a
     D    isi                        10u 0

     D CEE4RAGE        PR
     D   procedure                     *   procptr const
     D   feedback                          like(fdbk) options(*omit)

     D CEESGL          PR
     D   cond_rep                          like(fdbk)
     D   q_data_token                10i 0 const options(*omit)
     D   feedback                          like(fdbk) options(*omit)

     D rc              S             10I 0
     D ssl_auth_type   s             10i 0

     D sslpcl          s             10a   dim(10)
     D p               s             10i 0
     D pclmsg          s            256a

     D mySSLV2         s              1n   inz(*off)
     D mySSLV3         s              1n   inz(*off)
     D myTLSV10        s              1n   inz(*on)
     D myTLSV11        s              1n   inz(*on)
     D myTLSV12        s              1n   inz(*on)
     D myTLSV13        s              1n   inz(*on)

     c                   if        %parms >= 2
     c                   eval      mySSLV2 = peSSLV2
     c                   endif

     c                   if        %parms >= 3
     c                   eval      mySSLV3 = peSSLV3
     c                   endif

     c                   if        %parms >= 4
     c                   eval      myTLSV10 = peTLSV10
     c                   endif

     c                   if        %parms >= 5
     c                   eval      myTLSV11 = peTLSV11
     c                   endif

     c                   if        %parms >= 6
     c                   eval      myTLSV12 = peTLSV12
     c                   endif

     c                   if        %parms >= 7
     c                   eval      myTLSV13 = peTLSV13
     c                   endif

     c                   callp     http_dmsg('https_init(): entered')

     c                   if        wkEnvH <> *NULL
     c                             and peAppID <> LastAppId
     c                   callp     https_cleanup
     c                   eval      wkEnvH = *null
     c                   endif

     c                   if        wkEnvH <> *NULL
     c                   callp     SetError(HTTP_GSKENVI: 'SSL environment'+
     c                             ' was already initialized!')
     c                   return    0
     c                   endif

     c                   eval      LastAppId = peAppId

     c                   eval      rc = gsk_environment_open(wkEnvh)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKENVO: 'gsk_env_open: '+
     c                               ssl_error(rc))
     c                   return    -1
     c                   endif

     C* make sure that whatever happens, we clean up the GSKit environment
     C* since it uses a significant portion of memory.
     C                   callp     CEE4RAGE(%paddr('GSKIT_CLEANUP'): FdBk )
     c                   if        sev<>0
     c                   if        facid='CEE' and msgno=12545
     c                   callp     util_diag('HTTPAPI is running in ' +
     c                             'default activation group. ' +
     c                             'https_cleanup must be run explcitly.')
     c                   else
     C                   callp     CEESGL(fdbk: *omit: *omit)
     c                   endif
     c                   endif

      **************************************************************
      *  If https_certStore() was called, use those parameters
      **************************************************************
     c                   if        kdb.Override = *on

     c                   callp     http_dmsg('Overriding to alternate +
     c                               certificate store ' + kdb.Path )

     c                   eval      rc = gsk_attribute_set_buffer( wkEnvH
     c                                : GSK_KEYRING_FILE
     c                                : kdb.Path
     c                                : %len(kdb.Path) )
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKKEYF:'Attempt to use ' +
     c                               kdb.Path + ' cert store: ' +
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

     c                   if        kdb.Password <> ''
     c                   eval      rc = gsk_attribute_set_buffer( wkEnvH
     c                                : GSK_KEYRING_PW
     c                                : kdb.Password
     c                                : %len(kdb.Password) )
     c                   if        rc = GSK_OK
     c                   callp     http_dmsg('- Keyring password +
     c                             has been set.')
     c                   else
     c                   callp     SetError(HTTP_GSKKEYF:'Keyring PW: ' +
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

     c                   if        kdb.Label <> ''
     c                   eval      rc = gsk_attribute_set_buffer( wkEnvH
     c                                : GSK_KEYRING_LABEL
     c                                : kdb.Label
     c                                : %len(kdb.Label) )
     c                   if        rc = GSK_OK
     c                   callp     http_dmsg('- Keyring certificate +
     c                             label has been set.')
     c                   else
     c                   callp     SetError(HTTP_GSKKEYF:'Keyring Label: '+
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

      **************************************************************
      *  If https_certStore() was not used...
      **************************************************************
     c                   else

     C* If peAppId begins with a slash the assume it is the name of the keyring file
     c                   if        %subst(peAppId :1 :1) = '/'
     c                   eval      rc = gsk_attribute_set_buffer(
     c                              wkEnvh: GSK_KEYRING_FILE:
     c                              peAppId: %len(%trim(peAppId)))
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKKEYF:'Attempt to use ' +
     c                               %trim(peAppId) + ' cert store: ' +
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

     C* If no application ID was given, use the *SYSTEM certificate
     C* store as our keyring:
     c                   if        peAppId = *blanks
     c                   eval      rc = gsk_attribute_set_buffer(
     c                              wkEnvh: GSK_KEYRING_FILE:
     c                              '*SYSTEM': 0)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKKEYF:'Attempt to use ' +
     c                               '*SYSTEM cert store: ' +
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

     C* If an application ID was given, use that to associate with the
     C* digital certificate manager:
     c                   if        peAppID <> *blanks
     c                             and %subst(peAppId :1 :1) <> '/'
     c                   eval      rc = gsk_attribute_set_buffer(
     c                              wkEnvh: GSK_IBMI_APPLICATION_ID:
     c                              %trimr(peAppID): 0)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKAPPID:'Setting ID: ' +
     c                               ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

     c                   endif

     C* tell GSKit that we're a client app:
     c                   eval      rc = gsk_attribute_set_enum(wkEnvh:
     c                               GSK_SESSION_TYPE: GSK_CLIENT_SESSION)
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKSTYP: 'Setting ' +
     c                             'session type: ' + ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

     C* How shall we validate the server's certificate?
     c                   if        wkFullAuth = *ON
     c                   eval      ssl_auth_type = GSK_SERVER_AUTH_FULL
     c                   else
     c                   eval      ssl_auth_type = GSK_SERVER_AUTH_PASSTHRU
     c                   endif

      * (Note: GSK_SERVER_AUTH_TYPE isn't available on V5R2 and
      *        earlier without a PTF.  See APAR SE07984 for more
      *        info.  If the current system doesn't support this
      *        option, GSK_ATTRIBUTE_INVALID_ID will be returned. )

     c                   eval      rc = gsk_attribute_set_enum(wkEnvh
     c                                : GSK_SERVER_AUTH_TYPE
     c                                : ssl_auth_type       )
     c                   if        rc <> GSK_OK
     c                               and rc <> GSK_ATTRIBUTE_INVALID_ID
     c                   callp     SetError(HTTP_GSKATYP: 'Setting ' +
     c                             'auth type: ' + ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

     C* How shall we validate a client certificate?
     C* ( FIXME: does this do anything? We don't receive connects
     C*          from any clients...? )
     c*
     c                   if        wkFullAuth = *ON
     c                   eval      ssl_auth_type = GSK_CLIENT_AUTH_FULL
     c                   else
     c                   eval      ssl_auth_type = GSK_CLIENT_AUTH_PASSTHRU
     c                   endif

     c                   eval      rc = gsk_attribute_set_enum(wkEnvh
     c                                : GSK_CLIENT_AUTH_TYPE
     c                                : ssl_auth_type )

     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_GSKATYP: 'Setting ' +
     c                             'auth type: ' + ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

      * Show the QSSLPCL (SSL Protocol) system value in log
     c                   eval      pclmsg = 'QSSLPCL ='
     c                   callp     SSL_get_proto( sslpcl )
     c                   for       p = 1 to %elem(sslpcl)
     c                   if        sslpcl(p) <> *blanks
     c                   eval      pclmsg = %trimr(pclmsg) + ' '
     c                                    + sslpcl(p)
     c                   endif
     c                   endfor

     c                   callp     http_dmsg(pclmsg)

      * Set the allowed SSL/TLS versions here
      *  note that since SSLv2 and SSLv3 are no longer considered secure,
      *  we turn them off unless the caller explicitly turns them on.
      *
     c                   if        SSL_force_protocol( wkEnvh
     c                                               : mySSLv2
     c                                               : mySSLv3
     c                                               : myTLSv10 ) = *OFF
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

      * we enable all TLS versions by default. (But they can be overridden
      * by the caller).  Note that IBM i 7.1 disables TLS v1.1 and v1.2
      * by default -- and since these are more secure than v1.0, we
      * ignore the OS defaults.
     c                   if        TLS_force_protocol( wkEnvh
     c                                               : myTLSv10
     c                                               : myTLSv11
     c                                               : myTLSv12
     c                                               : myTLSv13 ) = *OFF
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif

     C* If requested, set up a certificate validation callback
      /if defined(V5R3_GSKIT)
     c                   if        wkGskValUsrDta <> *null
     c                   callp     gsk_attribute_set_callback( wkEnvh
     c                                : GSK_CERT_VALIDATION_CALLBACK
     c                                : wkGskValUsrDta )
     c                   endif
      /endif

     C* Initialize the SSL environment.  After this, secure sessions
     C*   can be created!
     c                   callp     http_dmsg('initializing GSK environment')

     c                   eval      rc = gsk_environment_init(wkEnvh)
     c                   if        rc <> GSK_OK
     c                   if        rc = GSK_IBMI_ERROR_NOT_REGISTERED
     c                   callp     SetError(HTTP_NOTREG: 'Application ' +
     c                             'is not registered with DCM!')
     c                   callp     https_cleanup
     c                   return    -1
     c                   else
     c                   callp     SetError(HTTP_GSKATYP: 'gsk_env_init: '+
     c                                         ssl_error(rc))
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     c                   endif

     c                   callp     http_dmsg('GSK Environment now available')

     c                   callp     http_dmsg('---------------------------'+
     c                                       '---------------------------'+
     c                                       '---------------------------'+
     c                                       '----')

     c                   callp     http_dmsg('Dump of local-side certific'+
     c                                       'ate information:')

     c                   callp     http_dmsg('---------------------------'+
     c                                       '---------------------------'+
     c                                       '---------------------------'+
     c                                       '----')

     c                   callp     SSL_debug_cert_info(wkEnvh
     c                                           : GSK_LOCAL_CERT_INFO )

     c                   if        rc = GSK_OK
     c                   return    0
     c                   else
     c                   callp     https_cleanup
     c                   return    -1
     c                   endif
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Register your application with the Digital Certificate Manager
      *
      *    peAppID = application ID.  IBM recommends that you do
      *         something like:  COMPANY_COMPONENT_NAME
      *         (example:  QIBM_DIRSRV_REPLICATION)
      *
      *  peLimitCA = set to *On if you want to only want to allow the
      *         certificate authorities registered in D.C.M., or set to
      *         *Off if you'll manage that yourself.
      *
      *   returns 0 for success, or -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_dcm_reg   B                   export
     D https_dcm_reg   PI            10I 0
     D  peAppID                     100A   const
     D  peLimitCA                     1N   const

      ****************************************************************
      *  Register Application for Certificate Use API
      *
      *  When the application is registered, registration information
      *  is stored in the OS/400 registration facility.  You can
      *  re-register using the appropriate control key.
      ****************************************************************
     D QSYRGAP         PR                  ExtPgm('QSYRGAP')
     D   ApplicID                   100A   options(*varsize)
     D   ApplicIDLen                 10I 0 const
     D   ApplicCtrls                256A   const
     D   ErrorCode                32766A   options(*varsize)

      ****************************************************************
      *  Format of Variable-Length Application Control Records
      *  used by the QSYRGAP (Register App For Cert Use) API.
      ****************************************************************
     D p_RGAP_DS1      S               *
     D RGAP_DS1        DS                  BASED(p_RGAP_DS1)
     D   RGAP_DS1_VarRecLen...
     D                               10I 0
     D   RGAP_DS1_AppCtrlKey...
     D                               10I 0
     D   RGAP_DS1_DataLen...
     D                               10I 0
     D   RGAP_DS1_Data...
     D                               50A

      ****************************************************************
      *  Application Control Key Values used by QSYRGAP API
      ****************************************************************
     D RGAP_QEXITPGM   C                   1
     D RGAP_APPTEXT    C                   2
     D RGAP_QMSGF      C                   3
     D RGAP_LIMITCA    C                   4
     D RGAP_REPLACE    C                   5
     D RGAP_THRSAFE    C                   6
     D RGAP_THRACTN    C                   7
     D RGAP_APPTYPE    C                   8

     D SERVER          C                   '1'
     D CLIENT          C                   '2'

     D wwAppID         S            100A
     D wwAppIDLen      S             10I 0
     D wwBuf           s            100A
     D p_NumKeys       S               *
     D wwNumKeys       S             10I 0 based(p_NumKeys)

     D dsEC            DS
     D  dsECBytesP             1      4I 0 INZ(256)
     D  dsECBytesA             5      8I 0 INZ(0)
     D  dsECMsgID              9     15
     D  dsECReserv            16     16
     D  dsECMsgDta            17    256
     c                   callp     http_dmsg('https_dcm_reg(): entered')

     C* Number of control keys:
     c                   eval      p_NumKeys = %addr(wwBuf)
     c                   eval      wwNumKeys = 0

     C* First key is "limit CA" which we set to '0'
     c                   eval      wwNumKeys = wwNumKeys + 1
     c                   eval      p_RGAP_DS1 = %addr(wwBuf) + 4
     c                   eval      RGAP_DS1_VarRecLen = 13
     c                   eval      RGAP_DS1_AppCtrlKey = RGAP_LIMITCA
     c                   eval      RGAP_DS1_DataLen = 1
     c                   eval      %subst(RGAP_DS1_Data:1:1) = peLimitCA

     C* Next key is "replace" which we set to '1' so we can
     C*    run this code each time the program runs without
     C*    getting an error.
     c                   eval      wwNumKeys = wwNumKeys + 1
     c                   eval      p_RGAP_DS1= %addr(wwBuf) + 17
     c                   eval      RGAP_DS1_VarRecLen = 13
     c                   eval      RGAP_DS1_AppCtrlKey = RGAP_REPLACE
     c                   eval      RGAP_DS1_DataLen = 1
     c                   eval      %subst(RGAP_DS1_Data:1:1) = '1'

     C* If this is V5R1 or later, we register as a client
     C*    application, since the DCM now distinguishes client & server
      /if not defined(V4R5_GSKIT)
     c                   eval      wwNumKeys = wwNumKeys + 1
     c                   eval      p_RGAP_DS1= %addr(wwBuf) + 30
     c                   eval      RGAP_DS1_VarRecLen = 13
     c                   eval      RGAP_DS1_AppCtrlKey = RGAP_APPTYPE
     c                   eval      RGAP_DS1_DataLen = 1
     c                   eval      %subst(RGAP_DS1_Data:1:1) = CLIENT
      /endif

     C* Call API, if theres an error, return the msg-id:
     c                   eval      wwAppId = %triml(peAppId)
     c                   eval      wwAppIdLen = %len(%trimr(wwAppId))
     c                   callp(e)  QSYRGAP(wwAppID: wwAppIdLen: wwBuf: dsEC)
     c                   if        %error
     c                   callp     SetError(HTTP_REGERR:'Failure trying ' +
     c                             'to register app.  See job log')
     c                   return    -1
     c                   endif
     c                   if        dsECBytesA > 0
     c                   callp     SetError(HTTP_REGERR:'Register App ' +
     c                             'failed with ' + dsECMsgID)
     c                   return    -1
     c                   endif

     c                   return    0
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  return an error message for a return code from a GSKit API
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P ssl_error       B
     D ssl_error       PI           256A
     D   peErr                       10I 0 value

     D wwMsg           S            256A

     c                   select
     c                   when      peErr = GSK_OK
     c                   eval      wwMsg = 'No error'
     c                   when      peErr = GSK_ERROR_IO
     c                   eval      wwMsg = '(GSKit) I/O: ' +
     c                                     %str(strerror(errno))
     c                   callp     util_diag(wwMsg)
     c                   other
      /if defined(V4R5_GSKIT)
     c                   eval      wwMsg = 'GSKit error #' +
     c                                %trim(%editc(peErr:'P'))
     c                   callp     util_diag(wwMsg)
      /else
     c                   eval      wwMsg = '(GSKit) ' +
     c                                %str(gsk_strerror(peErr))
     c                   callp     util_diag(wwMsg)
      /endif
     c                   endsl

     c                   callp     http_dmsg('ssl_error(' +
     c                                        %trim(%editc(peErr:'P')) +
     c                                        '): ' + wwMsg)

     c                   return    wwMsg
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SSL_protocol():  Get the SSL protocol version of the session
      *
      *       peHandle = (input) SSL Handle
      *      peVersion = (output) GSK_ENUM_ID of the protocol version
      *
      *  returns the human-readable protocol name or '' upon error
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_protocol    B
     D SSL_protocol    PI            20A   varying
     D    peHandle                         like(gsk_handle) value
     D    peVersion                        like(GSK_ENUM_ID)
     D                                     options(*omit)

     D wwName          s             20A   varying
     D wwVersion       s                   like(GSK_ENUM_VALUE)
     D rc              s             10I 0

     c                   eval      rc = gsk_attribute_get_enum( peHandle :
     c                                                 GSK_PROTOCOL_USED :
     c                                                 wwVersion         )
     c                   select
     c                   when      rc <> GSK_OK
     c                   callp     SetError(HTTP_SSPROT: 'SSL_protocol: '+
     c                                   ssl_error(rc))
     c                   return    ''
     c                   when      wwVersion = GSK_PROTOCOL_USED_SSLV2
     c                   eval      wwName = 'SSL Version 2'
     c                   when      wwVersion = GSK_PROTOCOL_USED_SSLV3
     c                   eval      wwName = 'SSL Version 3'
     c                   when      wwVersion = GSK_PROTOCOL_USED_TLSV1
     c                   eval      wwName = 'TLS Version 1.0'
     c                   when      wwVersion = GSK_PROTOCOL_USED_TLSV11
     c                   eval      wwName = 'TLS Version 1.1'
     c                   when      wwVersion = GSK_PROTOCOL_USED_TLSV12
     c                   eval      wwName = 'TLS Version 1.2'
     c                   when      wwVersion = GSK_PROTOCOL_USED_TLSV13
     c                   eval      wwName = 'TLS Version 1.3'
     c                   other
     c                   callp     SetError(HTTP_SSPUNK: 'SSL_protocol: '+
     c                                   'Unknown protocol ' +
     c                                    %trim(%editc(wwVersion:'Z')))
     c                   return    ''
     c                   endsl

     c                   if        %addr(peVersion) <> *NULL
     c                   eval      peVersion = wwVersion
     c                   endif

     c                   return    wwName
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SSL_force_protocol():  Force a particular SSL protocol
      *
      * Note: for TLS v1.1 and higher, see TLS_force_protocol()
      *
      *       peHandle = (input) SSL Handle (to env or to session)
      *        peSSLv2 = (input) Turn SSLv2 *ON or *OFF
      *        peSSLv3 = (input) Turn SSLv3 *ON or *OFF
      *       peTLSv10 = (input) Turn TLSv1.0 *ON or *OFF
      *
      *  returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_force_protocol...
     P                 B
     D SSL_force_protocol...
     D                 PI             1N
     D    peHandle                         like(gsk_handle) value
     D    peSSLv2                     1N   const
     D    peSSLv3                     1N   const
     D    peTLSv10                    1N   const

     D rc              s             10I 0
     D wwSSLv2         s                   like(GSK_ENUM_VALUE)
     D wwSSLv3         s                   like(GSK_ENUM_VALUE)
     D wwTLSv10        s                   like(GSK_ENUM_VALUE)
     D myAction        s              8a

      *************************************************
      * Set the SSLv2 protocol on or off
      *************************************************
     c                   if        peSSLv2 = *ON
     c                   eval      wwSSLv2 = GSK_PROTOCOL_SSLV2_ON
     c                   eval      myAction = 'enabled'
     c                   else
     c                   eval      wwSSLv2 = GSK_PROTOCOL_SSLV2_OFF
     c                   eval      myAction = 'disabled'
     c                   endif

     c                   eval      rc = gsk_attribute_set_enum( peHandle :
     c                                                GSK_PROTOCOL_SSLV2 :
     c                                                wwSSLv2            )
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSPSET: SSL_error(rc))
     c                   return    *OFF
     c                   endif

     c                   callp     http_dmsg('SSL version 2'
     c                              + ' support '
     c                              + %trim(myAction))

      *************************************************
      * Set the SSLv3 protocol on or off
      *************************************************
     c                   if        peSSLv3 = *ON
     c                   eval      wwSSLv3 = GSK_PROTOCOL_SSLV3_ON
     c                   eval      myAction = 'enabled'
     c                   else
     c                   eval      wwSSLv3 = GSK_PROTOCOL_SSLV3_OFF
     c                   eval      myAction = 'disabled'
     c                   endif

     c                   eval      rc = gsk_attribute_set_enum( peHandle :
     c                                                GSK_PROTOCOL_SSLV3 :
     c                                                wwSSLv3            )
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSPSET: SSL_error(rc))
     c                   return    *OFF
     c                   endif

     c                   callp     http_dmsg('SSL version 3'
     c                              + ' support '
     c                              + %trim(myAction))

      *************************************************
      * Set the TLS v1.0 protocol on or off
      *************************************************
     c                   if        peTLSv10 = *ON
     c                   eval      wwTLSv10 = GSK_PROTOCOL_TLSV1_ON
     c                   eval      myAction = 'enabled'
     c                   else
     c                   eval      wwTLSv10 = GSK_PROTOCOL_TLSV1_OFF
     c                   eval      myAction = 'disabled'
     c                   endif

     c                   eval      rc = gsk_attribute_set_enum( peHandle :
     c                                                GSK_PROTOCOL_TLSV1 :
     c                                                wwTLSv10           )
     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_SSPSET: SSL_error(rc))
     c                   return    *OFF
     c                   endif

     c                   callp     http_dmsg('Old interface to '
     c                              + 'TLS version 1.0 support '
     c                              + %trim(myAction))

     c                   return    *ON
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * TLS_force_protocol(): Force a particular TLS version
      *
      *  This requires V7R1 TR6 or newer, so will not give an
      *  error if the options aren't available...
      *
      *       peHandle = (input) SSL Handle (to env or to session)
      *       peTLSv10 = (input) Turn TLSv1.0 *ON or *OFF
      *       peTLSv11 = (input) Turn TLSv1.1 *ON or *OFF
      *       peTLSv12 = (input) Turn TLSv1.2 *ON or *OFF
      *       peTLSv13 = (input) Turn TLSv1.3 *ON or *OFF
      *
      *  returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P TLS_force_protocol...
     P                 B
     D                 PI             1N
     D    peHandle                         like(gsk_handle) value
     D    peTLSv10                    1N   const
     D    peTLSv11                    1N   const
     D    peTLSv12                    1N   const
     D    peTLSv13                    1N   const

     C                   if        TLS_set_version( peHandle
     C                                            : GSK_PROTOCOL_TLSV10
     c                                            : peTLSv10 ) = *OFF
     c                   return    *OFF
     c                   endif

     C                   if        TLS_set_version( peHandle
     C                                            : GSK_PROTOCOL_TLSV11
     c                                            : peTLSv11 ) = *OFF
     c                   return    *OFF
     c                   endif

     C                   if        TLS_set_version( peHandle
     C                                            : GSK_PROTOCOL_TLSV12
     c                                            : peTLSv12 ) = *OFF
     c                   return    *OFF
     c                   endif

     C                   if        TLS_set_version( peHandle
     C                                            : GSK_PROTOCOL_TLSV13
     c                                            : peTLSv13 ) = *OFF
     c                   return    *OFF
     c                   endif

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  TLS_set_version(): Enable/Disable support for TLS versions
      *
      *    peHandle = (input) environment handle
      *   peVersion = (input) GSKit enum for TLS version to set
      *     peValue = (input) *ON to enable, *OFF to disable.
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P TLS_set_version...
     P                 B
     D                 PI             1N
     D    peHandle                         like(gsk_handle) value
     D    peVersion                        like(GSK_ENUM_ID) value
     D    peValue                     1N   const

     D rc              s             10I 0
     D myVersion       s              3a
     D myAction        s              8a
     D myValue         s                   like(GSK_ENUM_VALUE)

     c                   select
     c                   when      peVersion = GSK_PROTOCOL_TLSV10
     c                   eval      myVersion = '1.0'
     c                   when      peVersion = GSK_PROTOCOL_TLSV11
     c                   eval      myVersion = '1.1'
     c                   when      peVersion = GSK_PROTOCOL_TLSV12
     c                   eval      myVersion = '1.2'
     c                   when      peVersion = GSK_PROTOCOL_TLSV13
     c                   eval      myVersion = '1.3'
     c                   other
     c                   callp     SetError( HTTP_TLSSET
     c                                     : 'Unknown TLS version')
     c                   return    *OFF
     c                   endsl

     c                   if        peValue = *ON
     c                   eval      myValue = GSK_TRUE
     c                   eval      myAction = 'enabled'
     c                   else
     c                   eval      myValue = GSK_FALSE
     c                   eval      myAction = 'disabled'
     c                   endif

     c                   eval      rc = gsk_attribute_set_enum( peHandle
     c                                                        : peVersion
     c                                                        : myValue )

     c                   if        rc = GSK_ATTRIBUTE_INVALID_ID
     c                             or rc = GSK_ERROR_UNSUPPORTED
     c                   callp     http_dmsg('Support for TLS '
     c                             + %trim(myVersion)
     c                             + ' unavailable.')
     c                   return    *ON
     c                   endif

     c                   if        rc <> GSK_OK
     c                   callp     SetError(HTTP_TLSSET: SSL_error(rc))
     c                   return    *OFF
     c                   endif

     c                   callp     http_dmsg('TLS version '
     c                              + %trim(myVersion)
     c                              + ' support '
     c                              + %trim(myAction))

     c                   return    *ON
     p                 e

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * gskit_cleanup():  Clean up the GSKit SSL environment
      *
      *      peAgMark = Activation group mark (ignored)
      *      peReason = Reason for cleaning up (ignored)
      *      peResult = Result of cleanup 0=success, 20=fail
      *      peUserRC = User result code (ignored)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P gskit_cleanup   B                   export
     D gskit_cleanup   PI
     D   peAgMark                    10U 0
     D   peReason                    10U 0
     D   peResult                    10U 0
     D   peUserRc                    10U 0

     D rc              s             10I 0

     c                   if        wkEnvH = *NULL
     c                   eval      peResult = 0
     c                   return
     c                   endif

     c                   eval      rc = gsk_environment_close(wkEnvH)

     c                   if        rc = GSK_OK
     c                   eval      wkEnvH = *NULL
     c                   eval      peResult = 0
     c                   else
     c                   eval      peResult = 20
     c                   endif

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * https_cleanup():  Clean up & free storage used by the SSL
      *   environment.
      *
      *  returns 0 if successful, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_cleanup   B                   export
     D https_cleanup   PI            10I 0

     D wwAgMark        s             10U 0 inz(0)
     D wwReason        s             10U 0 inz(0)
     D wwResult        s             10U 0 inz(21)
     D wwUserRC        s             10U 0 inz(0)

     c                   if        wkEnvH = *NULL
     c                   return    0
     c                   endif

     c                   callp     gskit_cleanup( wwAgMark
     c                                          : wwReason
     c                                          : wwResult
     c                                          : wwUserRC)

     c                   if        wwReason = 0
     c                   return    0
     c                   else
     c                   return    -1
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  https_connect():  connect to a HTTP server over TLS/SSL
      *
      *    peSockAddr = ptr to socket address structure for server
      *           (can be obtained by called http_build_sockaddr)
      *    peTimeout  = number of seconds before time-out when connecting
      *       peSSLh  = SSL connection handle
      *
      *  Returns -1 upon failure, or the socket descriptor of the
      *        connection upon success.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_connect   B                   export
     D https_connect   PI            10I 0
     D   peSockAddr                    *   value
     D   peTimeout                   10I 0 value
     D   peSSLh                        *
     c                   callp     SetError( HTTP_NOTSUPP
     c                                     : 'This procedure is no '
     c                                     + 'longer supported.')
     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Close HTTP connection
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_close     B                   export
     D https_close     PI            10I 0
     D  peSSLh                             like(gsk_handle) value
      *  This is now a No-Op
     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * https_idname(): Returns a string that describes an SSL certificate
      *                  data element id (for printing/debugging)
      *
      *       peID = (input) data ID to get name of
      *
      * Returns the human-readable name
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_idname    B                   export
     D https_idname    PI            50A   varying
     D   peID                        10I 0 value
     c                   select
     c                   when      peID = CERT_BODY_DER
     c                   return    'Body (DER)'
     c                   when      peID = CERT_BODY_BASE64
     c                   return    'Body (base64)'
     c                   when      peID = CERT_SERIAL_NUMBER
     c                   return    'Serial Number'
     c                   when      peID = CERT_COMMON_NAME
     c                   return    'Common Name'
     c                   when      peID = CERT_LOCALITY
     c                   return    'Locality'
     c                   when      peID = CERT_STATE_OR_PROVINCE
     c                   return    'State/Province'
     c                   when      peID = CERT_COUNTRY
     c                   return    'Country'
     c                   when      peID = CERT_ORG
     c                   return    'Org Unit'
     c                   when      peID = CERT_ORG_UNIT
     c                   return    'Org'
     c                   when      peID = CERT_DN_PRINTABLE
     c                   return    'DN'
     c                   when      peID = CERT_DN_DER
     c                   return    'DN (DER)'
     c                   when      peID = CERT_POSTAL_CODE
     c                   return    'PostalCode'
     c                   when      peID = CERT_EMAIL
     c                   return    'E-Mail'
     c                   when      peID = CERT_ISSUER_COMMON_NAME
     c                   return    'Issuer CN'
     c                   when      peID = CERT_ISSUER_LOCALITY
     c                   return    'Issuer Locality'
     c                   when      peID = CERT_ISSUER_STATE_OR_PROVINCE
     c                   return    'Issuer State/Province'
     c                   when      peID = CERT_ISSUER_COUNTRY
     c                   return    'Issuer Country'
     c                   when      peID = CERT_ISSUER_ORG
     c                   return    'Issuer Org'
     c                   when      peID = CERT_ISSUER_ORG_UNIT
     c                   return    'Issuer Org Unit'
     c                   when      peID = CERT_ISSUER_DN_PRINTABLE
     c                   return    'Issuer DN'
     c                   when      peID = CERT_ISSUER_DN_DER
     c                   return    'Issuer DN (DER)'
     c                   when      peID = CERT_ISSUER_POSTAL_CODE
     c                   return    'Issuer Postal Code'
     c                   when      peID = CERT_ISSUER_EMAIL
     c                   return    'Issuer E-Mail'
     c                   when      peID = CERT_VERSION
     c                   return    'Version'
     c                   when      peID = CERT_SIGNATURE_ALGORITHM
     c                   return    'signature algorithm'
     c                   when      peID = CERT_VALID_FROM
     c                   return    'not before'
     c                   when      peID = CERT_VALID_TO
     c                   return    'not after'
     c                   when      peID = CERT_PUBLIC_KEY_ALGORITHM
     c                   return    'pub key alg'
     c                   when      peID = CERT_ISSUER_UNIQUEID
     c                   return    'issuer unique id'
     c                   when      peID = CERT_SUBJECT_UNIQUEID
     c                   return    'subject unique id'
     c                   other
     c                   return    'Unknown Field'
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SSL_debug_cert_info(): Print certificate info into debug file
      *
      *      peSSLh = (input) SSL handle
      *    peInfoID = (input) either GSK_LOCAL_CERT_INFO
      *                           or GSK_PARTNER_CERT_INFO
      *
      * Returns the human-readable name
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_debug_cert_info...
     P                 B
     D SSL_debug_cert_info...
     D                 PI
     D   peSSLh                            like(GSK_HANDLE) value
     D   peInfoID                    10I 0 value

     D p_start         s               *
     D rc              s             10I 0
     D wwCount         s             10I 0
     D wwSize          s             10I 0
     D wwEntry         s             10I 0

     c                   eval      rc = gsk_attribute_get_cert_info(
     c                                      peSSLh                 :
     c                                      peInfoID               :
     c                                      p_start                :
     c                                      wwCount                )

     c                   if        rc <> GSK_OK
     c                   callp     http_dmsg(SSL_error(rc))
     c                   return
     c                   endif

     c                   eval      wwCount = wwCount - 1
     c                   eval      wwSize = %size(gsk_cert_data_elem)

     c     0             do        wwCount       wwEntry

     c                   eval      p_gsk_cert_data_elem =
     c                                 p_start + (wwEntry * wwSize)

     c                   select
     c                   when      cert_data_id = CERT_BODY_BASE64
     c                   callp     ssl_debug_cert_body( cert_data_p
     c                                                : cert_data_l )

     c                   when      cert_data_id = CERT_DN_PRINTABLE
     c                             or cert_data_id = CERT_DN_DER
     c                             or cert_data_id = CERT_BODY_DER
     c                             or cert_data_id = CERT_ISSUER_DN_DER
     c                             or cert_data_id =
     c                                           CERT_ISSUER_DN_PRINTABLE

     c                   other
     c                   callp     ssl_debug_cert_elem( cert_data_id
     c                                                : cert_data_p
     c                                                : cert_data_l )
     c                   endsl

     c                   enddo
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Print certificate body into debug file
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_debug_cert_body...
     P                 B
     D SSL_debug_cert_body...
     D                 PI
     d    peBody                       *   value
     D    peLen                      10I 0 value

     D CHUNK           C                   64
     D wwCRLF          s              2A   inz(x'0d25')

     c                   callp     http_xlate( %len(wwCRLF)
     c                                       : wwCRLF
     c                                       : TO_ASCII   )

     c                   callp     http_dmsg('-----BEGIN CERTIFICATE-----')

     c                   dow       peLen > CHUNK
     c                   callp     http_dwrite(peBody: CHUNK)
     c                   callp     http_dwrite(%addr(wwCRLF): %size(wwCRLF))
     c                   eval      peLen = peLen - CHUNK
     c                   eval      peBody = peBody + CHUNK
     c                   enddo

     c                   if        peLen > 0
     c                   callp     http_dwrite(peBody: peLen)
     c                   endif

     c                   callp     http_dmsg('-----END CERTIFICATE-----')
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Print certificate element into debug file
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_debug_cert_elem...
     P                 B
     D SSL_debug_cert_elem...
     D                 PI
     D    peElemNo                   10I 0 value
     D    peData                       *   value
     D    peLen                      10I 0 value

     D wwName          s             52A   varying
     D p_data          s               *
     D wwCRLF          s              2A   inz(x'0d25')

     c                   callp     http_xlate( %len(wwCRLF)
     c                                       : wwCRLF
     c                                       : TO_ASCII   )

     c                   eval      wwName = https_IDname(peElemNo) + ': '

     c                   eval      p_data = %addr(wwName) + VARPREF
     c                   callp     http_xlatep( %len(wwName)
     c                                        : p_data
     c                                        : TO_ASCII )

     c                   callp     http_dwrite(p_data: %len(wwName))
     c                   callp     http_dwrite(peData: peLen)
     c                   callp     http_dwrite(%addr(wwCRLF): %len(wwCRLF))
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Called by HTTPAPIR4 to set any SSL-related exit points.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P commssl_setxproc...
     P                 B                   export
     D commssl_setxproc...
     D                 PI
     D    pePoint                    10I 0 value
     D    peProc                       *   procptr value
     D    peUsrDta                     *   value
     C                   select
     c                   when      pePoint = HTTP_POINT_CERT_VAL
     c                   eval      wkValProc   = peProc
     c                   eval      wkValUsrDta = peUsrDta
     c                   when      pePoint = HTTP_POINT_GSKIT_CERT_VAL
     c                   eval      wkGskValProc   = peProc
     c                   eval      wkGskValUsrDta = peUsrDta
     c                   endsl

     c                   callp     https_cleanup
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SSL_validate_cert(): Verify the partner's certificate
      *
      *      peSSLh = (input) SSL handle
      *
      * Returns the human-readable name
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_validate_cert...
     P                 B
     D SSL_validate_cert...
     D                 PI            10i 0
     D   peSSLh                            like(GSK_HANDLE) value

     D cert_val_callback...
     D                 PR            10i 0 extPRoc(wkValProc)
     D   usrdta                        *   value
     D   id                          10i 0 value
     D   data                     32767a   varying const
     D   errmsg                      80a

     D p_start         s               *
     D rc              s             10I 0
     D wwCount         s             10I 0
     D wwSize          s             10I 0
     D wwEntry         s             10I 0
     D wwCancel        s              1n
     D wwMsg           s             80a
     D Data            s          32767a   based(p_data)
     D wwParm          s          32767a   varying

     c                   if        wkValProc = *null
     c                   return    0
     c                   endif

      ****************************************************
      * Ask GSKit for certificate information
      ****************************************************
     c                   eval      rc = gsk_attribute_get_cert_info(
     c                                      peSSLh                 :
     c                                      GSK_PARTNER_CERT_INFO  :
     c                                      p_start                :
     c                                      wwCount                )

     c                   if        rc <> GSK_OK
     c                   callp     http_dmsg(SSL_error(rc))
     c                   callp     SetError( HTTP_SSLGCI
     c                             : 'gsk_attribute_get_cert_info:'
     c                             + SSL_error(rc) )
     c                   return    -1
     c                   endif

     c                   eval      wwCount = wwCount - 1
     c                   eval      wwSize = %size(gsk_cert_data_elem)

      ****************************************************
      *  Loop through the certificate elements
      ****************************************************
     c     0             do        wwCount       wwEntry

     c                   eval      p_gsk_cert_data_elem =
     c                                 p_start + (wwEntry * wwSize)

     c                   eval      p_data = cert_data_p
     c                   eval      wwParm = %subst(data:1:cert_data_l)

      *****************************
      * If text, convert to EBCDIC
      *****************************
     c                   if        cert_data_id <> CERT_DN_DER
     c                             and cert_data_id <> CERT_BODY_DER
     c                             and cert_data_id <> CERT_ISSUER_DN_DER
     c                             and cert_data_l > 0
     c                   eval      p_data = %addr(wwParm) + VARPREF
     c                   callp     http_xlatep( cert_data_l
     c                                        : p_data
     c                                        : TO_EBCDIC )
     c                   endif

      *****************************
      * Run the callback
      *****************************
     c                   eval      rc = cert_val_callback( wkValUsrDta
     c                                                   : cert_data_id
     c                                                   : wwParm
     c                                                   : wwMsg       )
     c                   if        rc <> 0
     c                   callp     SetError( HTTP_SSLVAL: wwMsg )
     c                   return    -1
     c                   endif

     c                   enddo

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * https_strict(): Force SSL to be strictly validated
      *
      *      peSetting = (input) *ON  = use full validation
      *                          *OFF = use passthru validation
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_strict    B                   export
     D https_strict    PI
     D   peSetting                    1n   const
     c                   if        peSetting <> wkFullAuth
     c                   eval      wkFullAuth = peSetting
     c                   callp     https_cleanup
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SSL_get_proto():  Gets the SSL protocol system value
      *
      *    peValue = (output) array of CHAR(10) containing values
      *
      * Returns -1 upon failure.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SSL_get_proto   B                   export
     D                 PI
     D   peValue                     10a   dim(10)

     D QWCRSVAL        PR                  ExtPgm('QSYS/QWCRSVAL')
     D   RcvVar                   32767a   options(*varsize)
     D   RcvVarLen                   10i 0 const
     D   NbrSysVal                   10i 0 const
     D   SysValName                  10a   dim(1000) options(*varsize)
     D   ErrorCode                32767a   options(*varsize)

     D SysValBuf       DS         32767
     D    NbrRtn                     10i 0
     D    Offsets                    10i 0 dim(1000)

     D p_SysVal        s               *   inz(*null)
     D SysValDS        DS                  based(p_SysVal)
     D    SysVal                     10a
     D    Type                        1a
     D    Status                      1a
     D    DataLen                    10i 0
     D    Data                       10a   dim(10)

     D ErrorCode       DS
     D    BytesPrv                   10i 0 inz(%size(ErrorCode))
     D    BytesAvl                   10i 0 inz(0)

     D SysValName      s             10a   dim(1)

     c                   eval      SysValName(1) = 'QSSLPCL'
     c                   eval      peValue = *blanks

     c                   callp(e)  QWCRSVAL( SysValBuf
     c                                     : %size(SysValBuf)
     c                                     : 1
     c                                     : SysValName
     c                                     : ErrorCode )

     c                   if        %error = *off
     c                             and BytesAvl = 0
     c                             and NbrRtn >= 1
     c                             and Offsets(1) > 0

     c                   eval      p_SysVal = %addr(SysValBuf)
     c                                      + Offsets(1)

     c                   if        SysVal = SysValName(1)
     c                             and Type = 'C'
     c                             and Status = ' '
     c                             and DataLen = 100
     c                   eval      peValue = Data
     c                   endif

     c                   endif

     c                   return
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * refill(): Refill the internal receive buffer
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P refill          B
     D                 PI            10i 0
     D   peTimeout                   10P 3 value

     D len             S             10I 0
     D rc              s             10I 0
     D safetyNet       s             10i 0

      /if defined(USE_POLL)
     D pfd             ds                  likeds(pollfd_t) dim(1)
      /else
     D timeout         S                   like(timeval)
     D readSet         S                   like(fdset)
      /endif

     c                   if        bufLen > 0
     c                   return    0
     c                   endif

     c                   eval      bufCurr = bufBase

      *************************************************
      * loop until some data is received...
      *************************************************
     c                   dou       len > 0

     c                   eval      rc = gsk_secure_soc_read( sslh
     c                                                     : bufCurr
     c                                                     : bufSize
     c                                                     : len )

      ************************************
      *  len = 0 means the socket is
      *  closed, no more data will come
      ************************************
     c                   if        rc = GSK_OK and len = 0
     c                   callp     SetError(HTTP_BRRECV:'CommTCP_read: '+
     c                               'Socket has been shut down.')
     c                   return    -1
     c                   endif

      ************************************
      * GSK_IBMI_ERROR_TIMED_OUT will
      * happen if timeout is detected
      * within GSKit
      ************************************
     c                   if        rc = GSK_IBMI_ERROR_TIMED_OUT
     c                   callp     SetError(HTTP_BRTIME:'CommSSL_Read: '+
     c                               ' timeout!')
     c                   return    -1
     c                   endif

      ************************************
      *  If an error occurred
      *    - GSK_WOULD_BLOCK means to wait
      *         for more data
      *    - another error is an error
      ************************************
     c                   if        rc <> GSK_OK

     c                   if        rc <> GSK_WOULD_BLOCK
     c                   callp     SetError(HTTP_BRRECV:'CommSSL_read: '+
     c                               ' read:' + ssl_error(rc) )
     c                   return    -1
     c                   endif

     c                   eval      safetyNet = safetyNet + 1
     c                   if        safetyNet = 1000
     c                   callp     SetError(HTTP_BRRECV:'CommSSL_read: '+
     c                               ' safetyNet threshold exceeded' )
     c                   return    -1
     c                   endif

      /if defined(USE_POLL)
     c                   eval      pfd(1) = *allx'00'
     c                   eval      pfd(1).fd = fd
     c                   eval      pfd(1).events = POLLIN

     c                   eval      rc = poll( pfd: 1: peTimeout * 1000)
     c                   if        rc < 0
     c                   callp     SetError(HTTP_BRSELE:'CommSSL_read: '+
     c                               'poll: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        rc = 0
     c                   if        peTimeout >= 1
     c                   callp     SetError(HTTP_BRTIME:'CommSSL_read: '+
     c                               'timeout!')
     c                   else
     c                   callp     SetError(HTTP_BRTIME: 'CommSSL_read: '+
     c                               'No 100-Continue (error ignored)')
     c                   endif
     c                   return    -1
     c                   endif
      /else
     c                   eval      p_timeval = %addr(timeout)
     c                   eval      tv_sec = peTimeout
     c                   eval      tv_usec = (peTimeout-tv_sec) * 1000000

     c                   callp     CommTCP_FD_ZERO(readSet)
     c                   callp     CommTCP_FD_SET(fd: readSet)

     c                   eval      rc = select( fd+1
     c                                        : %addr(readSet)
     c                                        : *null
     c                                        : *null
     c                                        : %addr(timeout) )

     c                   if        rc < 0
     c                   callp     SetError(HTTP_BRSELE:'CommSSL_read: '+
     c                               'select: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        CommTCP_FD_ISSET(fd: readSet) = *Off
     c                   if        peTimeout >= 1
     c                   callp     SetError(HTTP_BRTIME:'CommSSL_read: '+
     c                               'time-out!')
     c                   else
     c                   callp     SetError(HTTP_BRTIME: 'CommSSL_read: '+
     c                               'No 100-Continue (error ignored)')
     c                   endif
     c                   return    -1
     c                   endif
      /endif

     c                   endif
      ************************************

     c                   enddo
      *************************************************

     C                   eval      bufLen = bufLen + len
     C                   return    len
     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy ERRNO_H
     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      */                                                                            +

      *
      *
      * COMMTCPR4: Comm driver for TCP (Transmission Control Protocol)
      *
      *
      *> ign: DLTMOD &O/&ON
      *>      CRTRPGMOD MODULE(&O/&ON) SRCFILE(&L/&F) DBGVIEW(&DV)
      *>      UPDSRVPGM SRVPGM(&O/HTTPAPIR4) MODULE((&O/&ON))
      *> ign: DLTMOD &O/&ON

      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT: *NOSHOWCPY)
      /endif
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /copy socket_h
      /copy errno_h
      /copy httpapi_h
      /copy private_h

     D p_CommTcp       s               *
     D CommTcp         ds                  based(p_CommTcp)
     D    p_Resolve...
     D                                 *   procptr
     D    p_Connect...
     D                                 *   procptr
     D    p_Upgrade...
     D                                 *   procptr
     D    p_Read...
     D                                 *   procptr
     D    p_BlockRead...
     D                                 *   procptr
     D    p_BlockWrite...
     D                                 *   procptr
     D    p_LineRead...
     D                                 *   procptr
     D    p_LineWrite...
     D                                 *   procptr
     D    p_Hangup...
     D                                 *   procptr
     D    p_Cleanup...
     D                                 *   procptr
     D    fd                         10I 0
     D    bufSize                    10u 0
     D    bufLen                     10u 0
     D                                4a
     D    bufBase                      *
     D    bufCurr                      *


     D CommTcp_New     PR              *

     D CommTcp_Connect...
     D                 PR             1N
     D   peHandle                      *   value
     D   peSockaddr                    *   value
     D   peTimeout                   10P 3 value

     D CommTcp_Upgrade...
     D                 PR             1N
     D   peHandle                      *   value
     D   peTimeout                   10P 3 value
     D   peEndHost                     *   value options(*string)

     D CommTcp_Read...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommTcp_BlockRead...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommTcp_BlockWrite...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D CommTcp_LineRead...
     D                 PR            10I 0
     D   handle                        *   value
     D   buffer                        *   value
     D   bufsize                     10I 0 value
     D   peTimeout                   10P 3 value

     D CommTcp_LineWrite...
     D                 PR            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peBufSize                   10I 0 value
     D   peTimeout                   10P 3 value

     D CommTcp_Hangup...
     D                 PR             1N
     D   peHandle                      *   value

     D CommTcp_Cleanup...
     D                 PR             1N
     D   peHandle                      *   value

     D Resolve         PR            10i 0
     D   peHost                        *   value options(*string)
     D   peService                     *   value options(*string)
     D   pePort                      10I 0 value
     D   peSockaddr                    *   value

     D CalcBitPos      PR
     D    peDescr                    10I 0
     D    peByteNo                    5I 0
     D    peBitMask                   1A

     D refill          PR            10i 0
     D   peTimeout                   10P 3 value

     D MAXNS           C                   3
     D MAXRESOLVSORT   C                   10

     D res             ds                  IMPORT('_res')
     D   retrans                     10i 0
     D   retry                       10i 0
     D   options                      4a
     D   nscount                     10i 0
     D   nsaddr                      16a   dim(MAXNS)
     D   id                           5u 0
     D   defdname                   256a
     D   reserved0                    1a
     D   reserved1                   13a
     D   dnsrch                        *   dim(7)
     D   sort_list                    8a   dim(MAXRESOLVSORT)
     D   res_h_errno                 10i 0
     D   extended_err                10i 0
     D   ndotssort                    1a
     D   state_data                  27a
     D   internal_use                10i 0 dim(4)
     D   reserved                   444a

     D DNS_Info        PR
     D HTTP_DEBUG_LEVEL...
     D                 s             10i 0 inz(1)

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Build a new TCP communications driver
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_New     B                   export
     D CommTcp_New     PI              *

     C                   eval      p_CommTcp = xalloc(%size(CommTcp))

     c                   eval      CommTcp     =*ALLx'00'
     c                   eval      p_Resolve   =%paddr('COMMTCP_RESOLVE')
     c                   eval      p_Connect   =%paddr('COMMTCP_CONNECT')
     c                   eval      p_Upgrade   =%paddr('COMMTCP_UPGRADE')
     c                   eval      p_Read      =%paddr('COMMTCP_READ')
     c                   eval      p_BlockRead =%paddr('COMMTCP_BLOCKREAD')
     c                   eval      p_BlockWrite=%paddr('COMMTCP_BLOCKWRITE')
     c                   eval      p_LineRead  =%paddr('COMMTCP_LINEREAD')
     c                   eval      p_LineWrite =%paddr('COMMTCP_LINEWRITE')
     c                   eval      p_Hangup    =%paddr('COMMTCP_HANGUP')
     c                   eval      p_Cleanup   =%paddr('COMMTCP_CLEANUP')
     c                   eval      fd = -1

     c                   eval      bufSize = 131072
     c                   eval      bufBase = xalloc(bufSize)
     c                   eval      bufLen  = 0
     c                   eval      bufCurr = bufBase

     c                   eval      HTTP_DEBUG_LEVEL = getDebugLevel()

     c                   return    p_CommTcp
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Resolve a hostname to an IP address
      *
      *    peHandle = handle to this module's data
      *      peHost = hostname to resolve
      *   peService = service name to resolve
      *      pePort = fixed port number to use
      *    peForced = (obsolete??)
      *
      * Returns a pointer to a static sockaddr_in structure.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P commTcp_Resolve...
     P                 B                   export
     D commTcp_Resolve...
     D                 PI              *
     D   peHandle                      *   value
     D   peHost                        *   value options(*string)
     D   peService                     *   value options(*string)
     D   pePort                      10I 0 value
     D   peForced                     1N   const

     D wwAddrBuf       s                   like(sockaddr_in) static

     c                   callp     DNS_Info
     c                   eval      p_CommTcp = peHandle
     c                   if        Resolve( peHost
     c                                    : peService
     c                                    : pePort
     c                                    : %addr(wwAddrBuf) ) = 0
     c                   return    %addr(wwAddrBuf)
     c                   else
     c                   return    *null
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Resolve():  Look up IP address & port number.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P Resolve         B
     D Resolve         PI            10i 0
     D   peHost                        *   value options(*string)
     D   peService                     *   value options(*string)
     D   pePort                      10I 0 value
     D   peSockaddr                    *   value

     c                   eval      p_Sockaddr = peSockaddr
     c                   eval      sockaddr_in = *ALLx'00'
     c                   eval      sin_family = AF_INET
     c                   eval      sin_addr = 0

     c                   eval      HTTP_DEBUG_LEVEL = getDebugLevel()

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   callp     http_dmsg('Resolving host '
     c                                      + %str(peHost))
     c                   endif

      *****************************************************
      * R E S O L V E   H O S T   T O   A D D R E S S
      *****************************************************

      * Check if host is specified as a raw IP address
      * such as http://323223677/path/to/file.html
      *
     c                   if        %scan('.':%str(peHost)) = 0
     c                             and atoll(peHost) > 167772156
     c                   eval      sin_addr = atoll(peHost)

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   callp     http_dmsg('Host appears to be a raw'
     c                                      +' IP address. atoll='
     c                                      + %char(sin_addr) )
     c                   endif

     c                   endif

      * Check if host is specified as a "dotted" IP address
      * such as http://192.168.5.1/path/to/file.html
      *
     c                   if        sin_addr = 0
     c                   eval      sin_addr = inet_addr(peHost)

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   callp     http_dmsg('inet_addr return value '
     c                                      +'for this host is '
     c                                      + %char(sin_addr) )
     c                   endif

     c                   if        sin_addr = INADDR_NONE
     c                   eval      sin_addr = 0
     c                   endif
     c                   endif

      * Try looking up host as a domain name
      * such as http://www.example.com/path/to/file.html
      *
     c                   if        sin_addr = 0
     c                   eval      p_hostent = gethostbyname(peHost)

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   if        p_hostent = *null
     c                   callp     http_dmsg('gethostbyname() returned'
     c                                      + ' *NULL')
     c                   else
     c                   callp     http_dmsg('gethostbyname() returned'
     c                                      + ' ' + %char(h_addr))
     c                   endif
     c                   endif

     c                   if        p_hostent <> *NULL
     c                   eval      sin_addr = h_addr
     c                   endif
     c                   endif

     c                   if        sin_addr = 0
     c                   callp     SetError( HTTP_HOSTNF
     c                                     : 'Host name look up failed.')
     c                   return    -1
     c                   endif

      *****************************************************
      * R E S O L V E   S E R V I C E   T O   P O R T
      *****************************************************

      * If port number was part of URL, use it directly.
      *

     c                   if        HTTP_DEBUG_LEVEL >= 2 and pePort > 0
     c                   callp     http_dmsg('Port specified as number '
     c                                      + %char(pePort))
     c                   endif

     c                   if        pePort > 0
     c                   eval      sin_port = pePort
     c                   return    0
     c                   endif

      * If port number specified as the service name (somehow?)
      * FIXME: I don't think this is possible in v1.10 and up.
      *
     c                   if        atoi(peService) <> 0

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   callp     http_dmsg('Service specified as number'
     c                                      + ' ' + %str(peService))
     c                   endif

     c                   eval      sin_port = atoi(peService)
     c                   return    0
     c                   endif

      * Otherwise, look it up in the system's services table
      *

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   callp     http_dmsg('Looking up service'
     c                                      + ' ' + %str(peService))
     c                   endif

     c                   eval      p_servent = getservbyname( peService
     c                                                      : 'tcp')

      * Or, if all else fails, fall back to a default.
     c                   if        p_servent = *NULL
     c                   if        %str(peService) = 'https'
     c                   eval      sin_port = 443
     c                   else
     c                   eval      sin_port = 80
     c                   endif
     c                   else
     c                   eval      sin_port = s_port
     c                   endif

     c                   if        HTTP_DEBUG_LEVEL >= 2
     c                   if        p_servent = *null
     c                   callp     http_dmsg('Service not found in'
     c                                      + ' service table. Using '
     c                                      + %char(sin_port))
     c                   else
     c                   callp     http_dmsg('Service table returns'
     c                                      + ' port ' + %char(sin_port))
     c                   endif
     c                   endif

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * connect to a server w/blocking socket
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_Connect...
     P                 B                   export
     D CommTcp_Connect...
     D                 PI             1N
     D   peHandle                      *   value
     D   peSockaddr                    *   value
     D   peTimeout                   10P 3 value

     c                   eval      p_commTCP = peHandle
     c                   eval      fd = CommTCP_ConnectNonBlock( peSockAddr
     c                                                         : peTimeout )
     c                   if        fd = -1
     c                   return    *OFF
     c                   else
     c                   return    *ON
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Upgrade connection.
      * (This is a no-op in the TCP driver)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_Upgrade...
     P                 B                   export
     D CommTcp_Upgrade...
     D                 PI             1N
     D   peHandle                      *   value
     D   peTimeout                   10P 3 value
     D   peEndHost                     *   value options(*string)
     C                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  CommTCP_ConnectNonBlock():  Connect to server.
      *
      *  Connection is made while socket is in non-blocking mode.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_ConnectNonBlock...
     P                 B                   export
     D CommTcp_ConnectNonBlock...
     D                 PI            10I 0
     D   peSockaddr                    *   value
     D   peTimeout                   10P 3 value
     D   peTTL                       10i 0 const options(*nopass)

     D s               S             10I 0
     D rc              S             10I 0
     D wwFlags         S             10U 0
     D wwBufSize       s             10I 0
     D wwSize          s             10i 0
     D wwConnErr       s             10i 0
     D wwTTL           s             10i 0
     D wwOpt           s             10i 0
      /if defined(USE_POLL)
     D pfd             ds                  likeds(pollfd_t) dim(1)
      /else
     D wwfds           S                   like(fdset)
     D wwTV            s                   like(timeval)
      /endif

      *********************************************************
      *  Create a socket, and set it's options
      *********************************************************
     c*  Create socket
     c                   eval      s = socket( AF_INET
     c                                       : SOCK_STREAM
     c                                       : IPPROTO_IP  )
     c                   if        s < 0
     c                   callp     SetError(HTTP_SOCERR:'socket(): ' +
     c                                %str(strerror(errno)) )
     c                   return    -1
     c                   endif

      * Force buffer sizes to 128k.
     c                   eval      wwBufSize = 128*1024
     c                   callp     setsockopt(s: SOL_SOCKET: SO_RCVBUF:
     c                                %addr(wwBufSize): %size(wwBufSize))
     c                   callp     setsockopt(s: SOL_SOCKET: SO_SNDBUF:
     c                                %addr(wwBufSize): %size(wwBufSize))

     c*  Put socket in nonblocking mode so
     c*   we can do timeouts, etc.
      /if not defined(ENABLE_BLOCKING)
     c                   eval      wwFlags = fcntl(s: F_GETFL)
     c                   eval      wwFlags = wwFlags + O_NONBLOCK
     c                   callp     fcntl(s: F_SETFL: wwFlags)
      /endif

      * Modify TTL if parameter passed
     c                   if        %parms >= 3
     c                             and peTTL > 0
     c                   eval      wwTTL = peTTL
     c                   callp     setsockopt( s
     c                                       : IPPROTO_IP
     c                                       : IP_TTL
     c                                       : %addr(wwTTL)
     c                                       : %size(wwTTL) )
     c                   endif

      * Disable Nagle's Algorithm
     c                   eval      wwOpt = 1
     c                   eval      rc = setsockopt( s
     c                                            : IPPROTO_TCP
     c                                            : TCP_NODELAY
     c                                            : %addr(wwOpt)
     C                                            : %size(wwOpt) )
     c                   if        rc = 0
     c                   callp     http_dmsg( 'Nagle''s algorithm'
     c                             + ' (TCP_NODELAY) disabled.')
     c                   else
     c                   callp     http_dmsg( 'Error disabling Nagle''s'
     c                             + ' (TCP_NODELAY) algorithm.')
     c                   endif

      *********************************************************
      *  Begin the connection process
      *********************************************************
     c                   if        connect(s: peSockAddr: %size(sockaddr))
     c                               < 0
     c                   if        errno <> EINPROGRESS
     c                   callp     SetError(HTTP_BADCNN: 'connect(1): ' +
     c                                %str(strerror(errno)) )
     c                   callp     close(s)
     c                   return    -1
     c                   endif
     c                   endif

     C*********************************************************
     C* Wait for connect to complete:
     C*   because these are non-blocking sockets, the API's
     C*   above will almost always complete before the
     C*   connection is finished.   This code waits for it:
     C*
     C* NOTE: This is old-school. IBM recommends replacing
     C*       the select() API with poll(). See below for
     C*       the poll() replacement.
     C*********************************************************
      /if not defined(USE_POLL)
     c                   eval      p_timeval = %addr(wwTV)
     c                   eval      tv_sec = peTimeout
     c                   eval      tv_usec = (peTimeout-tv_sec)*1000000

     C                   callp     CommTCP_FD_ZERO(wwfds)
     c                   callp     CommTCP_FD_SET(s: wwfds)

     c                   eval      rc = select( s+1
     c                                        : *NULL
     c                                        : %addr(wwfds)
     c                                        : *NULL
     c                                        : p_timeval )
     c                   select
     c                   when      rc = 0
     c                   callp     close(s)
     c                   callp     SetError(HTTP_CNNTIMO:'Timeout occurred '+
     c                             'while trying to connect to server!')
     c                   return    -1

     c                   when      rc = -1
     c                   callp     close(s)
     c                   callp     SetError(HTTP_BADCNN: 'select(2): ' +
     c                                %str(strerror(errno)) )
     c                   return    -1
     c                   endsl

     c                   if        CommTCP_FD_ISSET(s: wwfds) = *Off
     c                   callp     close(s)
     c                   callp     SetError(HTTP_CNNTIMO:'Timeout occurred '+
     c                             'while trying to connect to server!')
     c                   return    -1
     c                   endif
      /endif

     C*********************************************************
     C* Wait for connect to complete:
     C*   because these are non-blocking sockets, the API's
     C*   above will almost always complete before the
     C*   connection is finished.   This code waits for it:
     C*********************************************************
      /if defined(USE_POLL)
     c                   eval      pfd(1) = *ALLx'00'
     c                   eval      pfd(1).fd = s
     c                   eval      pfd(1).events = POLLOUT

     c                   eval      rc = poll( pfd: 1: peTimeout * 1000)

     c                   select
     c                   when      rc = 0
     c                   callp     close(s)
     c                   callp     SetError(HTTP_CNNTIMO:'Timeout occurred '+
     c                             'while trying to connect to server!')
     c                   return    -1

     c                   when      rc = -1
     c                   callp     close(s)
     c                   callp     SetError(HTTP_BADCNN: 'poll(1): ' +
     c                                %str(strerror(errno)) )
     c                   return    -1
     c                   endsl

     c                   if        %bitand( pfd(1).revents: POLLOUT ) = 0
     c                   callp     close(s)
     c                   callp     SetError(HTTP_CNNTIMO:'Timeout occurred '+
     c                             'while trying to connect to server!')
     c                   return    -1
     c                   endif
      /endif

     C*********************************************************
     C* Was connection successful?
     C*********************************************************
     c                   eval      wwSize = %size(wwConnErr)
     c                   callp     getsockopt( s
     c                                       : SOL_SOCKET
     c                                       : SO_ERROR
     c                                       : %addr(wwConnErr)
     c                                       : wwSize )
     c                   if        wwConnErr <> 0
     c                   callp     SetError(HTTP_BADCNN: 'connect(2): ' +
     c                                %str(strerror(wwConnErr)) )
     c                   callp     close(s)
     c                   return    -1
     c                   endif

     c                   return    s
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket w/a timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_Read...
     P                 B                   export
     D CommTcp_Read...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwLen           S             10I 0

     c                   eval      p_commTcp = pehandle

     c                   if        refill(peTimeout) = -1
     c                   return    -1
     c                   endif

     c                   eval      wwLen = peSize
     c                   if        wwLen > bufLen
     c                   eval      wwLen = bufLen
     c                   endif

     c                   callp     memcpy(peBuffer: bufCurr: wwLen)
     c                   eval      bufLen = bufLen - wwLen
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + wwLen
     c                   endif

     c                   callp     http_dwrite(peBuffer: wwLen)

     c                   return    wwLen
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket in a fixed-length block
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_BlockRead...
     P                 B                   export
     D CommTcp_BlockRead...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwTimeout       S                   like(timeval)
     D wwLen           S             10I 0
     D wwFds           S                   like(fdset)
     D wwLeft          S             10I 0

     c                   eval      wwLeft = peSize

     c                   dow       wwLeft > 0

     c                   eval      wwLen = commTcp_Read( peHandle
     c                                                 : peBuffer
     c                                                 : wwLeft
     c                                                 : peTimeout )
     c                   callp     http_dmsg('got ' + %char(wwLen))
     c                   if        wwLen < 1
     c                   if        wwLeft = peSize
     c                   return    -1
     c                   else
     c                   return    peSize - wwLeft
     c                   endif
     c                   endif

     c                   eval      wwLeft = wwLeft - wwLen
     c                   eval      peBuffer = peBuffer + wwLen
     c                   enddo

     c                   return    peSize
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Write data to socket in a fixed-length block
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_BlockWrite...
     P                 B                   export
     D CommTcp_BlockWrite...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     D wwLen           S             10I 0
     D wwSent          s             10I 0

      /if defined(USE_POLL)
     D pfd             ds                  likeds(pollfd_t) dim(1)
     D rc              s             10i 0
      /else
     D wwTimeout       S                   like(timeval)
     D wwFds           S                   like(fdset)
      /endif

     c                   eval      p_CommTcp = peHandle

     c                   dou       peSize = 0

     c                   eval      wwLen = send(fd: peBuffer: peSize: 0)

     c                   if        wwLen<1 and errno<>EAGAIN
     c                   callp     SetError(HTTP_BWSEND:'blockwrite: '+
     c                               'send: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

      /if defined(USE_POLL)
     c                   if        wwLen < 1

     c                   eval      pfd(1).fd = fd
     c                   eval      pfd(1).events = POLLOUT
     c                   eval      pfd(1).revents = 0

     c                   eval      rc = poll( pfd
     c                                      : %elem(pfd)
     c                                      : peTimeout * 1000 )
     c                   if        rc < 0
     c                   callp     SetError(HTTP_BWSELE:'blockwrite: '+
     c                               'poll: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        rc = 0
     c                   callp     SetError(HTTP_BWTIME:'blockwrite: '+
     c                               ' timeout!')
     c                   return    -1
     c                   endif

     c                   iter
     c                   endif
      /else
     c                   if        wwLen < 1

     c                   eval      p_timeval = %addr(wwTimeout)
     c                   eval      tv_sec = peTimeout
     c                   eval      tv_usec = (peTimeout-tv_sec)*1000000

     c                   callp     CommTCP_FD_ZERO(wwfds)
     c                   callp     CommTCP_FD_SET(fd: wwfds)

     c                   if        select(fd+1:*NULL:%addr(wwfds):*NULL:
     c                               %addr(wwTimeout) ) < 0
     c                   callp     SetError(HTTP_BWSELE:'blockwrite: '+
     c                               'select: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        CommTCP_FD_ISSET(fd: wwfds) = *Off
     c                   callp     SetError(HTTP_BWTIME:'blockwrite: '+
     c                               ' time-out!')
     c                   return    -1
     c                   endif

     c                   iter
     c                   endif
      /endif

     c                   callp     http_dwrite(peBuffer: wwLen)

     c                   eval      wwSent = wwSent + wwLen
     c                   eval      peSize = peSize - wwLen

     c                   if        peSize > 0
     c                   eval      peBuffer = peBuffer + wwLen
     c                   endif

     c                   enddo

     c                   return    wwSent
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read data from socket as a CR/LF terminated line
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_LineRead...
     P                 B                   export
     D CommTcp_LineRead...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peSize                      10I 0 value
     D   peTimeout                   10P 3 value

     d EOL             c                   const(x'0a')
     d len             s             10I 0
     D left            s             10i 0
     D bufPos          s               *
     D Pos             s               *

     c                   if        peSize <= 0
     c                   return    0
     c                   endif

     c                   eval      p_commTcp = peHandle
     c                   eval      len  = 0
     c                   eval      left = peSize
     c                   eval      bufPos = peBuffer

      *************************************************
      * keep receiving as long as there is space to
      * receive the data into.
      *************************************************
     c                   dow       left > 0

     c                   if        refill(peTimeout) = -1
     c                   return    -1
     c                   endif

     c                   eval      len = bufLen
     c                   if        len > left
     c                   eval      len = left
     c                   endif

      *************************************
      * if linefeed found, copy it and all
      * preceding characters to return buf
      *************************************
     c                   eval      pos = memchr(bufCurr: EOL: len)
     c                   if        pos <> *null
     c                   eval      len = (pos - bufCurr) + 1
     c                   callp     memcpy(bufPos: bufCurr: len)
     c                   eval      bufLen = bufLen - len
     c                   eval      left = left - len
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + len
     c                   endif
     c                   leave
     c                   endif

      *************************************
      * linefeed not found in buffer, so
      * copy everything over to buffer and
      * refill from the socket
      *************************************
     c                   callp     memcpy(bufPos: bufCurr: len)
     c                   eval      bufLen = bufLen - len
     c                   eval      bufPos = bufPos + len
     c                   eval      left = left - len
     c                   if        bufLen > 0
     c                   eval      bufCurr = bufCurr + len
     c                   endif

     c                   enddo

     c                   callp     http_dwrite(peBuffer: peSize - left)
     c                   return    peSize - left
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Write data to socket as a CR/LF terminated line
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_LineWrite...
     P                 B                   export
     D CommTcp_LineWrite...
     D                 PI            10I 0
     D   peHandle                      *   value
     D   peBuffer                      *   value
     D   peBufSize                   10I 0 value
     D   peTimeout                   10P 3 value

     D p_Buf           s               *
     D p_EOL           s               *
     D wwEOL           s              2A   based(p_EOL)
     D rc              s             10I 0

     c                   eval      p_Buf = xalloc(peBufSize + %size(wwEOL))
     c                   callp     memcpy(p_Buf: peBuffer: peBufSize)

     c                   eval      p_EOL = p_Buf + peBufSize
     c                   eval      wwEOL = x'0d0a'

     c                   eval      rc = CommTcp_BlockWrite( peHandle
     c                                                    : p_buf
     c                                                    : peBufSize
     c                                                      + %size(wwEOL)
     c                                                    : peTimeout )

     c                   callp     xdealloc(p_buf)
     c                   return    rc
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Disconnect session
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_Hangup...
     P                 B                   export
     D CommTcp_Hangup...
     D                 PI             1N
     D   peHandle                      *   value
     c                   eval      p_CommTcp = peHandle
     c                   if        close(fd) = 0
     c                   return    *ON
     c                   else
     c                   return    *OFF
     c                   endif
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Cleanup module
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTcp_Cleanup...
     P                 B                   export
     D CommTcp_Cleanup...
     D                 PI             1N
     D   peHandle                      *   value
     c                   eval      p_CommTcp = peHandle
     c                   callp     xdealloc(bufBase)

     c                   callp(e)  xdealloc(peHandle)

     c                   if        %error
     c                   return    *OFF
     c                   else
     c                   return    *ON
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Set a File Descriptor in a set ON...  for use w/Select()
      *
      *      peFD = descriptor to set on
      *      peFDSet = descriptor set
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTCP_FD_SET...
     P                 B                   EXPORT
     D CommTCP_FD_SET...
     D                 PI
     D   peFD                        10I 0
     D   peFDSet                           like(fdset)
     D wkByteNo        S              5I 0
     D wkMask          S              1A
     D wkByte          S              1A
     C                   callp     CalcBitPos(peFD:wkByteNo:wkMask)
     c                   eval      wkByte = %subst(peFDSet:wkByteNo:1)
     c                   biton     wkMask        wkByte
     c                   eval      %subst(peFDSet:wkByteNo:1) = wkByte
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Determine if a file desriptor is on or off...
      *
      *      peFD = descriptor to set off
      *      peFDSet = descriptor set
      *
      *   Returns *ON if its on, or *OFF if its off.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTCP_FD_ISSET...
     P                 B                   EXPORT
     D CommTCP_FD_ISSET...
     D                 PI             1N
     D   peFD                        10I 0
     D   peFDSet                           like(fdset)
     D wkByteNo        S              5I 0
     D wkMask          S              1A
     D wkByte          S              1A
     C                   callp     CalcBitPos(peFD:wkByteNo:wkMask)
     c                   eval      wkByte = %subst(peFDSet:wkByteNo:1)
     c                   testb     wkMask        wkByte                   88
     c                   return    *IN88
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Clear All descriptors in a set.  (also initializes at start)
      *
      *      peFDSet = descriptor set
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CommTCP_FD_ZERO...
     P                 B                   EXPORT
     D CommTCP_FD_ZERO...
     D                 PI
     D   peFDSet                           like(fdset)
     C                   eval      peFDSet = *ALLx'00'
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This is used by the CommTCP_FD_SET/CommTCP_FD_ISSET procs to
      *  determine which byte in the 28-char string to check,
      *  and a bitmask to check the individual bit...
      *
      *  peDescr = descriptor to check in the set.
      *  peByteNo = byte number (returned)
      *  peBitMask = bitmask to set on/off or test
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P CalcBitPos      B
     D CalcBitPos      PI
     D    peDescr                    10I 0
     D    peByteNo                    5I 0
     D    peBitMask                   1A
     D dsMakeMask      DS
     D   dsZeroByte            1      1A
     D   dsMask                2      2A
     D   dsBitMult             1      2U 0 INZ(0)
     C     peDescr       div       32            wkGroup           5 0
     C                   mvr                     wkByteNo          2 0
     C                   div       8             wkByteNo          2 0
     C                   mvr                     wkBitNo           2 0
     C                   eval      wkByteNo = 4 - wkByteNo
     c                   eval      peByteNo = (wkGroup * 4) + wkByteNo
     c                   eval      dsBitMult = 2 ** wkBitNo
     c                   eval      dsZeroByte = x'00'
     c                   eval      peBitMask = dsMask
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * DNS_Info(): Display DNS Resolver information
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P DNS_Info        B
     D DNS_Info        PI

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                        8A
     D  input                         4A
     D  output_len                   10I 0 value

     D opt             s              1a
     D hexopt          s              8a
     D res_init        PR                  extproc('res_init')
     D rc              s             10i 0
     D msg             s            256a
     D x               s             10i 0

      *************************************************
      * Initialize DNS resolver, if not already done
      *************************************************
     C                   callp     res_init

     c                   eval      opt = %subst(options:4:1)
     C                   testb     x'10'         opt                      99
     c                   if        *in99 = *OFF
     c                   callp     http_dmsg('DNS Resolver doesnt init, '
     c                                      + 'errno='
     c                                      + %trim(%editc(errno:'P')) )
     c                   return
     c                   endif

      *************************************************
      * Log a bunch of various DNS options
      *************************************************
     C                   callp     http_dmsg( 'DNS resolver retrans: '
     C                               + %trim(%editc(retrans:'P')) )

     C                   callp     http_dmsg( 'DNS resolver retry  : '
     C                               + %trim(%editc(retry:'P')) )

     C                   callp     cvthc(hexopt: options: %size(hexopt))
     C                   callp     http_dmsg( 'DNS resolver options: '
     C                               + 'x''' + hexopt + '''' )

     C                   callp     http_dmsg( 'DNS default domain: '
     C                               + %str(%addr(defdname)) )

      *************************************************
      *  List name servers referenced by resolver
      *************************************************
     c                   if        nscount = 0
     c                   eval      msg = 'WARNING: No name servers '
     c                                    + 'are configured for DNS '
     c                                    + 'resolution! You will not '
     c                                    + 'be able to contact '
     c                                    + 'Internet hosts! '
     c                                    + 'See http://www.scottklement'
     c                                    + '.com/httpapi/dns.html for '
     c                                    + 'more information.'
     c                   callp     http_dmsg(msg)
     c                   callp     http_diag(msg)
     c                   return
     c                   endif

     c                   do        nscount       x
     c                   eval      p_sockaddr = %addr(nsaddr(x))
     c                   callp     http_dmsg('DNS server found: '
     c                                      + %str(inet_ntoa(sin_addr)) )
     c                   enddo
     c                   return
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * refill(): Refill the internal receive buffer
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P refill          B
     D                 PI            10i 0
     D   peTimeout                   10P 3 value

     D len             S             10I 0
     D rc              s             10I 0
     D safetyNet       s             10i 0

      /if defined(USE_POLL)
     D pfd             ds                  likeds(pollfd_t) dim(1)
      /else
     D timeout         S                   like(timeval)
     D readSet         S                   like(fdset)
      /endif

     c                   if        bufLen > 0
     c                   return    0
     c                   endif

     c                   eval      bufCurr = bufBase

      *************************************************
      * loop until some data is received...
      *************************************************
     c                   dou       len > 0

     c                   eval      len = recv(fd: bufCurr: bufsize: 0)

      ************************************
      *  len = 0 means the socket is
      *  closed, no more data will come
      ************************************
     c                   if        len = 0
     c                   callp     SetError(HTTP_BRRECV:'CommTCP_read: '+
     c                               'Socket has been shut down.')
     c                   return    -1
     c                   endif

      ************************************
      *  If an error occurred
      *    - EWOULDBLOCK means to wait
      *         for more data
      *    - another error is an error
      ************************************
     c                   if        len < 0

     c                   if        errno <> EWOULDBLOCK
     c                   callp     SetError(HTTP_BRRECV:'CommTCP_read: '+
     c                               'recv: ' + %str(strerror(errno)))
     c                   return    -1
     c                   endif

     c                   eval      safetyNet = safetyNet + 1
     c                   if        safetyNet = 1000
     c                   callp     SetError(HTTP_BRRECV:'CommTCP_read: '+
     c                               ' safetyNet threshold exceeded' )
     c                   return    -1
     c                   endif

      /if defined(USE_POLL)
     c                   eval      pfd(1) = *ALLx'00'
     c                   eval      pfd(1).fd = fd
     c                   eval      pfd(1).events = POLLIN

     c                   eval      rc = poll( pfd: 1: peTimeout * 1000)

     c                   if        rc < 0
     c                   callp     SetError(HTTP_BRSELE:'CommTCP_read: '+
     c                               'poll: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        rc = 0
     c                   if        peTimeout >= 1
     c                   callp     SetError(HTTP_BRTIME:'CommTCP_read: '+
     c                               'timeout!')
     c                   else
     c                   callp     SetError(HTTP_BRTIME: 'CommTCP_read: '+
     c                               'No 100-Continue (error ignored)')
     c                   endif
     c                   return    -1
     c                   endif
      /else
     c                   eval      p_timeval = %addr(timeout)
     c                   eval      tv_sec = peTimeout
     c                   eval      tv_usec = (peTimeout-tv_sec) * 1000000

     c                   callp     CommTCP_FD_ZERO(readSet)
     c                   callp     CommTCP_FD_SET(fd: readSet)

     c                   eval      rc = select( fd+1
     c                                        : %addr(readSet)
     c                                        : *null
     c                                        : *null
     c                                        : %addr(timeout) )

     c                   if        rc < 0
     c                   callp     SetError(HTTP_BRSELE:'CommTCP_read: '+
     c                               'select: ' + %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        CommTCP_FD_ISSET(fd: readSet) = *Off
     c                   if        peTimeout >= 1
     c                   callp     SetError(HTTP_BRTIME:'CommTCP_read: '+
     c                               'time-out!')
     c                   else
     c                   callp     SetError(HTTP_BRTIME: 'CommTCP_read: '+
     c                               'No 100-Continue (error ignored)')
     c                   endif
     c                   return    -1
     c                   endif
      /endif

     c                   endif
      ************************************

     c                   enddo
      *************************************************

     C                   eval      bufLen = bufLen + len
     C                   return    len
     P                 E


      /define ERRNO_LOAD_PROCEDURE
      /copy ERRNO_H
     /*-                                                                            +
      * Copyright (c) 2001-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      *  This member contains routines that are deprecated or no longer
      *  supported, and are only included to maintain backward compatibility
      *  with old releases of HTTPAPI
      */

      /copy VERSION

      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*NOSHOWCPY: *SRCSTMT: *NODEBUGIO)
      /endif
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /copy PRIVATE_H

     D HTTP_NOTSUPP    C                   CONST(61)

     D http_DEPRECATED_url_get...
     D                 PR            10I 0
     D  peURL                       256A   const
     D  peFileName                  256A   const
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peModTime                      Z   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_DEPRECATED_url_post...
     D                 PR            10I 0
     D  peURL                       256A   const
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFilename                  256A   const
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_DEPRECATED_url_get_raw...
     D                 PR            10I 0
     D  peURL                       256A   const
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peModTime                      Z   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_DEPRECATED_url_post_raw...
     D                 PR            10I 0
     D  peURL                       256A   const
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_getraw...
     D                 PR            10I 0
     D  peSock                       10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)

     D http_postraw...
     D                 PR            10I 0
     D  peSock                       10I 0 value
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)

     D https_getraw...
     D                 PR            10I 0
     D  peSock                         *   value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)

     D https_postraw...
     D                 PR            10I 0
     D  peSock                         *   value
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)

     D http_connect    PR            10I 0
     D   peSockAddr                    *   value
     D   peTimeout                   10I 0 value

     D http_url_encoder_addvar...
     D                 PR             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peData                       *   value
     D    peDataSize                 10I 0 value

     D http_url_encoder_addvar_s...
     D                 PR             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peValue                   256A   varying value

     D HTTP_SetTables  PR            10I 0
     D   peASCII                     10A   const
     D   peEBCDIC                    10A   const

     D http_build_sockaddr...
     D                 PR            10I 0
     D   peHost                     256A   const
     D   peService                   32A   const
     D   peForcePort                 10I 0 value
     D   peSockAddr                    *

     D http_ParseURL   PR            10I 0
     D  peURL                       256A   const
     D  peService                    32A
     D  peUserName                   32A
     D  pePassword                   32A
     D  peHost                      256A
     D  pePort                       10I 0
     D  pePath                      256A


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * DEPRECATED:  All new code should call http_url_get_raw().
      *              No features should be added to this procedure.
      *              This is for backward-compatibility only.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_DEPRECATED_url_get...
     P                 B                   export
     D http_DEPRECATED_url_get...
     D                 PI            10I 0
     D  peURL                       256A   const
     D  peFileName                  256A   const
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peModTime                      Z   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_url_get    PR            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peFilename                32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     c                   select
     c                   when      %parms = 2
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         )
     c                   when      %parms = 3
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         : peTimeout
     c                                         )
     c                   when      %parms = 4
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         : peTimeout
     c                                         : peUserAgent
     c                                         )
     c                   when      %parms = 5
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         : peTimeout
     c                                         : peUserAgent
     c                                         : peModTime
     c                                         )
     c                   when      %parms = 6
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         : peTimeout
     c                                         : peUserAgent
     c                                         : peModTime
     c                                         : peContentType
     c                                         )
     c                   when      %parms = 7
     c                   return    http_url_get( %trimr(peURL)
     c                                         : %trimr(peFileName)
     c                                         : peTimeout
     c                                         : peUserAgent
     c                                         : peModTime
     c                                         : peContentType
     c                                         : peSoapAction
     c                                         )
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * DEPRECATED:  All new code should call http_url_get_raw().
      *              No features should be added to this procedure.
      *              This is for backward-compatibility only.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_DEPRECATED_url_post...
     P                 B                   export
     D http_DEPRECATED_url_post...
     D                 PI            10I 0
     D  peURL                       256A   const
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFilename                  256A   const
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)

     D http_url_post   PR            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFilename                32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     c                   select
     c                   when      %parms = 4
     c                   return    http_url_post( %trimr(peURL)
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : %trimr(peFileName)
     c                                          )
     c                   when      %parms = 5
     c                   return    http_url_post( %trimr(peURL)
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : %trimr(peFileName)
     c                                          : peTimeout
     c                                          )
     c                   when      %parms = 6
     c                   return    http_url_post( %trimr(peURL)
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : %trimr(peFileName)
     c                                          : peTimeout
     c                                          : peUserAgent
     c                                          )
     c                   when      %parms = 7
     c                   return    http_url_post( %trimr(peURL)
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : %trimr(peFileName)
     c                                          : peTimeout
     c                                          : peUserAgent
     c                                          : peContentType
     c                                          )
     c                   when      %parms = 8
     c                   return    http_url_post( %trimr(peURL)
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : %trimr(peFileName)
     c                                          : peTimeout
     c                                          : peUserAgent
     c                                          : peContentType
     c                                          : peSoapAction
     c                                          )
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * DEPRECATED:  All new code should call http_url_get_raw().
      *              No features should be added to this procedure.
      *              This is for backward-compatibility only.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_DEPRECATED_url_get_raw...
     P                 B                   export
     D http_DEPRECATED_url_get_raw...
     D                 PI            10I 0
     D  peURL                       256A   const
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peModTime                      Z   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)
     D http_url_get_raw...
     D                 PR            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
     c                   select
     c                   when      %parms = 3
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             )
     c                   when      %parms = 4
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             : peTimeout
     c                                             )
     c                   when      %parms = 5
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             : peTimeout
     c                                             : peUserAgent
     c                                             )
     c                   when      %parms = 6
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             : peTimeout
     c                                             : peUserAgent
     c                                             : peModTime
     c                                             )
     c                   when      %parms = 7
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             : peTimeout
     c                                             : peUserAgent
     c                                             : peModTime
     c                                             : peContentType
     c                                             )
     c                   when      %parms = 8
     c                   return    http_url_get_raw( %trimr(peURL)
     c                                             : peFD
     c                                             : peProc
     c                                             : peTimeout
     c                                             : peUserAgent
     c                                             : peModTime
     c                                             : peContentType
     c                                             : peSOAPAction
     c                                             )
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * DEPRECATED:  All new code should call http_url_get_raw().
      *              No features should be added to this procedure.
      *              This is for backward-compatibility only.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_DEPRECATED_url_post_raw...
     P                 B                   export
     D http_DEPRECATED_url_post_raw...
     D                 PI            10I 0
     D  peURL                       256A   const
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass)
     D  peContentType                64A   const options(*nopass)
     D  peSOAPAction                 64A   const options(*nopass)
     D http_url_post_raw...
     D                 PR            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
     c                   select
     c                   when      %parms = 5
     c                   return    http_url_post_raw( %trimr(peURL)
     c                                              : pePostData
     c                                              : pePostDataLen
     c                                              : peFD
     c                                              : peProc
     c                                              )
     c                   when      %parms = 6
     c                   return    http_url_post_raw( %trimr(peURL)
     c                                              : pePostData
     c                                              : pePostDataLen
     c                                              : peFD
     c                                              : peProc
     c                                              : peTimeout
     c                                              )
     c                   when      %parms = 7
     c                   return    http_url_post_raw( %trimr(peURL)
     c                                              : pePostData
     c                                              : pePostDataLen
     c                                              : peFD
     c                                              : peProc
     c                                              : peTimeout
     c                                              : peUserAgent
     c                                              )
     c                   when      %parms = 8
     c                   return    http_url_post_raw( %trimr(peURL)
     c                                              : pePostData
     c                                              : pePostDataLen
     c                                              : peFD
     c                                              : peProc
     c                                              : peTimeout
     c                                              : peUserAgent
     c                                              : peContentType
     c                                              )
     c                   when      %parms = 9
     c                   return    http_url_post_raw( %trimr(peURL)
     c                                              : pePostData
     c                                              : pePostDataLen
     c                                              : peFD
     c                                              : peProc
     c                                              : peTimeout
     c                                              : peUserAgent
     c                                              : peContentType
     c                                              : peSoapAction
     c                                              )
     c                   endsl
     P                 E




      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_ParseURL(): Parse URL into it's component parts
      *
      *  Breaks a uniform resource locator (URL) into it's component
      *  pieces for use with the http: or https: protocols.  (would also
      *  work for FTP with minor tweaks)
      *
      *  peURL = URL that needs to be parsed.
      *  peService = service name from URL (i.e. http or https)
      *  peUserName = user name given, or *blanks
      *  pePassword = password given, or *blanks
      *  peHost = hostname given in URL. (could be domain name or IP)
      *  pePort = port number to connect to, if specified, otherwise 0.
      *  pePath = remaining path/request for server.
      *
      *  returns -1 upon failure, or 0 upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_ParseURL   B                   export
     D http_ParseURL   PI            10I 0
     D  peURL                       256A   const
     D  peService                    32A
     D  peUserName                   32A
     D  pePassword                   32A
     D  peHost                      256A
     D  pePort                       10I 0
     D  pePath                      256A

     D wwHost          s           1024A   varying
     D wwPath          s          32767A   varying
     D rc              s             10I 0

     d http_long_ParseURL...
     D                 PR            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peService                    32A
     D  peUserName                   32A
     D  pePassword                   32A
     D  peHost                      256A
     D  pePort                       10I 0
     D  pePath                    32767A   varying

     c                   eval      rc = http_long_ParseURL( %trimr(peURL)
     c                                                    : peService
     c                                                    : peUserName
     c                                                    : pePassword
     c                                                    : peHost
     c                                                    : pePort
     c                                                    : wwPath )

     c                   eval       pePath = wwPath

     c                   return     rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_build_sockaddr():  Build a socket address structure for a host
      *
      *        peHost = hostname to build sockaddr_in for
      *     peService = service name (or port) to build sockaddr_in for
      *   peForcePort = numeric port to force entry to, overrides peService
      *    peSockAddr = pointer to a location to place a sockaddr_in into.
      *
      *   returns -1 upon failure, 0 upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_build_sockaddr...
     P                 B                   export
     D http_build_sockaddr...
     D                 PI            10I 0
     D   peHost                     256A   const
     D   peService                   32A   const
     D   peForcePort                 10I 0 value
     D   peSockAddr                    *

     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')

     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_connect():  connect to an HTTP server
      *
      *    peSockAddr = ptr to socket address structure for server
      *           (can be obtained by called http_build_sockaddr)
      *    peTimeout  = number of seconds before time-out when connecting
      *
      *  Returns -1 upon failure, or the socket descriptor of the
      *        connection upon success.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_connect    B                   export
     D http_connect    PI            10I 0
     D   peSockAddr                    *   value
     D   peTimeout                   10I 0 value

     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')

     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_getraw():  a blast from the past.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_getraw...
     P                 B                   export
     D http_getraw...
     D                 PI            10I 0
     D  peSock                       10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)
     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')
     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_postraw():  I think not.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_postraw...
     P                 B                   export
     d http_postraw...
     D                 PI            10I 0
     D  peSock                       10I 0 value
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)
     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')
     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  https_getraw():  Receive an http document
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_getraw...
     P                 B                   export
     D https_getraw...
     D                 PI            10I 0
     D  peSock                         *   value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)
     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')
     c                   return    -1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  https_postraw:  Post data to a CGI script or server function
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P https_postraw...
     P                 B                   export
     D https_postraw...
     D                 PI            10I 0
     D  peSock                         *   value
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peProcedure                    *   value procptr
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                   256A   const
     D  peHost                      256A   const
     D  peUserAgent                  64A   options(*omit)
     D  peContentType                64A   options(*omit)
     D  peSOAPAction                 64A   options(*omit)
     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : 'This function is no longer '
     c                                     + 'supported!')
     c                   return    -1
     P                 E




      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_addvar():  Add a variable to what's stored
      *          a URL encoder.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_url_encoder_new() routine
      *   peVariable = variable name to add
      *       peData = pointer to data to store in variable
      *   peDataSize = size of data to store in variable
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_addvar...
     P                 B                   export
     D http_url_encoder_addvar...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peData                       *   value
     D    peDataSize                 10I 0 value
     D http_url_encoder_addvar_long...
     D                 PR             1N
     D    peEncoder                    *   value
     D    peVariable                   *   value options(*string)
     D    peData                       *   value options(*string)
     D    peDataSize                 10i 0 value
     C                   return    http_url_encoder_addvar_long(
     C                                           peEncoder
     C                                         : peVariable
     C                                         : peData
     C                                         : peDataSize)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_addvar_s():  Simplified (but limited)
      *       interface to http_url_encoder_addvar().
      *
      *    peEncoder = (input) HTTP_url_encoder object
      *   peVariable = (input) variable name to set
      *      peValue = (input) value to set variable to
      *
      * Returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_addvar_s...
     P                 B                   export
     D http_url_encoder_addvar_s...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peValue                   256A   varying value
     c                   return    http_url_encoder_addvar( peEncoder
     c                                         : peVariable
     c                                         : %addr(peValue)+VARPREF
     c                                         : %len(peValue))
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * OBSOLETE:  There is no good reason to use tables instead
      *            of CCSIDs anymore. HTTPAPI will only use CCSID
      *            support going forward.
      *
      * HTTP_SetTables():  Set the translation tables used for
      *                    ASCII/EBCDIC translation
      *
      *     peASCII  = (input) Table for converting to ASCII
      *     peEBCDIC = (input) Table for converting to EBCDIC
      *
      * Returns 0 if successful, -1 otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_SetTables  B                   export
     D HTTP_SetTables  PI            10I 0
     D   peASCII                     10A   const
     D   peEBCDIC                    10A   const
     D HTTP_MUTABLE    C                   CONST(69)
     c                   callp     SetError(HTTP_MUTABLE: 'HTTPAPI was '
     c                                     + 'compiled to use CCSIDs '
     c                                     + 'rather than Tables')
     c                   return    -1
     P                 E
     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +
      /copy VERSION

     H DFTACTGRP(*NO)

     FCONFIGS   CF   E             WORKSTN sfile(CONFIG2S: WKRRN2)
     F                                     sfile(CONFIG3S: WKRRN3)
     FSRCPF     UF   F  112        DISK    USROPN

      /copy HTTPAPI_H

     D QCMDEXC         PR                  ExtPgm('QCMDEXC')
     D   command                    200A   const
     D   length                      15P 5 const

     D WKRRN2          s              4P 0
     D WKRRN3          s              4P 0
     D wkVersion       s                   like(scVersion)
     D wkPos           s             10I 0
     D Teraspace       s              1a   inz(*OFF)

     ISRCPF     NS
     I                                 13   90  WKLINE

     c     *entry        plist
     c                   parm                    peVersion         6
     c                   parm                    peCancel          1
     c                   parm                    peBldSSL          1
     c                   parm                    peBldSamp         1
     c                   parm                    peBldExpat        1
     c                   parm                    peBldXml          1
     c                   parm                    peSrcLib         10
     c                   parm                    peInstLib        10
     c                   parm                    peUseLibl         1
     c                   parm                    peBldNtlm         1

     c                   eval      peCancel = 'N'
     c                   eval      *inlr = *on

     C****************************************************************
     C* Load the LICENSE member onto the screen
     C****************************************************************
     c                   callp     QCMDEXC('OVRDBF FILE(SRCPF) '
     c                                    +      ' TOFILE(QRPGLESRC) '
     c                                    +      ' MBR(LICENSE)'
     c                                    : 200)

     c                   open      SRCPF
     c                   read(N)   SRCPF

     c                   dow       not %eof(SRCPF)
     c                   eval      wkRRN2 = wkRRN2 + 1
     c                   eval      scLine = wkLine
     c                   write     CONFIG2S
     c                   read(N)   SRCPF
     c                   enddo

     c                   close     SRCPF
     c                   callp     QCMDEXC('DLTOVR FILE(SRCPF)'
     c                                    : 200)

     C****************************************************************
     C* Load the eXpat COPYING member onto the screen
     C****************************************************************
     c                   callp     QCMDEXC('OVRDBF FILE(SRCPF) '
     c                                    +      ' TOFILE(EXPAT) '
     c                                    +      ' MBR(COPYING)'
     c                                    : 200)

     c                   open      SRCPF
     c                   read(N)   SRCPF

     c                   dow       not %eof(SRCPF)
     c                   eval      wkRRN3 = wkRRN3 + 1
     c                   eval      scLine = wkLine
     c                   write     CONFIG3S
     c                   read(N)   SRCPF
     c                   enddo

     c                   close     SRCPF
     c                   callp     QCMDEXC('DLTOVR FILE(SRCPF)'
     c                                    : 200)

     C****************************************************************
     c* Display License
     C****************************************************************
     c                   dou       *INKH = *ON

     c                   write     CONFIG2F
     c                   exfmt     CONFIG2C

     c                   if        *INKC = *ON
     c                   eval      peCancel = 'Y'
     c                   return
     c                   endif

     c                   enddo

     C****************************************************************
     c* Set up defaults for options screen
     C****************************************************************
     c                   eval      wkVersion = 'Version ' + HTTPAPI_VERSION
     c                                   +   ' Released ' + HTTPAPI_RELDATE
     c                   eval      wkPos = %size(scVersion)/2
     c                                   - %len(%trimr(wkVersion))/2
     c                                   + 1
     c                   eval      %subst(scVersion:wkPos) = wkVersion

     c                   eval      scBldSamp = 'Y'
     c                   eval      scBldSSL =  'N'
     c                   eval      scBldExpat = 'N'
     c                   eval      scBldXml = 'N'

      /if defined(HAVE_SSLAPI)
     c                   eval      scBldSSL = 'Y'
      /endif

     c                   if        peVersion < 'V4R5M0'
     c                   eval      scBldSSL = 'N'
     c                   endif

     c                   if        peVersion >= 'V5R1M0'
     c                   eval      scBldExpat = 'Y'
     c                   eval      scBldXml = 'Y'
     c                   endif

     C****************************************************************
     C* display options screen
     C****************************************************************
     c                   dou       (scBldSamp='Y' or scBldSamp='N')
     c                             and (scBldSSL='Y' or scBldSSL='N')

     c                   exfmt     CONFIGS1
     c                   if        *INKC = *ON
     c                   eval      peCancel = 'Y'
     c                   return
     c                   endif

     c                   enddo

     C****************************************************************
     C* display XML options screen
     C****************************************************************
     c                   dou       (scBldXML='Y' or scBldXML='N')
     c                             and (scBldExpat='Y' or scBldExpat='N')

     c                   exfmt     CONFIGS4
     c                   if        *INKC = *ON
     c                   eval      peCancel = 'Y'
     c                   return
     c                   endif

     c                   enddo

     C****************************************************************
     c* Display eXpat License if selected
     C****************************************************************
     c                   if        scBldExpat = 'Y'

     c                   dou       *INKH = *ON

     c                   write     CONFIG3F
     c                   exfmt     CONFIG3C

     c                   if        *INKC = *ON
     c                   eval      peCancel = 'Y'
     c                   return
     c                   endif

     c                   enddo

     c                   endif

     C****************************************************************
     c* Ask for source/installation libraries
     C****************************************************************
     c                   eval      scSrcLib = peSrcLib
     c                   eval      scInstLib = peInstLib
     c                   eval      scUseLibl = 'Y'

     c                   dou       scMsg = *blanks

     c                   exfmt     CONFIGS5
     c                   eval      scMsg = *blanks

     c                   if        *INKC = *ON
     c                   eval      peCancel = 'Y'
     c                   return
     c                   endif

     c                   if        scUseLibl<>'Y' and scUseLibl<>'N'
     C                   eval      scMsg = 'Use *LIBL must be Y or N'
     c                   endif

     c                   if        scSrcLib <> '*LIBL'
     c                   callp(e)  QCMDEXC('CHKOBJ OBJ(' + %trim(scSrcLib)
     c                                    + ') OBJTYPE(*LIB)': 200)
     c                   if        %error
     c                   eval      scMsg = 'Library ' + %trim(scSrcLib)
     c                                   + ' not found.'
     c                   endif
     c                   endif

     c                   if        scInstLib <> '*CURLIB'
     c                   callp(e)  QCMDEXC('CHKOBJ OBJ(' + %trim(scInstLib)
     c                                    + ') OBJTYPE(*LIB)': 200)
     c                   if        %error
     c                   eval      scMsg = 'Library ' + %trim(scInstLib)
     c                                   + ' not found.'
     c                   endif
     c                   endif

     c                   enddo


     C****************************************************************
     C* modify CONFIG_H according to SSL build info & version
     C****************************************************************
     c                   callp     QCMDEXC('OVRDBF FILE(SRCPF) '
     c                                    +      ' TOFILE(QRPGLESRC) '
     c                                    +      ' MBR(CONFIG_H)'
     c                                    : 200)

     c                   open      SRCPF
     c                   read      SRCPF

     c                   dow       not %eof(SRCPF)

     c                   if        %scan('HAVE_SSLAPI': wkLine) > 0
     c                   if        scBldSSL = 'Y'
     c                   eval      wkLine = '     D/define HAVE_SSLAPI'
     c                   else
     c                   eval      wkLine = '     D/undefine HAVE_SSLAPI'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('HAVE_INT64': wkLine) > 0
     c                   if        peVersion >= 'V4R4M0'
     c                   eval      wkLine = '     D/define HAVE_INT64'
     c                   else
     c                   eval      wkLine = '     D/undefine HAVE_INT64'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('HAVE_SRCSTMT_NODEBUGIO':wkLine)>0
     c                   if        peVersion >= 'V4R4M0'
     c                   eval      wkLine = '     D/define HAVE_SRC' +
     c                                      'STMT_NODEBUGIO'
     c                   else
     c                   eval      wkLine = '     D/undefine HAVE_SRC' +
     c                                      'STMT_NODEBUGIO'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('V4R5_GSKIT':wkLine)>0
     c                   if        peVersion <= 'V4R5M0' and scBldSSL='Y'
     c                   eval      wkLine = '     D/define V4R5_GSKIT'
     c                   else
     c                   eval      wkLine = '     D/undefine V4R5_GSKIT'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('V5R3_GSKIT':wkLine)>0
     c                   if        peVersion >= 'V5R3M0' and scBldSSL='Y'
     c                   eval      wkLine = '     D/define V5R3_GSKIT'
     c                   else
     c                   eval      wkLine = '     D/undefine V5R3_GSKIT'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('NTLM_SUPPORT': wkLine)>0
     c                   if        peVersion >= 'V5R3M0'
     c                   eval      wkLine = '     D/define NTLM_SUPPORT'
     c                   eval      peBldNtlm = 'Y'
     c                   else
     c                   eval      wkLine = '     D/undefine NTLM_SUPPORT'
     c                   eval      peBldNtlm = 'N'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        ( %subst(wkLine:7:2)='/d'
     c                             or %subst(wkLine:7:2) = '/D' )
     c                   if        %scan('TERASPACE': wkLine)>0
     c                   eval      Teraspace = *on
     c                   endif
     c                   endif

     c                   if        %scan('USE_TS_MALLOC64':wkLine)>0
     c                   if        peVersion<'V5R2M0' or Teraspace=*off
     c                   eval      wkLine = '     D/undefine '
     c                                    + 'USE_TS_MALLOC64'
     c                   else
     c                   eval      wkLine = '     D/define '
     c                                    + 'USE_TS_MALLOC64'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   if        %scan('HTTP_USE_CCSID':wkLine)>0
     c                   if        peVersion >= 'V5R1M0'
     c                   eval      wkLine = '     D/define HTTP_USE_CCSID'
     c                   else
     c                   eval      wkLine = '     D/undefine HTTP_USE_CCSID'
     c                   endif
     c                   except    updconfig
     c                   endif

     c                   read      SRCPF
     c                   enddo

     c                   close     SRCPF
     c                   callp     QCMDEXC('DLTOVR FILE(SRCPF)'
     c                                    : 200)

     C****************************************************************
     C* modify CONFIG_H according to SSL build info & version
     C****************************************************************
     c                   callp     QCMDEXC('OVRDBF FILE(SRCPF) '
     c                                    +      ' TOFILE(QRPGLESRC) '
     c                                    +      ' MBR(HTTPAPI_H)'
     c                                    : 200)

     c                   open      SRCPF
     c                   read      SRCPF

     c                   dow       not %eof(SRCPF)

     c                   if        %scan('qrpglesrc,config_h':wkLine)>0
     c                   if        scSrcLib <> *blanks
     c                   eval      wkLine = '      /copy '
     c                                    + %trim(scSrcLib) + '/'
     c                                    + 'qrpglesrc,config_h'
     c                   except    updconfig
     c                   endif
     c                   endif

     c                   read      SRCPF
     c                   enddo

     c                   close     SRCPF
     c                   callp     QCMDEXC('DLTOVR FILE(SRCPF)'
     c                                    : 200)

     C****************************************************************
     C* return parameters
     C****************************************************************
     c                   eval      peBldSSL   = scBldSSL
     c                   eval      peBldSamp  = scBldSamp
     c                   eval      peCancel   = 'N'
     c                   eval      peBldExpat = scBldExpat
     c                   eval      peBldXml   = scBldXml
     c                   eval      peSrcLib   = scSrcLib
     c                   eval      peInstLib  = scInstLib
     c                   eval      peUseLibl  = scUseLibl
     c                   return

     OSRCPF     E            updconfig
     O                       wkLine              90
     /*-                                                                            +
      * Copyright (c) 2019-2025 Scott C. Klement                               +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * DECODERR4 -- Decoding routines for HTTPAPI
      *
      */

     H NOMAIN
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT)
      /endif

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy private_h
      /copy ifsio_h
      /copy errno_h

      /if defined(HTTP_USE_CCSID)
     D CCSID_OR_CP     S             10I 0 inz(O_CCSID)
      /else
     D CCSID_OR_CP     S             10I 0 inz(O_CODEPAGE)
      /endif

     D p_Mpr           s               *
     D dsMpr           ds                  based(p_Mpr)
     D   dsMpr_root                  64A   varying
     D   dsMpr_bound                 64A   varying
     D   dsMpr_fd                    10I 0
     D   dsMpr_Data                    *
     D   dsMpr_StrPrc                  *   procptr
     D   dsMpr_PrtPrc                  *   procptr
     D   dsMpr_EndPrc                  *   procptr

     D upper           C                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           C                   'abcdefghijklmnopqrstuvwxyz'

     D part_header_parse...
     D                 PR
     D   resp                     65535A   varying const

     D part_header_clean...
     D                 PR

     D part_header_find...
     D                 PR            10I 0
     D   name                       256A   varying const
     D   pos                         10I 0 value

     D toUppercase     PR         65535A   varying
     D   peString                 65535A   varying const

     D phdrs           s             10I 0 inz(0)

     D phdr            ds                  occurs(4000)
     D  phdr_name                   256A   varying
     D  phdr_idx                     10I 0
     D  phdr_len                     10I 0
     D  phdr_fill                     8A
     D  phdr_ptr                       *

     D pheader         s          32500A   based(p_pheader)

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_decoder_open(): Create a multipart/related decoder
      *
      * The procedure initalize the parser of a multipart/related
      * response message.
      *
      *   peStmFile   = (input) pathname to stream file from which
      *                 to read the parts to be decoded.
      *
      *   peContType  = (input) the entire content type as from
      *                 received by httpapi.
      *
      *   peUserData  = (input) the pointer to the memory address
      *                 where custom data are stored.
      *
      *   peStartProc = (input) the procedure to launch when a
      *                 new part is starting to be processed.
      *                 The procedure has this interface:
      * D StartPrc        PR
      * D   userdata                      *   value
      * D   isRoot                        N   const
      *                 userdata = the same pointer passed with peUserdata.
      *                 isRoot   = *ON if the part is the starting point
      *                            of the multipart/related message.
      *
      *   pePartProc  = (input) the procedure to launch when a
      *                 new batch of part info is processed.
      *                 The procedure has this interface:
      * D PartPrc         PR
      * D   userdata                      *   value
      * D   data                          *   value
      * D   datalen                     10I 0 const
      *                 userdata = the same pointer passed with peUserdata.
      *                 data     = pointer to the next chunck of data to write.
      *                 dataLen  = lenght of the chunck.
      *
      *   peEndProc   = (input) the procedure to launch at the
      *                 end of a part processing.
      *                 The procedure has this interface:
      *
      * D EndPrc          PR
      * D   userdata                      *   value
      *                 userdata = the same pointer passed with peUserdata.
      *
      *   Note: all the passed procedures can use part_header() to
      *         retrieve a header specific for that part
      *         (example: part_header("Content-ID")).
      *
      *   returns an (opaque) pointer to the new decoder
      *           or *NULL upon error.
      *
      * WARNING: To free the memory used by this routine and close
      *          the stream file, you MUST call http_mpr_decoder_close()
      *          after the data is parsed.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_decoder_open...
     P                 B                   export
     D http_mpr_decoder_open...
     D                 PI              *
     D  peStmFile                      *   value options(*string)
     D  peContType                  256A   const varying
     D  peUserData                     *   value
     D  peStartProc                    *   procptr value
     D  pePartProc                     *   procptr value
     D  peEndProc                      *   procptr value

     D wwFilename      s          32767a   varying
     D wwFD            s             10I 0
     D wwBoundary      s             64A   varying
     D wwStartId       s             64A   varying
     D wwRetVal        s               *
     D pos1            s             10I 0
     D pos2            s             10I 0
     D isRoot          s               n

      *************************************************
      *  Open the file that contain the results
      *************************************************
     c                   eval      wwFilename = %trimr(%str(peStmFile))
     c                   eval      wwFD = open( wwFilename : O_RDONLY )

     c                   if        wwFD < 0
     c                   callp     SetError( HTTP_IFOPEN
     c                                     : 'open(): '
     c                                     + %str(strerror(errno)))
     c                   return    *NULL
     c                   endif

      *************************************************
      * Save space for crap
      *************************************************
     c                   eval      wwRetVal = xalloc(%size(dsMpr))

      *************************************************
      * Parse the content to get the boundary and
      * eventually the id of the starting part
      *************************************************
     c                   eval      pos1 = %scan('BOUNDARY="'
     c                                         : toUppercase(peContType))
     c                   eval      pos1 = pos1 + %len('BOUNDARY="')
     c                   eval      pos2 = %scan('"':peContType:pos1)
     c                   eval      wwBoundary = %subst( peContType
     c                                                : pos1
     c                                                : pos2-pos1)

     c                   eval      pos1 = %scan('START="'
     c                                         : toUppercase(peContType))
     c                   if        pos1 > 0
     c                   eval      pos1 = pos1 + %len('START="')
     c                   eval      pos2 = %scan('"':peContType:pos1)
     c                   eval      wwStartId = %subst( peContType
     c                                                : pos1
     c                                                : pos2-pos1)
     c                   endif

      *************************************************
      * Set up MPR structure
      *************************************************
     c                   eval      p_Mpr = wwRetVal
     c                   eval      dsMpr_root = wwStartId
     c                   eval      dsMpr_bound = wwBoundary
     c                   eval      dsMpr_fd = wwFD
     c                   eval      dsMpr_Data = peUserData
     c                   eval      dsMpr_StrPrc = peStartProc
     c                   eval      dsMpr_PrtPrc = pePartProc
     c                   eval      dsMpr_EndPrc = peEndProc

     c                   return    wwRetVal
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_decoder_parse(): Start the parsing process calling
      *          the given procedures at each step.
      *
      *    peDecoder = pointer to decoder created by the
      *                  http_mpr_decoder_open() routine
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_decoder_parse...
     P                 B                   export
     D http_mpr_decoder_parse...
     D                 PI             1N
     D    peDecoder                    *   value

     D CRLFA           c                   x'0d0a'
     D CR              c                   x'0d'
     D p_buffer        s               *
     D buffer          s           1025A   based(p_buffer)

     D line            s                   like(buffer)
     D lineLen         s             10I 0
     D tbw             s                   like(buffer)
     D tbwLen          s             10I 0

     D rd              s             10I 0
     D bytesr          s             10I 0
     D left            s             10I 0

     D wwBound         s             68A   varying
     D wwBoundEnd      s             70A   varying

     D isRoot          s               N
     D subHdrs         s             10I 0 inz(0)
     D subHdr          ds                  occurs(4000)
     D  subHdr_name                 256A   varying
     D  subHdr_idx                   10I 0
     D  subHdr_len                   10I 0
     D  subHdr_fill                   8A
     D  subHdr_ptr                     *

     D Status          s             10I 0
     D STS_START       c                   0
     D STS_PARTHEADER  c                   10
     D STS_PARTLOAD    c                   20
     D STS_END         c                   30

     D wwHeader        s          65535A   varying

     D p_startPrc      s               *   procptr
     D StartPrc        PR                  extproc(p_startPrc)
     D   userdata                      *   value
     D   isRoot                        N   const

     D p_partPrc       s               *   procptr
     D PartPrc         PR                  extproc(p_partPrc)
     D   userdata                      *   value
     D   data                          *   value
     D   datalen                     10I 0 const

     D p_endPrc        s               *   procptr
     D EndPrc          PR                  extproc(p_endPrc)
     D   userdata                      *   value

      /free
        wwBound = '--' + dsMpr_bound;
        http_xlatep(%len(wwBound) : %addr(wwBound) + 2 : TO_ASCII);
        wwBoundEnd = '--' + dsMpr_bound + '--';
        http_xlatep(%len(wwBoundEnd) : %addr(wwBoundEnd) + 2 : TO_ASCII);
        p_startPrc = dsMpr_StrPrc;
        p_partPrc = dsMpr_PrtPrc;
        p_endPrc = dsMpr_EndPrc;

        Status = STS_START;
        p_buffer = xalloc(%size(buffer));

        exsr ReadLine;

        dow bytesr <> 0;

          select;
          when Status = STS_START;
            if line = CRLFA;
              exsr ReadLine;
              iter;
            endif;
            if %subst(line : 1 : %len(wwBound)) = wwBound;
              isRoot = *off;
              if (dsMpr_root = *blanks);
                isRoot = *on;
              endif;
              Status = STS_PARTHEADER;
              clear wwHeader;
            endif;


          when Status = STS_PARTHEADER;
            isRoot = *off;

            if line <> CRLFA;
              http_xlatep(lineLen : %addr(line) : TO_EBCDIC);
              wwHeader = %trim(wwHeader) + %subst(line : 1 : lineLen);
            else;
              part_header_parse(wwHeader);
              wwHeader = %trim(http_mpr_part_header('content-id'));
              if ((wwHeader = dsMpr_root) and (dsMpr_root <> *blanks));
                isRoot = *on;
              endif;
              if (p_startPrc <> *null);
                StartPrc(dsMpr_data : isRoot);
              endif;
              Status = STS_PARTLOAD;
            endif;


          when Status = STS_PARTLOAD;
            tbw = line;
            tbwLen = lineLen;
            exsr ReadLine;
            if %subst(line : 1 : %len(wwBoundEnd)) = wwBoundEnd;
              if (p_partPrc <> *null);
                PartPrc(dsMpr_data : %addr(tbw) : tbwLen-2);
              endif;
              if (p_endPrc <> *null);
                EndPrc(dsMpr_data);
              endif;
              eval Status = STS_END;
              iter;
            endif;
            if %subst(line : 1 : %len(wwBound)) = wwBound;
              if (p_partPrc <> *null);
                PartPrc(dsMpr_data : %addr(tbw) : tbwLen-2);
              endif;
              if (p_endPrc <> *null);
                EndPrc(dsMpr_data);
              endif;
              eval Status = STS_PARTHEADER;
              iter;
            endif;
            if (p_partPrc <> *null);
              PartPrc(dsMpr_data : %addr(tbw) : tbwLen);
              iter;
            endif;

          endsl;

          exsr ReadLine;
        enddo;

        return *ON;

        //*************************************************
        //* Read a new line
        //*************************************************
        begsr ReadLine;
          clear line;
          lineLen = 0;

          //* Read the file a little more
          rd = read(dsMpr_fd :
                   p_buffer + left :
                   %size(buffer) - left - 1);
          bytesr = rd + left;

          //* If nothing more left, leave
          if bytesr = 0;
            leavesr;
          endif;

          //* If the last byte is a CR, read one more byte
          if %subst(buffer : bytesr : 1) = CR ;
            rd = read(dsMpr_fd : p_buffer + bytesr : 1);
            bytesr = bytesr + rd;
          endif;

          //* Search for the first CRLF, if not present, take it all
          lineLen = %scan(CRLFA : %subst(buffer : 1 : bytesr));
          if lineLen <= 0;
            lineLen = bytesr;
          else;
            lineLen = lineLen + 1;
          endif;
          line = %subst(buffer : 1 : lineLen);

          //* Remember what's left to read and update the buffer
          left = bytesr - lineLen;
          if left > 0;
            memcpy(p_buffer: p_buffer + lineLen: left);
          endif;
        endsr;

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_decoder_close():  close an open multipart/related
      *                            decoder.
      *
      *     peDecoder = (input) decoder to close
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_decoder_close...
     P                 B                   export
     D http_mpr_decoder_close...
     D                 PI
     D  peDecoder                      *   value

     c                   callp     close(dsMpr_fd)
     c                   callp     xdealloc(peDecoder)

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Parse part header
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P part_header_parse...
     P                 B
     D part_header_parse...
     D                 PI
     D   resp                     65535A   varying const

     D name            s            256A   varying
     D val             s          32500A   varying
     D CRLF            c                   x'0d25'
     D next            s             10I 0 inz(1)
     D eoh             s             10I 0
     D eok             s             10I 0
     D len             s             10I 0

     c                   callp     part_header_clean

      ***********************************************
      * Break response chain into individual headers
      ***********************************************
     c                   dow       next < %len(resp)

      * Find end of header
     c                   eval      eoh = %scan(CRLF:resp:next)
     c                   if        eoh  = 0
     c                   leave
     c                   endif

      * Find end of keyword, start of value
     c                   eval      eok = %scan(':':resp:next)
     c                   if        eok=0 or eok=next or eok>eoh
     c                   eval      next = eoh + 2
     c                   iter
     c                   endif

      * get name of header & value
     c                   eval      len = eok - next
     c                   eval      name = %subst(resp:next:len)
     c                   eval      name = ToUppercase(name)
     c                   eval      len = (eoh - eok) - 1

     c                   if        len = 0
     c                   eval      %len(val) = 0
     c                   else
     c                   eval      val = %subst(resp:eok+1:len)
     c                   endif

      * process them
     c                   if        phdrs < %elem(phdr)

     c                   if        len = 0
     c                   eval      p_pHeader = *null
     c                   else
     c                   eval      p_pHeader = xalloc(len)
     c                   eval      %subst(pheader:1:len) = val
     c                   endif

     c                   eval      phdrs = phdrs + 1
     C     phdrs         occur     phdr
     c                   eval      phdr_name = name
     c                   eval      phdr_idx = phdrs
     c                   eval      phdr_len = len
     c                   eval      phdr_ptr = p_pheader

     c                   endif

      * look for next header
     c                   eval      next = eoh + 2
     c                   enddo

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * part_header_clean(): free up all part header data
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P part_header_clean...
     P                 B
     D part_header_clean...
     D                 PI
     D i               s             10I 0
     c     1             do        phdrs         i
     c     i             occur     phdr
     c                   eval      phdr_idx = 0
     c                   eval      phdr_len = 0
     c                   if        phdr_ptr <> *null
     c                   callp     xdealloc(phdr_ptr)
     c                   endif
     c                   enddo
     c                   eval      phdrs = 0
     c                   eval      p_pheader = *NULL
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * part_header_find():  returns the position of a given part header
      *                      in the part header list
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P part_header_find...
     P                 B
     D part_header_find...
     D                 PI            10I 0
     D   name                       256A   varying const
     D   pos                         10I 0 value

     D x               s             10I 0
     D count           s             10I 0
     D found           s             10I 0

     c                   eval      count = 0
     c                   eval      found = 0

     c     1             do        phdrs         x
     c     x             occur     phdr

     c                   if        phdr_name = name
     c                   eval      count = count + 1
     c                   if        count = pos
     c                   eval      found = x
     c                   leave
     c                   endif
     c                   endif

     c                   enddo

     c                   return    found
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_part_header():  retrieve the value of a part header
      *
      *      name = (input) name of header to look for
      *       pos = (input/optional) position of header if there's
      *                 more than one with the same name
      *
      * returns the value of the part header, or '' if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_part_header...
     P                 B                   export
     D                 PI         32500A   varying
     D   name                       256A   varying const
     D   pos                         10I 0 value options(*nopass)

     D lname           s            256a   varying
     D p               s             10I 0 inz(1)
     D found           s             10I 0

     c                   if        %parms >= 2
     c                   eval      p = pos
     c                   endif

     c                   eval      lname = name
     c                   eval      lname = ToUppercase(lname)

     c                   eval      found = part_header_find(lname: p)
     c                   if        found < 1
     c                   return    ''
     c                   endif

     c     found         occur     phdr
     c                   if        phdr_len = 0
     c                   return    ''
     c                   else
     c                   eval      p_pheader = phdr_ptr
     c                   return    %subst(pheader:1:phdr_len)
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * toUppercase: convert a string to uppercase
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P toUppercase     B
     D toUppercase     PI         65535A   varying
     D   peString                 65535A   varying const
     c                   return    %xlate(lower:upper:peString)
     P                 E


      /define ERRNO_LOAD_PROCEDURE
      /copy errno_h

     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * ENCODERR4 -- Encoding routines for HTTPAPI
      *
      */

     H NOMAIN
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT)
      /endif

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy private_h
      /copy ifsio_h
      /copy errno_h

      /if defined(HTTP_USE_CCSID)
     D CCSID_OR_CP     S             10I 0 inz(O_CCSID)
      /else
     D CCSID_OR_CP     S             10I 0 inz(O_CODEPAGE)
      /endif

     D memset          PR              *   ExtProc('memset')
     D   ptr                           *   value
     D   value                       10I 0 value
     D   length                      10U 0 value

     D p_Encoder       s               *
     D dsEncoder       DS                  based(p_Encoder)
     D   dsEnc_Len                   10I 0
     D   dsEnc_Size                  10I 0
     D   dsEnc_Data                    *
     D   dsEnc_Space                  1A
     D   dsEnc_Spec                  25A
     D   dsEnc_HexAll               512A
     D   dsEnc_Hex                    2A   dim(256) overlay(dsEnc_HexAll)

     D p_Mfd           s               *
     D dsMfd           ds                  based(p_Mfd)
     D   dsMfd_bound                 32A
     D   dsMfd_fd                    10I 0

     D p_Mpr           s               *
     D dsMpr           ds                  based(p_Mpr)
     D   dsMpr_bound                 32A
     D   dsMpr_fd                    10I 0

     D http_url_encoder_addvar_long...
     D                 PR             1N
     D    peEncoder                    *   value
     D    peVariable                   *   value options(*string)
     D    peData                       *   value options(*string)
     D    peDataSize                 10i 0 value
     D http_url_encoder_addvar_long_s...
     D                 PR             1N
     D    peEncoder                    *   value
     D    peVariable                   *   value options(*string)
     D    peValue                      *   value options(*string)

     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P* Initializes the base64 alphabet used by base64_encode
     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P base64_init     B                   export
     D base64_init     PI
     D   peBase64                      *   value
     D p_Base64        S               *
     D wwBase64        S             64A   based(p_Base64)
     c                   eval      p_Base64 = peBase64
     c                   eval      wwBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
     c                                        'abcdefghijklmnopqrstuvwxyz' +
     c                                        '0123456789+/'
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  base64_encode:  Encodes a data stream into BASE64 encoding
      *
      *       peInput = pointer to data to convert
      *    peInputLen = length of data to convert
      *      peOutput = pointer to memory to receive output
      *     peOutSize = size of area to store output in
      *
      *  Returns length of encoded data, or space needed to encode
      *      data.   If this value is greater than peOutSize, then
      *      output may have been truncated.
      *  Returns -1 upon error
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P base64_encode   B                   export
     D base64_encode   PI            10I 0
     D   peInput                       *   value
     D   peInputLen                  10I 0 value
     D   peOutput                      *   value
     D   peOutSize                   10I 0 value

     D base64          S              1A   dim(64) static
     D wwInit          S              1N   inz(*OFF) static

     D dsCvt           DS
     D   wwNumb                1      2U 0 inz(0)
     D   wwByte                2      2A

     D p_Data          S               *
     D dsData          DS                  based(p_Data)
     D   ds8B1                        1A
     D   ds8B2                        1A
     D   ds8B3                        1A

     D p_OutData       S               *
     D wwOutData       S              4A   based(p_OutData)
     D wwOut           S              4A
     D wwPos           S             10I 0
     D wwOutLen        S             10I 0

     c                   if        not wwInit
     c                   callp     base64_init(%addr(base64))
     c                   eval      wwInit = *On
     c                   endif

     c                   eval      p_Data = peInput
     c                   eval      p_OutData = peOutput

     c                   eval      wwPos = 1
     c                   dow       wwPos <= peInputLen

     C* First Output Byte = Leftmost 6 bits of the first input byte
     c                   move      ds8B1         wwByte
     c                   bitoff    x'03'         wwByte
     c                   div       4             wwNumb
     c                   eval      %subst(wwOut:1) = base64(wwNumb+1)

     C*
     C* Second Output Byte = rightmost 2 bits of the first input byte
     C*                   and leftmost 4 bits of 2nd input byte
     c                   move      ds8B1         wwByte
     c                   bitoff    x'FC'         wwByte
     c                   mult      16            wwNumb

     c                   if        wwPos+1 <= peInputLen
     c                   move      wwByte        wwSave            1
     c                   move      ds8B2         wwByte
     c                   bitoff    x'0F'         wwByte
     c                   div       16            wwNumb
     c                   biton     wwSave        wwByte
     c                   endif

     c                   eval      %subst(wwOut:2) = base64(wwNumb+1)


     C*
     C* Third Output Byte = rightmost 4 bits of the 2nd input byte
     C*                   and leftmost 2 bits of 3nd input byte
     C*  or '=' if there was only one input byte
     C*
     c                   if        wwPos+1 > peInputLen

     c                   eval      %subst(wwOut:3) = '='

     c                   else

     c                   move      ds8B2         wwByte
     c                   bitoff    x'F0'         wwByte
     c                   mult      4             wwNumb

     c                   if        wwPos+2 <= peInputLen
     c                   move      wwByte        wwSave
     c                   move      ds8B3         wwByte
     c                   bitoff    x'3F'         wwByte
     c                   div       64            wwNumb
     c                   biton     wwSave        wwByte
     c                   endif

     c                   eval      %subst(wwOut:3) = base64(wwNumb+1)

     c                   endif

     C*
     C* Fourth Output Byte = rightmost 6 bits of the 3nd input byte
     C*  or '=' if there were less than 3 input bytes
     C*
     c                   if        wwPos+2 > peInputLen
     c                   eval      %subst(wwOut:4:1) = '='
     c                   else
     c                   move      ds8B3         wwByte
     c                   bitoff    x'C0'         wwByte
     c                   eval      %subst(wwOut:4) = base64(wwNumb+1)
     c                   endif

     c                   eval      wwOutLen = wwOutLen + 4
     c                   if        wwOutLen <= peOutSize
     c                   eval      wwOutData = wwOut
     c                   eval      p_Outdata = p_Outdata + 4
     c                   endif

     c                   eval      p_Data = p_Data + 3
     c                   eval      wwPos = wwPos + 3

     c                   enddo

     c                   return    wwOutLen
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_new():  Create a URL encoder.
      *
      *   returns an (opaque) pointer to the new encoder
      *           or *NULL upon error.
      *
      * WARNING: To free the memory used by this routine, you MUST
      *          call http_url_encoder_free() after the data is sent.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_new...
     P                 B                   export
     D http_url_encoder_new...
     D                 PI              *

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                      512A
     D  input                       256A
     D  output_len                   10I 0 value

     D                 ds
     D dsCh1                   1      1A
     D dsCh                    2      2A
     D dsBin                   1      2U 0 inz(0)

     D wwRetVal        s               *

     D wwSpace         s              1A   inz(' ')
      ****                                      12345678901 2345678901234
     D wwBuf           s            256A
     D x               s             10I 0

     c                   eval      wwRetVal = xalloc(%size(dsEncoder))

     c                   eval      p_Encoder = wwRetVal
     c                   eval      dsEnc_Len = 0
     c                   eval      dsEnc_Size = 0
     c                   eval      dsEnc_Data = *NULL
     c                   eval      dsEnc_Space = wwSpace
     c                   eval      dsEnc_Spec  = get_symbols

     c     1             do        256           x
     c                   eval      dsBin = x - 1
     c                   eval      %subst(wwBuf:x:1) = dsCh
     c                   enddo

     c                   callp     cvthc( dsEnc_HexAll
     c                                  : wwBuf
     c                                  : %size(dsEnc_HexAll))

     c                   callp     http_xlate( %size(dsEnc_Space)
     c                                       : dsEnc_Space
     c                                       : TO_ASCII )

     c                   callp     http_xlate( %size(dsEnc_Spec)
     c                                       : dsEnc_Spec
     c                                       : TO_ASCII  )

     c                   callp     http_xlate( %size(dsEnc_HexAll)
     c                                       : dsEnc_HexAll
     c                                       : TO_ASCII )

     c                   return    wwRetVal
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_free(): free resources allocated by both
      *        http_url_encoder_new() and http_url_encoder_addvar()
      *
      *     peEncoder = pointer to encoder to free
      *
      * Returns *ON if successful, *OFF otherwise.
      *
      * WARNING: After calling this, do not use the encoder or
      *          data returned by http_url_encoder_getptr() again.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_free...
     P                 B                   export
     D http_url_encoder_free...
     D                 PI             1N
     D    peEncoder                    *   value

     c                   eval      p_Encoder = peEncoder

     c                   callp(e)  xdealloc(dsEnc_Data)
     c                   if        %error
     c                   return    *OFF
     c                   endif

     c                   callp(e)  xdealloc(p_Encoder)
     c                   if        %error
     c                   return    *OFF
     c                   endif

     c                   eval      p_Encoder = *NULL
     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  url_encode_pre():  (Internal) Prepare data for URL encoding.
      *
      *     peEncoder = encoder to use
      *       peInput = data to encode.  This will be converted to
      *                   ASCII...
      *      peInpLen = length of input data
      *
      *  Returns the length that is required for the output data
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P url_encode_pre  B                   export
     D url_encode_pre  PI            10I 0
     D    peEncoder                    *   value
     D    peInput                      *   value
     D    peInpLen                   10I 0 value

     D p_Deref         s               *
     D wwDeref         s              1A   based(p_Deref)

     D wwPos           s             10I 0
     D wwLen           s             10I 0
     D wwCheck         s             10I 0

     c                   eval      p_Encoder = peEncoder
     c                   eval      p_Deref = peInput

      ********************************************
      * Count the size of data needed
      ********************************************
     c     1             do        peInpLen      wwPos


     c     dsEnc_Spec    check     wwDeref       wwCheck
     c                   if        wwCheck = 0
     c                               or wwDeref<x'20'
     c                               or wwDeref>x'7F'
     c                   eval      wwLen = wwLen + 3
     c                   else
     c                   eval      wwLen = wwLen + 1
     c                   endif

     c                   eval      p_Deref = p_Deref + 1
     c                   enddo

     c                   return    wwLen
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  url_encode():  (Internal) URL encode data into output buffer
      *
      *     peEncoder = encoder to use
      *       peInput = data to encode.  Should be ASCII.  Will be
      *                    converted to EBCDIC.
      *      peInpLen = length of input data
      *         peLoc = location to store output data into
      *     peLocSize = size of output data (returned by _pre)
      *
      * Resulting output data will be EBCDIC data suitable for passing
      *    into http_url_post()
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P url_encode      B                   export
     D url_encode      PI
     D    peEncoder                    *   value
     D    peInput                      *   value
     D    peInpLen                   10I 0 value
     D    peLoc                        *   value
     D    peLocSize                  10I 0 value

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                        2A
     D  input                         1A
     D  output_len                   10I 0 value

     D p_Deref         s               *
     D wwDeref         s              1A   based(p_Deref)

     D p_ResChar       s               *
     D wwResChar       s              2A   based(p_ResChar)

     D                 ds
     D   wwVal                 1      2U 0 inz(0)
     D   wwChar                2      2A

     D wwPos           s             10I 0
     D wwCheck         s             10I 0

     c                   eval      p_Encoder = peEncoder

      ********************************************
      **  Create urlencoded result
      ********************************************
     c                   eval      p_deref = peInput
     c                   eval      p_reschar = peLoc

     c     1             do        peInpLen      wwPos

     c                   if        wwPos <> 1
     c                   eval      p_deref = p_deref + 1
     c                   endif

     c     dsEnc_Spec    check     wwDeref       wwCheck

     c                   select
     c                   when      wwDeref = dsEnc_Space
     c                   eval      %subst(wwResChar:1:1) =
     c                                  %subst(dsEnc_Spec:6:1)
     c                   eval      p_reschar = p_reschar + 1

     c                   when      wwCheck = 0
     c                               or wwDeref<x'20'
     c                               or wwDeref>x'7F'

     c                   eval      %subst(wwResChar:1:1) =
     c                                %subst(dsEnc_Spec:7:1)
     c                   eval      p_ResChar = p_ResChar + 1

     c                   eval      wwChar = wwDeref
     c                   eval      wwResChar = dsEnc_Hex(wwVal+1)
     c                   eval      p_ResChar = p_ResChar + 2

     c                   other
     c                   eval      %subst(wwResChar:1:1) = wwDeref
     c                   eval      p_reschar = p_reschar + 1
     c                   endsl

     c                   enddo

      ********************************************
      *  convert result back to EBCDIC so that
      *  user can inspect it and SendProc() won't
      *  be confused.
      ********************************************
     c                   callp     http_xlatep( peLocSize
     c                                        : peLoc
     c                                        : TO_EBCDIC )

     c                   return
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_addvar_long(): Add a variable to what's stored
      *          a URL encoder.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_url_encoder_new() routine
      *   peVariable = variable name to add
      *       peData = pointer to data to store in variable
      *   peDataSize = size of data to store in variable
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_addvar_long...
     P                 B                   export
     D http_url_encoder_addvar_long...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                   *   value options(*string)
     D    peData                       *   value options(*string)
     D    peDataSize                 10i 0 value

     D ENCBLOCK        C                   8192

     D p_Deref         s               *
     D wwDeref         s              1A   based(p_Deref)

     D wwLenVar        s             10I 0
     D wwLenData       s             10I 0
     D wwNewLen        s             10I 0
     D wwNewSize       s             10I 0

     D wwVarXLen       s             10i 0
     D wwDataXLen      s             10i 0
     D p_VarX          s               *
     D p_DataX         s               *

     c                   eval      p_Encoder = peEncoder

      ****************************************************************
      * Translate to destination CCSID (ASCII, Unicode whatever)
      ****************************************************************
     c                   if        %len(%str(peVariable)) = 0
     c                   return    *off
     c                   endif

     c                   eval      wwVarXLen =
     c                             http_xlatedyn( %len(%str(peVariable))
     c                                          : peVariable
     c                                          : TO_ASCII
     c                                          : p_VarX )

     c                   if        peDataSize = 0
     c                   eval      wwDataXLen = 0
     c                   eval      p_DataX    = *null
     c                   else
     c                   eval      wwDataXLen =
     c                             http_xlatedyn( peDataSize
     c                                          : peData
     c                                          : TO_ASCII
     c                                          : p_DataX )
     c                   endif


      ****************************************************************
      * Figure out how much space we'll need to encode the data:
      ****************************************************************
     c                   eval      wwLenVar =
     c                             url_encode_pre( peEncoder
     c                                           : p_VarX
     c                                           : wwVarXLen )

     c                   eval      wwLenData =
     c                             url_encode_pre( peEncoder
     c                                           : p_DataX
     c                                           : wwDataXLen )

     c                   eval      wwNewLen = dsEnc_Len +
     c                               wwLenVar + %len('=') + wwLenData

     c                   if        dsEnc_Len > 0
     c                   eval      wwNewLen = wwNewLen + %len('&')
     c                   endif

      ****************************************************************
      *  Allocate enough space to store newly encoded variable and
      *  it's data into the encoder.
      ****************************************************************
     c                   eval      wwNewSize = dsEnc_Size

     c                   if        wwNewSize < wwNewLen

     c                   dow       wwNewSize < wwNewLen
     c                   eval      wwNewSize = wwNewSize + ENCBLOCK
     c                   enddo

     c                   eval      dsEnc_Data = xrealloc( dsEnc_data
     c                                                  : wwNewSize )

     c                   if        dsEnc_Data = *null
     c                   callp     xdealloc(p_VarX)
     c                   callp     xdealloc(p_DataX)
     c                   return    *OFF
     c                   endif

     c                   callp     memset( dsEnc_Data + dsEnc_Size
     c                                   : 0
     c                                   : wwNewSize - dsEnc_Size )

     c                   eval      dsEnc_Size = wwNewSize
     c                   endif

      ****************************************************************
      *  Encode the variable and data
      ****************************************************************
     c                   if        dsEnc_Len > 0
     c                   eval      p_deref = dsEnc_Data + dsEnc_Len
     c                   eval      wwDeref = '&'
     c                   eval      dsEnc_Len = dsEnc_Len + %len('&')
     c                   endif

     c                   callp     url_encode( peEncoder
     c                                       : p_VarX
     c                                       : wwVarXLen
     c                                       : dsEnc_Data + dsEnc_Len
     c                                       : wwLenVar )
     c                   eval      dsEnc_Len = dsEnc_Len + wwLenVar
     c                   callp     xdealloc(p_VarX)

     c                   eval      p_deref = dsEnc_Data + dsEnc_Len
     c                   eval      wwDeref = '='
     c                   eval      dsEnc_Len = dsEnc_Len + %len('=')

     c                   if        wwDataXLen > 0
     c                   callp     url_encode( peEncoder
     c                                       : p_DataX
     c                                       : wwDataXLen
     c                                       : dsEnc_Data + dsEnc_Len
     c                                       : wwLenData )
     c                   eval      dsEnc_Len = dsEnc_Len + wwLenData
     c                   callp     xdealloc(p_DataX)
     c                   endif

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_urlEncode(): Encodes one component of a URL without
      *                   having to build a whole "form"
      *
      *   input = (input) string to encode
      *
      * Returns the encoded string, or '' upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_urlEncode  B                   export
     D                 PI         65535a   varying
     D    input                        *   value options(*string)

     D inputLen        s             10i 0
     D XLen            s             10i 0
     D p_inputX        s               *
     D myEnc           s               *
     D EncLen          s             10i 0
     D Output          s          65535a   varying

      /free

       if input = *null;
          return '';
       endif;

       inputLen = %len(%str(input));
       if inputLen < 1;
          return '';
       endif;

       XLen = http_xlatedyn( inputLen
                           : input
                           : TO_NETWORK
                           : p_inputX );

       if XLen=0 or p_InputX=*null;
          return '';
       endif;

       myEnc = http_url_encoder_new();
       if myEnc = *null;
          xdealloc(p_inputX);
          return '';
       endif;

       EncLen = url_encode_pre( myEnc
                              : p_inputX
                              : XLen );

       if EncLen < 1;
          xdealloc(p_InputX);
          http_url_encoder_free(myEnc);
          return '';
       endif;

       %len(Output) = EncLen;

       url_encode( myEnc
                 : p_inputX
                 : XLen
                 : %addr(Output) + VARPREF
                 : EncLen );

       http_url_encoder_free(myEnc);
       xdealloc(p_inputX);

       return Output;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_getptr(): Get a pointer to the encoded
      *        data stored in a URL encoder
      *
      *     peEncoder = (input) pointer to encoder
      *        peData = (output) pointer to encoded data
      *        peSize = (output) size of encoded data
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_getptr...
     P                 B                   export
     D http_url_encoder_getptr...
     D                 PI
     D    peEncoder                    *   value
     D    peData                       *
     D    peSize                     10I 0
     c                   eval      p_Encoder = peEncoder
     c                   eval      peData = dsEnc_data
     c                   eval      peSize = dsEnc_len
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_getstr(): Get encoded data he encoded
      *        data stored in a URL encoder as a string
      *
      *     peEncoder = (input) pointer to encoder
      *
      * NOTE: This routine is much slower than http_url_encoder_getptr()
      *       and is limited to a 32k return value.  It's suitable for
      *       use with data that's added to a URL, such as when
      *       performing a GET request to a web server, but you should
      *       use http_url_encoder_getptr() for POST requests.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_getstr...
     P                 B                   export
     D http_url_encoder_getstr...
     D                 PI         32767A   varying
     D    peEncoder                    *   value

     D len             s             10i 0
     D wwRet           s          32767A   varying

     c                   eval      p_Encoder = peEncoder
     c                   eval      len = %size(wwRet) - VARPREF

     c                   if        dsEnc_Len < len
     c                   eval      len = dsEnc_len
     c                   endif

     c                   eval      %len(wwRet) = len

     c                   callp     memcpy( %addr(wwRet)+VARPREF
     c                                   : dsEnc_Data
     c                                   : len )

     c                   return    wwRet
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_url_encoder_addvar_long_s():  Simplified interface to
      *      http_url_encoder_addvar().
      *
      *    peEncoder = (input) HTTP_url_encoder object
      *   peVariable = (input) variable name to set
      *      peValue = (input) value to set variable to
      *
      * Returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_encoder_addvar_long_s...
     P                 B                   export
     D http_url_encoder_addvar_long_s...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                   *   value options(*string)
     D    peValue                      *   value options(*string)
     c                   return    http_url_encoder_addvar_long(
     c                                           peEncoder
     c                                         : peVariable
     c                                         : peValue
     c                                         : %len(%str(peValue))
     c                                         )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mfd_encoder_open(): Create a multipart/form-data encoder
      *
      * A multipart/form-data encoder will encode the variables
      * and or stream files that you pass to it and store the results
      * in a stream file.  You can later POST those results with the
      * http_url_post_stmf() API.
      *
      *   peStmFile = (input) pathname to stream file to store
      *               encoded results.
      *
      *   returns an (opaque) pointer to the new encoder
      *           or *NULL upon error.
      *
      * WARNING: To free the memory used by this routine and close
      *          the stream file, you MUST call http_mfd_encoder_close()
      *          after the data is sent.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mfd_encoder_open...
     P                 B                   export
     D http_mfd_encoder_open...
     D                 PI              *
     D  peStmFile                      *   value options(*string)
     D  peContType                   64A

     D wwFilename      s          32767a   varying
     D wwFD            s             10I 0
     D wwTS            s               Z
     D wwTsStr         s             26A
     D wwBoundary      s             32A
     D wwRetVal        s               *

      *************************************************
      *  Open a file to contain the results
      *************************************************
     c                   eval      wwFilename = %trimr(%str(peStmFile))
     c                   eval      wwFD = open( wwFilename
     c                                        : O_WRONLY  +
     c                                          O_CREAT   +
     c                                          O_TRUNC   +
     c                                          CCSID_OR_CP
     c                                        : HTTP_IFSMODE
     c                                        : FILE_CCSID )

     c                   if        wwFD < 0
     c                   callp     SetError( HTTP_IFOPEN
     c                                     : 'open(): '
     c                                     + %str(strerror(errno)))
     c                   return    *NULL
     c                   endif

      *************************************************
      * Save space for crap
      *************************************************
     c                   eval      wwRetVal = xalloc(%size(dsMfd))

      *************************************************
      * Create a boundary string
      *************************************************
     c                   time                    wwTS
     c                   move      wwTS          wwTsStr
     c                   eval      wwBoundary = '-httpapi-' + wwTsStr

      *************************************************
      * Set up MFD structure
      *************************************************
     c                   eval      p_Mfd = wwRetVal
     c                   eval      dsMfd_fd = wwFD
     c                   eval      dsMfd_bound = wwBoundary

     c                   eval      peContType = 'multipart/form-data; '
     c                                        + 'boundary=' + wwBoundary

     c                   return    wwRetVal
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mfd_encoder_addvar():  Add a variable to what's stored
      *          a multipart/form-data encoder.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_mfd_encoder_open() routine
      *   peVariable = variable name to add
      *       peData = pointer to data to store in variable
      *   peDataSize = size of data to store in variable
      *   peContType = (optional) Content-type of data in variable
      *                if this parameter is not given, the content
      *                type header will be omitted.
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mfd_encoder_addvar...
     P                 B                   export
     D http_mfd_encoder_addvar...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peData                       *   value
     D    peDataSize                 10I 0 value
     D    peContType              32767a   varying const
     D                                     options(*varsize: *nopass: *omit)

     D CRLF            c                   x'0d25'
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s          33791A   varying

     c                   eval      p_Mfd = peEncoder
     c                   eval      p_LD = %addr(wwLine) + VARPREF

     c                   eval      wwLine = '--' + dsMfd_bound + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Disposition: '
     c                                    + 'form-data; '
     c                                    + 'name="' + peVariable + '"'
     c                                    + CRLF
     c*
     c                   if        %parms>=5 and %addr(peContType)<>*null
     c                   eval      wwLine += 'Content-Type: ' + peContType
     c                                    +  CRLF
     c                   endif
     c*
     c                   eval      wwLine += CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   eval      p_LD = peData
     c                   callp     http_xlate(peDataSize: wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: peDataSize)
     c                   callp     http_xlate(peDataSize: wwLD: TO_EBCDIC)

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mfd_encoder_addvar_s():  Simplified (but limited)
      *       interface to http_mfd_encoder_addvar().
      *
      *    peEncoder = (input) HTTP_mfd_encoder object
      *   peVariable = (input) variable name to set
      *      peValue = (input) value to set variable to
      *   peContType = (optional) Content-type of data in variable
      *                if this parameter is not given, the content
      *                type header will be omitted.
      *
      * Returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mfd_encoder_addvar_s...
     P                 B                   export
     D http_mfd_encoder_addvar_s...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    peValue                   256A   varying value
     D    peContType              32767a   varying const
     D                                     options(*varsize: *nopass: *omit)
     c                   if        %parms>=4 and %addr(peContType)<>*null
     c                   return    http_mfd_encoder_addvar( peEncoder
     c                                          : peVariable
     c                                          : %addr(peValue)+VARPREF
     c                                          : %len(peValue)
     c                                          : peContType )
     c                   else
     c                   return    http_mfd_encoder_addvar( peEncoder
     c                                          : peVariable
     c                                          : %addr(peValue)+VARPREF
     c                                          : %len(peValue))
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mfd_encoder_addstmf(): Add a stream file to what's stored
      *       in a multipart/form-data encoder.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_mfd_encoder_open() routine
      *   peVariable = variable name to add
      *   pePathName = Path name of stream file to add
      *   peContType = Content-type of stream file to add
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mfd_encoder_addstmf...
     P                 B                   export
     D http_mfd_encoder_addstmf...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peVariable                 50A   varying value
     D    pePathName                   *   value options(*string)
     D    peContType              32767a   varying const
     D                                     options(*varsize)

     D wwfilename      s          32767a   varying
     D CRLF            c                   x'0d25'
     D wwFd            s             10I 0
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s          32791A   varying
     D wwBuffer        s          32767A
     D wwLen           s             10I 0
     D showfn          s              1n   inz(*on)

     c                   eval      p_Mfd = peEncoder

     c                   eval      wwFilename = %trimr(%str(pePathname))
     c                   if        %len(wwFilename) > 7
     c                             and %subst(wwFilename:1:7) = 'noshow:'
     c                   eval      showfn = *off
     c                   eval      wwFilename = %subst(wwFilename:8)
     c                   endif

     c                   eval      wwFD = open( wwFilename: O_RDONLY)
     c                   if        wwFD < 0
     c                   callp     SetError( HTTP_IFOPEN
     c                                     : 'open(): '
     c                                     + %str(strerror(errno)))
     c                   return    *OFF
     c                   endif

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = '--' + dsMfd_bound + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Disposition: '
     c                                    + 'form-data; '
     c                                    + 'name="' + peVariable + '"'
     c                   if        showfn = *on
     c                   eval      wwLine += '; filename="'
     c                                    + %str(pePathName) + '"'
     c                   endif
     c                   eval      wwLine += CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Type: '
     c                                    + peContType
     c                                    + CRLF
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   eval      wwLen = read( wwFd
     c                                         : %addr(wwBuffer)
     c                                         : %size(wwBuffer) )
     c                   dow       wwLen > 0
     c                   callp     write( dsMfd_fd
     c                                  : %addr(wwBuffer)
     c                                  : wwLen )
     c                   eval      wwLen = read( wwFd
     c                                         : %addr(wwBuffer)
     c                                         : %size(wwBuffer) )
     c                   enddo

     c                   eval      wwLine = CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   callp     close(wwFD)

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mfd_encoder_close():  close an open multipart/form-data
      *                            encoder.
      *
      *     peEncoder = (input) encoder to close
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mfd_encoder_close...
     P                 B                   export
     D http_mfd_encoder_close...
     D                 PI
     D  peEncoder                      *   value

     D CRLF            c                   x'0d25'
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s           1024A   varying

     c                   eval      p_mfd = peEncoder

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = '--' + dsMfd_Bound + '--'
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMfd_fd : p_LD: %len(wwLine))

     c                   callp     close(dsMfd_fd)

     c                   callp     xdealloc(p_mfd)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_encoder_open(): Create a multipart/related encoder
      *
      * A multipart/related encoder will encode the parts that compose
      * a message and store the results in a stream file.
      * You can later POST those results with the http_url_post_stmf()
      * API.
      *
      *   peStmFile   = (input) pathname to stream file to store
      *                 encoded results.
      *
      *   peType      = (input) the type of content of the starting
      *                 part of the message.
      *
      *   peContType  = (output) the entire calculated content type
      *                 to pass to http_url_post_stmf.
      *
      *   peStartRef  = (input) the id used for the root part of
      *                 the message. Can be omitted, in this case
      *                 the first part of the message is the root.
      *
      *   peStartInfo = (input) the type of content of the root part
      *                 of the message. Can be omitted, in this case
      *                 the first part of the message is the root.
      *
      *   returns an (opaque) pointer to the new encoder
      *           or *NULL upon error.
      *
      * WARNING: To free the memory used by this routine and close
      *          the stream file, you MUST call http_mpr_encoder_close()
      *          after the data is sent.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_encoder_open...
     P                 B                   export
     D http_mpr_encoder_open...
     D                 PI              *
     D  peStmFile                      *   value options(*string)
     D  peType                       64A   varying const
     D  peContType                  256A
     D  peStartRef                   64A   varying const options(*nopass)
     D  peStartInfo                  64A   varying const options(*nopass)

     D wwFilename      s          32767a   varying
     D wwFD            s             10I 0
     D wwTS            s               Z
     D wwTsStr         s             26A
     D wwBoundary      s             32A
     D wwRetVal        s               *

      *************************************************
      *  Open a file to contain the results
      *************************************************
     c                   eval      wwFilename = %trimr(%str(peStmFile))
     c                   eval      wwFD = open( wwFilename
     c                                        : O_WRONLY  +
     c                                          O_CREAT   +
     c                                          O_TRUNC   +
     c                                          CCSID_OR_CP
     c                                        : HTTP_IFSMODE
     c                                        : FILE_CCSID )

     c                   if        wwFD < 0
     c                   callp     SetError( HTTP_IFOPEN
     c                                     : 'open(): '
     c                                     + %str(strerror(errno)))
     c                   return    *NULL
     c                   endif

      *************************************************
      * Save space for crap
      *************************************************
     c                   eval      wwRetVal = xalloc(%size(dsMpr))

      *************************************************
      * Create a boundary string
      *************************************************
     c                   time                    wwTS
     c                   move      wwTS          wwTsStr
     c                   eval      wwBoundary = '-httpapi-' + wwTsStr

      *************************************************
      * Set up MPR structure
      *************************************************
     c                   eval      p_Mpr = wwRetVal
     c                   eval      dsMpr_bound = wwBoundary
     c                   eval      dsMpr_fd = wwFD

     c                   eval      peContType = 'multipart/related; '
     c                                        + 'type="' + %trim(peType) + '"; '
     c                                        + 'boundary=' + wwBoundary
     c                   if        %parms > 3
     c                   eval      peContType = %trim(peContType) + '; '
     c                                        + 'start="' + %trim(peStartRef)
     c                                        + '"'
     c                   endif
     c                   if        %parms > 4
     c                   eval      peContType = %trim(peContType) + '; '
     c                                        + 'start-info="'
     c                                        + %trim(peStartInfo)
     c                                        + '"'
     c                   endif

     c                   return    wwRetVal
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_encoder_addstr():  Add a part to what's stored
      *          a multipart/related encoder in the form of a string.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_mfd_encoder_open() routine
      *       peData = pointer to data to store in variable
      *   peDataSize = size of data to store in variable
      *   peContType = Content-type of string to add
      *     peContID = The ID of the part
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_encoder_addstr...
     P                 B                   export
     D http_mpr_encoder_addstr...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peData                       *   value
     D    peDataSize                 10I 0 value
     D    peContType                256A   varying const
     D    peContID                   64A   varying const

     D CRLF            c                   x'0d25'
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s           1024A   varying

     c                   eval      p_Mpr = peEncoder
     c                   eval      p_LD = %addr(wwLine) + VARPREF

     c                   eval      wwLine = '--' + dsMpr_bound + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Type: '
     c                                    + peContType
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Transfer-Encoding: '
     c                                    + '8bit'
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Id: '
     c                                    + peContId
     c                                    + CRLF
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      p_LD = peData
     c                   callp     http_xlate(peDataSize: wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: peDataSize)
     c                   callp     http_xlate(peDataSize: wwLD: TO_EBCDIC)

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_encoder_addstr_s():  Simplified (but limited)
      *       interface to http_mpr_encoder_addvar().
      *
      *    peEncoder = (input) HTTP_mpr_encoder object
      *       peData = (input) string to write
      *   peContType = Content-type of string to add
      *     peContID = The ID of the part
      *
      * Returns *ON if successful, *OFF otherwise
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_encoder_addstr_s...
     P                 B                   export
     D http_mpr_encoder_addstr_s...
     D                 PI             1N
     D    peEncoder                    *   value
     D    peData                  32767A   varying value
     D    peContType                256A   varying const
     D    peContID                   64A   varying const
     c                   return    http_mpr_encoder_addstr( peEncoder
     c                                          : %addr(peData)+VARPREF
     c                                          : %len(peData)
     c                                          : peContType
     c                                          : peContId )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_encoder_addstmf(): Add a stream file to what's stored
      *       in a multipart/related encoder.
      *
      *    peEncoder = pointer to encoder created by the
      *                  http_mfd_encoder_open() routine
      *   pePathName = Path name of stream file to add
      *   peContType = Content-type of stream file to add
      *     peContID = The ID of the part
      *
      * Returns *ON if successful, *OFF otherwise.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_encoder_addstmf...
     P                 B                   export
     D http_mpr_encoder_addstmf...
     D                 PI             1N
     D    peEncoder                    *   value
     D    pePathName                   *   value options(*string)
     D    peContType                256A   varying const
     D    peContID                   64A   varying const

     D wwfilename      s          32767a   varying
     D CRLF            c                   x'0d25'
     D wwFd            s             10I 0
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s           1024A   varying
     D wwBuffer        s          32767A
     D wwLen           s             10I 0

     c                   eval      p_Mpr = peEncoder

     c                   eval      wwFilename = %trimr(%str(pePathname))
     c                   eval      wwFD = open( wwFilename: O_RDONLY)
     c                   if        wwFD < 0
     c                   callp     SetError( HTTP_IFOPEN
     c                                     : 'open(): '
     c                                     + %str(strerror(errno)))
     c                   return    *OFF
     c                   endif

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = '--' + dsMpr_bound + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Type: '
     c                                    + %trim(peContType)
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Transfer-Encoding: '
     c                                    + 'binary'
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLine = 'Content-Id: '
     c                                    + %trim(peContId)
     c                                    + CRLF
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   eval      wwLen = read( wwFd
     c                                         : %addr(wwBuffer)
     c                                         : %size(wwBuffer) )
     c                   dow       wwLen > 0
     c                   callp     write( dsMpr_fd
     c                                  : %addr(wwBuffer)
     c                                  : wwLen )
     c                   eval      wwLen = read( wwFd
     c                                         : %addr(wwBuffer)
     c                                         : %size(wwBuffer) )
     c                   enddo

     c                   eval      wwLine = CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   callp     close(wwFD)

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_mpr_encoder_close():  close an open multipart/related
      *                            encoder.
      *
      *     peEncoder = (input) encoder to close
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_mpr_encoder_close...
     P                 B                   export
     D http_mpr_encoder_close...
     D                 PI
     D  peEncoder                      *   value

     D CRLF            c                   x'0d25'
     D p_LD            s               *
     D wwLD            s              1A   based(p_LD)
     D wwLine          s           1024A   varying

     c                   eval      p_mpr = peEncoder

     c                   eval      p_LD = %addr(wwLine) + VARPREF
     c                   eval      wwLine = '--' + dsMpr_Bound + '--'
     c                                    + CRLF
     c                   callp     http_xlate(%len(wwLine): wwLD: TO_ASCII)
     c                   callp     write(dsMpr_fd : p_LD: %len(wwLine))

     c                   callp     close(dsMpr_fd)

     c                   callp     xdealloc(p_mpr)
     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy errno_h

     /*-                                                                            +
      * Copyright (c) 2012-2025 Thomas Raddatz                                      +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +
      *=====================================================================*
      *  NTLM: Data encryption and digest services                          *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  28.02.2012                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Date        Name          Description                              *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*NOSHOWCPY: *SRCSTMT: *NODEBUGIO)
      /endif
     H NOMAIN
      *=====================================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  Exported prototypes
      * ------------------------------------
      /DEFINE RC4_INTERNAL_USE
      /DEFINE MD4_INTERNAL_USE
      /DEFINE MD5_INTERNAL_USE
      *
      /COPY NTLM_H
      /COPY NTLM_P
      /COPY MD4_H
      *
      * ------------------------------------
      *  Imported prototypes
      * ------------------------------------
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      *
      *  Calculates the odd parity bit for each byte
      *  of a given value.
     D setParityBit...
     D                 PR             1A
     D                                     extproc('setParityBit')
     D  i_char                        1A   const
      *
      *  QtqIconvOpen()--Code Conversion Allocation API
     D QtqIconv_open...
     D                 PR                  extproc('QtqIconvOpen')
     D                                     likeds(iconv_t )
     D  i_toCode                           const  likeds(QtqCode_t)
     D  i_fromCode                         const  likeds(QtqCode_t)
      *
     D iconv_t         DS                  qualified   based(pDummy)   align
     D  return_value                 10I 0
     D  cd                           10I 0 dim(12)
      *
     D QtqCode_t...
     D                 DS                  qualified   based(pDummy)
     D  ccsid                        10I 0
     D  conversionA                  10I 0
     D  substitutionA                10I 0
     D  shiftStateA                  10I 0
     D  inpLenOpt                    10I 0
     D  errOptMxdDta                 10I 0
     D  reserved                     12A
      *
      *  iconv()--Code Conversion API
     D iconv...
     D                 PR            10U 0        extproc('iconv')
     D  i_cd                               value likeds(iconv_t  )
     D  i_pInBuf                       *
     D  i_inBytLeft                  10U 0
     D  i_pOutBuf                      *
     D  i_outBytLeft                 10U 0
      *
     D ICONV_ERROR     C                   const(4294967295)
     D E2BIG_C         C                   const(3491)                          Argument list
      *
      *  iconv_close()--Code Conversion Deallocation API
     D iconv_close...
     D                 PR            10I 0        extproc('iconv_close')
     D  i_cd                               value likeds(iconv_t  )
      *
      *  Cipher (CIPHER)
     D cipher...
     D                 PR                  extproc('_CIPHER')
     D                                 *   const
     D                                 *   value
     D                                 *   const
      *
     D cipherCtrls_0005_t...
     D                 DS                  qualified  based(pDummy)  align
     D  function               1      2A
     D  hashAlg                3      3A
     D  sequence               4      4A
     D  dataLength             5      8U 0
     D  output                 9      9A
     D  reserved_1            10     16A
     D  hashContext           17     32*
     D  HMACKey               33     48*
     D  HMACKeyLength         49     52U 0
     D  reserved_2            53     96A
      *
     D cipherCtrls_0013_t...
     D                 DS                  qualified  based(pDummy)  align
     D  function               1      2A
     D  dataLength             3      4U 0
     D  operation              5      5A
     D  reserved               6     16A
     D  keyCtxPtr             17     32*
      *
     D cCIPHER_ENCRYPT...
     D                 C                   const(x'00')
     D cCIPHER_DECRYPT...
     D                 C                   const(x'01')
      *
     D cCIPHER_MD5...
     D                 C                   const(x'00')
     D cCIPHER_HASH...
     D                 C                   const(x'00')
     D cCIPHER_HMAC...
     D                 C                   const(x'01')
     D cCIPHER_ONLY...
     D                 C                   const(x'00')
      *
     D MD5_CTX_t       DS                  qualified               based(pDummy)
     D  key                          16A
     D  context                     160A
     D  state                         1A
     D  digest                       16A
      *
     D rc4_ctx_t       ds                  qualified  based(pDummy)
     D   stream                     256A
     D   length                       5U 0
     D   reserved                     6A
      *
      *  Encrypt Data (QC3ENCDT, Qc3EncryptData) API
      /if defined(NTLM_SUPPORT)
     D Qc3EncryptData...
     D                 PR                  extproc('Qc3EncryptData')
     D  i_clearData               65535A   const  options(*varsize)
     D  i_length                     10I 0 const
     D  i_dataFormat                  8A   const
     D  i_algDesc                 65535A   const  options(*varsize)
     D  i_algFormat                   8A   const
     D  i_keyDesc                 65535A   const  options(*varsize)
     D  i_keyFormat                   8A   const
     D  i_cyptSrvPrv                  1A   const
     D  i_cyptDevNme                 10A   const
     D  o_encypted                65535A          options(*varsize)
     D  i_encLenPrv                  10I 0 const
     D  o_encLenRet                  10I 0
     D  io_ErrCode                32767A          options(*nopass: *varsize)
      /endif

     D algd0200_t      DS                  qualified               based(pDummy)
     D  algorithm                    10I 0
     D  blockLen                     10I 0
     D  mode                          1A
     D  padOption                     1A
     D  padChar                       1A
     D  reserved_1                    1A
     D  macLen                       10I 0
     D  keySize                      10I 0
     D  initVector                   32A
      *
     D keyd0200_t      DS                  qualified               based(pDummy)
     D  type                         10I 0
     D  length                       10I 0
     D  format                        1A
     D  reserved_1                    3A
     D  value                         8A
      *
      * ------------------------------------
      *  Global fields
      * ------------------------------------
      *
      *=====================================================================*
    R *  *** Exported, because internally used by NTLMR4, RPGUNIT tests ***
      *  Encrypts a given string using the RC4 algorithm
      *=====================================================================*
     P RC4...
     P                 B                   export
      *
     D RC4...
     D                 PI          4096A          varying
     D  i_key                              const  like(RC4_key_t   )
     D  i_string                   4096A          varying options(*varsize)
      *
      *  Return value
     D digest          S           4096A   varying inz
      *
      *  Local fields
     D controls        DS                  likeds(cipherCtrls_0013_t) inz
     D rc4_ctx         DS                  likeds(rc4_ctx_t         ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return '';
         endif;

         rc4_ctx = *ALLx'00';
         %subst(rc4_ctx.stream: 1: %len(i_key)) = i_key;
         rc4_ctx.length = %len(i_key);
         rc4_ctx.reserved = *ALLx'00';

         controls = *ALLx'00';

         controls.function   = x'0013';          // RC4
         controls.dataLength = %len(i_string);
         controls.operation  = cCIPHER_ENCRYPT;  // Hex 00 = Encrypt
                                                 // Hex 01 = Decrypt
         controls.reserved   = *ALLx'00';
         controls.keyCtxPtr  = %addr(rc4_ctx);

         %len(digest) = %len(i_string);
         cipher(%addr(digest)+2: %addr(controls): %addr(i_string)+2);

         return digest;

      /END-FREE
      *
     P RC4...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by NTLMR4, RPGUNIT tests ***
      *  Encrypts a given string using the DES algorithm
      *=====================================================================*
     P DES...
     P                 B                   export
      *
     D DES...
     D                 PI          4096A          varying
     D  i_string                   4096A   const  varying options(*varsize)
     D  i_challenge                        const  like(ntlm_challenge_t )
      *
      *  Return value
     D encrypted       S           4096A   varying inz
      *
      *  Local fields
     D tmpEncrypted    S           4096A   inz
     D encryptedLen    S             10I 0 inz
      *
     D algd0200        DS                  likeds(algd0200_t ) inz
     D keyd0200        DS                  likeds(keyd0200_t ) inz
     D errCode         DS                  likeds(errCode_t  ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return i_string;
         endif;

         algd0200 = *ALLx'00';
         algd0200.algorithm  = 20;
         algd0200.blockLen   = 8;
         algd0200.mode       = '0';
         algd0200.padOption  = '1';
         algd0200.padChar    = x'00';
         algd0200.reserved_1 = *ALLx'00';
         algd0200.macLen     = 0;
         algd0200.keySize    = 0;
         algd0200.initVector = *ALLx'00';

         keyd0200 = *ALLx'00';
         keyd0200.type       = 20;
         keyd0200.length     = 8;
         keyd0200.format     = '0';
         keyd0200.reserved_1 = *ALLx'00';
         keyd0200.value      = i_challenge;

         clear errCode;
      /if defined(NTLM_SUPPORT)
         Qc3EncryptData(i_string              // Clear data
                        : %len(i_string)      // Length of clear data
                        : 'DATA0100'          // Clear data format name
                        : algd0200            // Algorithm description
                        : 'ALGD0200'          // Algorithm description format name
                        : keyd0200            // Key description
                        : 'KEYD0200'          // Key description format name
                        : '0'                 // Cryptographic service provider
                        : ''                  // Cryptographic device name
                        : tmpEncrypted        // Encrypted data
                        : %size(tmpEncrypted) // Length of area provided for encrypted data
                        : encryptedLen        // Length of encrypted data returned
                        : errCode);           // Error code
      /endif
         encrypted = %subst(tmpEncrypted: 1: encryptedLen);

         return encrypted;

      /END-FREE
      *
     P DES...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by NTLMR4, RPGUNIT tests ***
      *  Calculates a DES key from a given key value.
      *=====================================================================*
     P DES_produceKey...
     P                 B                   export
      *
     D DES_produceKey...
     D                 PI                         like(DES_key_t )
     D  i_value                       7A   const
      *
      *  Return value
     D desKey          S                   like(DES_key_t ) inz(x'00')
      *
      *  Local fields
     D x               S             10I 0 inz
     D i               S             10I 0 inz
     D char            S              1A   inz(x'00')
      *
     D inp             DS                  qualified
     D  lm_byte                1      1A
     D  lm_int4                1      4U 0
     D  lm_int4_4              4      4A
     D  rm_int4_1              5      5A
     D  rm_int4                5      8U 0
     D  value                  1      7A
     D  rm_byte                8      8A   inz(x'00')
      *
     D tmp             DS                  qualified
     D  int4                   1      4I 0 inz
     D  byte                   4      4    inz(x'00')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         inp = *ALLx'00';
         inp.value = i_value;

         for x = 1 to 8;

            // get the 7 left most bits of the left most byte
            char = byteand(inp.lm_byte: x'FE');

            // set parity bit
            char = setParityBit(char);

            // put result into the DES key value
            i = i + 1;
            %subst(desKey: i: 1) = char;

            // shift the 4 left most bytes 7 bits to the left
            inp.lm_int4 = bitand(inp.lm_int4: x'01FFFFFF');
            inp.lm_int4 = inp.lm_int4 * 128;

            // shift the 7 left most bits of byte 5 to byte 4
            tmp.byte = byteand(inp.rm_int4_1: x'FE');
            tmp.int4 = tmp.int4 / 2;
            inp.lm_int4_4 = byteor(inp.lm_int4_4: tmp.byte);

            // shift the 4 right most bytes 7 bits to the left
            inp.rm_int4 = bitand(inp.rm_int4: x'01FFFFFF');
            inp.rm_int4 = inp.rm_int4 * 128;

         endfor;

         return desKey;

      /END-FREE
      *
     P DES_produceKey...
     P                 E
      *
      *=====================================================================*
    R *  *** Private ***
      *  Calculates the odd parity bit for each byte
      *  of a given value.
      *=====================================================================*
     P setParityBit...
     P                 B
      *
     D setParityBit...
     D                 PI             1A
     D  i_char                        1A   const
      *
      *  Return value
     D char            S              1A   inz
      *
      *  Local fields
     D x               S             10I 0 inz
     D num1Bits        S             10I 0 inz
      *
     D bit             S              1A   dim(7)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         bit(7) = byteand(i_char: x'80') = x'80';
         bit(6) = byteand(i_char: x'40') = x'40';
         bit(5) = byteand(i_char: x'20') = x'20';
         bit(4) = byteand(i_char: x'10') = x'10';
         bit(3) = byteand(i_char: x'08') = x'08';
         bit(2) = byteand(i_char: x'04') = x'04';
         bit(1) = byteand(i_char: x'02') = x'02';

         for x = 1 to %elem(bit);
            if (bit(x)) = '1';
               num1Bits = num1Bits + 1;
            endif;
         endfor;

         if (%rem(num1Bits: 2) = 0);
            char = byteor(i_char: x'01');
         else;
            char = byteand(i_char: x'FE');
         endif;

         return char;

      /END-FREE
      *
     P setParityBit...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by NTLMR4, RPGUNIT tests ***
      *  MD4 operation.
      *=====================================================================*
     P MD4...
     P                 B                   export
      *
     D MD4...
     D                 PI                         like(MD4_digest_t )
     D  i_string                   4096A          varying options(*varsize)
      *
      *  Return value
     D digest          S                   like(MD4_digest_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         MD4Only_r(digest: %addr(i_string)+2: %len(i_string));

         return digest;

      /END-FREE
      *
     P MD4...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by NTLMR4, RPGUNIT tests ***
      *  Returns the MD5 digest of a given string.
      *=====================================================================*
     P MD5Hmac...
     P                 B                   export
      *
     D MD5Hmac...
     D                 PI                         like(MD5_digest_t)
     D  i_hmacKey                          const  like(MD5_digest_t)
     D  i_string                   4096A          varying options(*varsize)
      *
      *  Return value
     D digest          S                   like(MD5_digest_t   )
      *
      *  Local fields
     D controls        DS                  likeds(cipherCtrls_0005_t) inz
     D MD5_CTX         DS                  likeds(MD5_CTX_t         ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return '';
         endif;

         MD5_CTX.key = i_hmacKey;
         MD5_CTX.context = *ALLx'00';
         MD5_CTX.state = cCIPHER_ONLY;
         MD5_CTX.digest = *ALLx'00';

         controls = *ALLx'00';

         controls.function      = x'0005';       // MD5 or SHA-1
         controls.hashAlg       = cCIPHER_MD5;   // Hex 00 = MD5
                                                 // Hex 01 = SHA-1
         controls.sequence      = MD5_CTX.state; // Hex 00 = Only
                                                 // Hex 01 = First
                                                 // Hex 02 = Middle
                                                 // Hex 03 = Final
         controls.dataLength    = %len(i_string);
         controls.output        = cCIPHER_HMAC;  // Hex 00 =  Hash
                                                 // Hex 01 =  HMAC
         controls.hashContext   = %addr(MD5_CTX.context);
         controls.HMACKey       = %addr(MD5_CTX.key);
         controls.HMACKeyLength = %size(MD5_CTX.key);

         cipher(%addr(MD5_CTX.digest): %addr(controls): %addr(i_string)+2);

         digest = MD5_CTX.digest;

         return digest;

      /END-FREE
      *
     P MD5Hmac...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by NTLMR4, RPGUNIT tests ***
      *  Returns the MD5 digest of a given string.
      *=====================================================================*
     P MD5Digest...
     P                 B                   export
      *
     D MD5Digest...
     D                 PI                         like(MD5_digest_t)
     D  i_string                   4096A          varying options(*varsize)
      *
      *  Return value
     D digest          S                   like(MD5_digest_t   )
      *
      *  Local fields
     D controls        DS                  likeds(cipherCtrls_0005_t) inz
     D MD5_CTX         DS                  likeds(MD5_CTX_t         ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return '';
         endif;

         MD5_CTX.key = *ALLx'00';
         MD5_CTX.context = *ALLx'00';
         MD5_CTX.state = cCIPHER_ONLY;
         MD5_CTX.digest = *ALLx'00';

         controls = *ALLx'00';

         controls.function      = x'0005';       // MD5 or SHA-1
         controls.hashAlg       = cCIPHER_MD5;   // Hex 00 = MD5
                                                 // Hex 01 = SHA-1
         controls.sequence      = MD5_CTX.state; // Hex 00 = Only
                                                 // Hex 01 = First
                                                 // Hex 02 = Middle
                                                 // Hex 03 = Final
         controls.dataLength    = %len(i_string);
         controls.output        = cCIPHER_HASH;  // Hex 00 =  Hash
                                                 // Hex 01 =  HMAC
         controls.hashContext   = %addr(MD5_CTX.context);
         controls.HMACKey       = *NULL;
         controls.HMACKeyLength = 0;

         cipher(%addr(MD5_CTX.digest): %addr(controls): %addr(i_string)+2);

         digest = MD5_CTX.digest;

         return digest;

      /END-FREE
      *
     P MD5Digest...
     P                 E
      *
      * THE STORY:
      * ----------
      * HTTPAPI is a tool designed to help work with the HTTP protocol
      * in ILE RPG (and possibly other languages). The members named
      * EXAMPLE are intended to teach you the basics of using HTTPAPI.
      * when you are done with this member, please proceed to EXAMPLE2.
      *
      * EXAMPLE1:
      * ----------
      * This first example will demonstrate how to connect to a web
      * address (called a "URL") and download data from that web server.
      * The network protocol that web servers speak is called "HTTP".
      *
      * HTTPAPI does not try to be a web browser. It has no idea what
      * data it's downloading, or how to display it.  It only knows
      * how to retrieve data and store it somewhere.
      *
      * EXAMPLE1 will download a PDF document (though, any type of
      * document should work) and save it to a file in the IFS.
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D rc              s             10I 0
     D msg             s             52A
     D URL             S            300A    varying
     D IFS             S            256A    varying

      *********************************************************
      *  Turning on debugging.
      *
      *     Calling http_debug and passing *ON will turn on
      *     HTTPAPI's debugging support.  It will write a debug
      *     log file to the IFS in /tmp/httpapi_debug.txt
      *     with loads of tech info about the HTTP transaction.
      *
      *     The debug file is crucial if you have problems!
      *********************************************************
     c                   callp     http_debug(*ON)


      *********************************************************
      *  Setting a proxy (if you need it!)
      *********************************************************
     C* Some corporate networks require you to send HTTP requests
     C* through a proxy server (and some do not!) If yours does,
     C* you'll need to uncomment these lines and set the right
     C* proxy for your network:
     C*
     c****               callp     http_setproxy( 'proxy.example.com'
     c****                                      : 8080 )

     C* If you use a corporate proxy, and it requires a userid/password
     C* you'll have to uncomment the following and set the user/pass
     C* accordingly.
     c*
     C****               callp     http_proxy_setauth( HTTP_AUTH_BASIC
     C****                                           : 'userid'
     C****                                           : 'password' )

     C* More proxy notes:
     C*    -- proxy is only required if your network requires it.
     C*    -- user/pass is only required if your network requires it,
     C*         (you can use a proxy without a user/password by leaving
     C*             http_proxy_setauth() commented out...)
     C*    -- The parameters for the preceding routines can be set with
     C*         variables in place of the constants if you prefer.
     C*         it's up to you.


      *********************************************************
      *  What do I want to get?   Where should I put it?
      *********************************************************
     C* The URL points to a place on Scott's web site where
     C*   he has a PDF file.
     C* The IFS variable tells HTTPAPI where to put it on your
     C*   local computer.

     c                   eval      URL = 'http://www.scottklement.com'
     c                                 + '/presentations/'
     c                                 + 'Web Services from RPG with '
     c                                 + 'HTTPAPI.pdf'

     c                   eval      IFS = '/tmp/Scott''s HTTPAPI '
     c                                 + 'presentation handout.pdf'

     C* Now call HTTPAPI's routine that receives to a stream file
     C*  with the above variables as parameters. It will download
     C*  to the IFS.
     C*
     c                   callp     http_stmf('GET': URL: IFS)

     c                   eval      *inlr = *on
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      *
      * This example shows how to send a "tweet" (change your
      * status on Twitter.com) via HTTPAPI.
      *
      * You must pass a userid/password.  This tells Twitter.com
      * which Twitter account to update.
      *
      *   CALL EXAMPLE10 PARM('youruserid' 'yourpassword')
      *
      *

      /define WEBFORMS
      /include httpapi_h

     D EXAMPLE10       PR                  ExtPgm('EXAMPLE10')
     D   userid                      32a   const
     D   passwd                      32a   const
      * This works like *ENTRY PLIST
     D EXAMPLE10       PI
     D   userid                      32a   const
     D   passwd                      32a   const

     D xmlReply        PR
     D   tw                                likeds(tweet)
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const

     D tweet           ds                  qualified
     D   id                          20a   varying
     D   text                       140a   varying inz('')
     D   created                     30a   varying

     D newStatus       s            140a   varying
     D form            s                   like(WEBFORM)
     D rc              s             10I 0
     D postData        s               *
     D postDataSize    s             10I 0

      /free
         if %parms < 2;
            http_comp('You must pass a USERID & PASSWORD');
            return;
         endif;

         //
         //  the http_setAuth() routine is used to set
         //  the userid/password of the HTTP connection.
         //

         http_setAuth( HTTP_AUTH_BASIC
                     : %trim(Userid)
                     : %trim(Passwd) );


         //
         //  newStatus is the new status message to set.
         //  because of spaces & other special symbols,
         //  it must be encoded, like a form on a web page.
         //

         newStatus = 'is testing HTTPAPI from ScottKlement.com';

         form = WEBFORM_open();
         WEBFORM_setVar(form: 'status': newstatus );
         WEBFORM_postData(form: postData: postDataSize );

         //
         //  http_post_xml() sends the encoded data to Twitter,
         //   receives the reply, and parses the reply as an
         //   XML document.
         //
         //  Note: We must set http_set_100_timeout() because
         //        Twitter doesn't allow Expect: 100-continue
         //        despite that RFC2616 says that all HTTP 1.1
         //        servers must recognize it.  Bug in Twitter??
         //

         http_set_100_timeout(0);
         rc = http_post_xml( 'http://twitter.com/statuses/update.xml'
                           : postData
                           : postDataSize
                           : *null
                           : %paddr(xmlReply)
                           : %addr(tweet)
                           : HTTP_TIMEOUT
                           : HTTP_USERAGENT
                           : 'application/x-www-form-urlencoded' );
         WEBFORM_close(form);
         if (rc <> 1);
            http_crash();
            return;
         endif;

         http_comp( 'Twitter status set at ' + tweet.created
                  + ' id=' + tweet.id);
         http_comp( 'Twitter status is now: ' + tweet.text );

         *inlr = *on;

      /end-free


      *------------------------------------------------------
      * xmlReply(): retrieve the XML reply from Twitter.
      *
      *  http_post_xml will call this subprocedure while
      *   it's parsing the XML.  It will call it individually
      *   for each XML tag it receives.
      *------------------------------------------------------
     P xmlReply        B
     D xmlReply        PI
     D   tw                                likeds(tweet)
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
      /free
         if path='/status';
            select;
            when name = 'created_at';
              tw.created = value;
            when name = 'id';
              tw.id = value;
            when name = 'text';
              tw.text = value;
            endsl;
          endif;
      /end-free
     P                 E
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

     FQSYSPRT   O    F  132        PRINTER OFLIND(*INOF)

      /copy httpapi_h
      /copy ifsio_h

     D Incoming        PR
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   Attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D num             s             10I 0
     D item            ds                  occurs(10)
     D   title                      512A   varying
     D   artlink                    512A   varying

     D msg             s             50A
     D rc              s             10I 0
     D url             s            100A   varying
     D PrintLine       s            132A
     D x               s             10I 0
     D filename        s             45A   varying

      /free

        *inlr = *on;
        http_debug(*ON);

        // ****************************************************
        //  Download the latest news headlines from CNN
        //  to a temporary file in the IFS
        // ****************************************************
        url = 'http://rss.cnn.com/rss/cnn_topstories.rss';
        filename = http_tempfile() + '.xml';

        rc = http_url_get( url : filename );
        if (rc <> 1);
           PrintLine = http_error();
           except;
           unlink(filename);
           return;
        endif;

        // ****************************************************
        //   parse the XML from the temp file.
        // ****************************************************

        if (http_parse_xml_stmf( filename
                               : HTTP_XML_CALC
                               : *null
                               : %paddr(Incoming)
                               : *null ) < 0 );
           PrintLine = http_error();
           except;
           unlink(filename);
           return;
        endif;

        // ****************************************************
        //  Print the news headlines & links to the full
        //   articles
        //
        //  Note:  If you wanted to, you could retrieve the
        //         articles themselves by calling http_url_get
        //         for each link.
        // ****************************************************

        if num > %elem(item);
           num = %elem(item);
        endif;

        for x = 1 to num;
           %occur(item) = x;
           PrintLine = title;
           except;
           PrintLine = '  ' + artlink;
           except;
           PrintLine = '';
           except;
        endfor;

        unlink(filename);
        return;

      /end-free

     OQSYSPRT   E
     O                       PrintLine          132


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This is called for each XML element that's received in the
      *  document. The document that's received will look something
      *  like the following:
      *
      *     <rss version="2.0">
      *       <channel>
      *         <title>Title of Newsfeed channel</title>
      *         <link>http://www.blahblahblah.com</link>
      *         <description>Whatever Headlines</description>
      *         <language>en-US</language>
      *         <item>
      *           <title>Title of first article</title>
      *           <link>link to first article</link>
      *         </item>
      *         <item>
      *           <title>Title of second article</title>
      *           <link>link to second article</link>
      *         </item>
      *       </channel>
      *     </rss>
      *
      *  The DEPTH parameter indicates the nesting depth of the
      *  element received.  In the above example, the "item" tag
      *  would be found at depth=3, since it's inside the "rss"
      *  and "channel" tags.
      *
      *  The NAME parameter is the name of the XML element that
      *  has been received.  It might be something like "channel"
      *  or "title" or "link".
      *
      *  Note that in the above example, there are two different
      *  depths that have "title" and "link".  They are featured
      *  inside the "channel" tag, and also inside the "item" tag.
      *  the "path" parameter will help us sort that out.
      *
      *  The PATH indicates the elements that the current element
      *  is found inside. So, the channel title is found when the
      *  path is "/rss/channel" and the name of the element is "title".
      *  the article titles, however, have a path of "/rss/channel/item"
      *  and a name of "title".
      *
      *  The VALUE parameter gives us the text that's inside that
      *  element.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P Incoming        B
     D Incoming        PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D count           s             10I 0
     D attrname        s           1024A   varying
     D attrval         s          65535A   varying
      /free
         if (num > %elem(item));
             return;
         endif;

         if ( path = '/rss/channel/item' );

            select;
            when name = 'title';
               num = num + 1;
               if (num <= %elem(item));
                  %occur(item) = num;
                  title = value;
               endif;
            when name = 'link';
               artlink = value;
            endsl;

         endif;


         // sometimes an element will have attributes.  In the example
         // XML shown above, the only attribute is the VERSION attrib
         // of the RSS tag.
         //
         // The following searches through the attribute list of the
         // rss tag to extract the version number.

         if (name = 'rss');

            count = 1;
            dow http_nextXmlAttr(attrs: count: attrname: attrval);
               if (attrname = 'version');
                  PrintLine = 'RSS version ' + attrval;
                  except;
               endif;
            enddo;

         endif;

      /end-free
     P                 E
      *  Example of looking up the weather from Weather Underground's
      *  RESTful web service from RPG.
      *
      *  To compile:
      *    * Make sure HTTPAPI is installed and in your *LIBL
      *    * CRTBNDRPG EXAMPLE12 SRCFILE(xxx/QRPGLESRC)
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP('KLEMENT')
      /endif
     H BNDDIR('HTTPAPI')

      /define WEBFORMS
      /copy httpapi_h

     D EXAMPLE12       PR                  ExtPgm('EXAMPLE12')
     D   queryString                 32a   const
     D EXAMPLE12       PI
     D   queryString                 32a   const

     D QUILNGTX        PR                  ExtPgm('QUILNGTX')
     D   text                     65535a   const options(*varsize)
     D   length                      10i 0 const
     D   msgid                        7a   const
     D   qualmsgf                    20a   const
     D   errorCode                32767a   options(*varsize)

     D ErrorEscape     ds                  qualified
     D   bytesProv                   10i 0 inz(0)
     D   bytesAvail                  10i 0 inz(0)

     D parseWeather    PR
     D   userData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D showForecast    PR
     D   msg                      65535a   varying const options(*varsize)

     D form            s                   like(WEBFORM)
     D rc              s             10i 0
     D uri             s            200a   varying

      /free
        if %parms() < 1;
           http_comp('Please pass a city name or postal code!');
           return;
        endif;

        //
        //  The query (city name/postal code) must be URL encoded
        //  like a form on a web page
        //

        form = webform_open();
        webform_setVar(form: 'query': %trim(queryString));
        uri ='http://api.wunderground.com/auto/wui/geo/ForecastXML/+
              index.xml?query=' + webform_getData(Form);
        webform_close(form);

        //
        // get the response, and parse it as an XML document.
        //  http_url_get_xml() will call the parseWeather procedure
        //  for each XML tag found.
        //

        rc = http_url_get_xml( uri: *null: %paddr(parseWeather): *null);
        if (rc <> 1);
           http_crash();
        endif;

        *inlr = *on;
      /end-free

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * parseWeather(): This is called by http_url_get_xml() for
      *   each XML tag found.
      *
      * When we see a weatther forecast in an <fcttext> tag, then
      * we'll display it's contents on the screen via the
      * IBM-supplied QUILNGTX API.
      *
      * The QUILNGTX is just an easy way to display a window with
      * text on the screen.  If you'd prefer to do something else
      * with the forecast, simply write the VALUE variable to
      * whereever you want the forecast to go...
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P parseWeather    B
     D                 PI
     D   userData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D title           s             80a   varying static
      /free
         if path = '/forecast/txt_forecast/forecastday';
            select;
            when name='title';
               title=value;
            when name='fcttext';
               showForecast(title + ': ' + value);
            endsl;
         endif;
      /end-free
     P                 E

     P showForecast    B
     D showForecast    PI
     D   msg                      65535a   varying const options(*varsize)
      /free
        QUILNGTX( msg
                : %len(msg)
                : *blanks
                : *blanks
                : errorEscape );
      /end-free
     P                 E
      * EXAMPLE14:  Track a package with UPS.
      *
      * This is an interactive program that asks for a UPS tracking
      * number, then gets the status of that package from UPS. You
      * might use this as a model for your own custom tracking app.
      * for example:
      *     -- Modify it to get the tracking number from your
      *        database instead of from the user.  (User keys an
      *        order number, it looks up the UPS tracking number,
      *        and tracks it, real time!)
      *     -- Modify it to track all packages for a day during
      *        a batch run, instead of working interactively.
      *     -- Make it a Web app where customers can see the
      *        status of their orders on-line.
      *
      * UPS offers several other services besides tracking, and you
      * can use this as a model for accessing those services as well.
      *
      * Prior to using this application, you *MUST* register with UPS,
      * then fill-in the UPS_USERID, UPS_PASSWD and UPS_LICENSE
      * constants in the D-specs below.
      *
      * For more information, see the following:
      *   http://ups.com/content/us/en/bussol/offering
      *       /technology/automated_shipping/online_tools.html
      *
      * Here's a shorter/easier link:
      *   http://tinyurl.com/hsrzt
      *
      * The URL used herein is UPS's URL for testing. They have a
      * different one for production. See the PDF documentation for
      * tracking found on the above Web site for more info.
      *
      * To Compile:
      *    CRTDSPF FILE(EXAMPLE14S) SRCFILE(xxx/QDDSSRC)
      *    CRTBNDRPG EXAMPLE14 SRCFILE(xxx/QRPGLESRC) DBGVIEW(*LIST)
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) 
      /endif
     H BNDDIR('HTTPAPI')

     FEXAMPLE14SCF   E             WORKSTN SFILE(SFLREC: RRN)
     F                                     indds(dsIndic)

      /copy httpapi_h

     D StartOfElement  PR
     D   UserData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D EndOfElement    PR
     D   UserData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D UPS_USERID      C                   '<put your userid here>'
     D UPS_PASSWD      C                   '<put your password here>'
     D UPS_LICENSE     C                   '<put your access license here>'

     D dsIndic         ds
     D   ExitKey              03     03N
     D   Clear_Sfl            50     50N
     D   Empty_Sfl            51     51N

     d act             s             10I 0
     d activity        ds                  qualified
     d   array                             dim(100)
     d   Date                         8A   overlay(array)
     d   Time                         6A   overlay(array:*next)
     D   Desc                        20A   overlay(array:*next)
     D   City                        20A   overlay(array:*next)
     D   State                        2A   overlay(array:*next)
     D   Status                      20A   overlay(array:*next)
     D   SignedBy                    20A   overlay(array:*next)

     D rc              s             10I 0
     D postData        s            750A   varying
     D TrackingNo      s             24A   varying
     D RRN             s              4  0
     D tempDate        s               D
     D tempTime        s               T

      /free
         if (  %subst(UPS_USERID:1:1) = '<'
            or %subst(UPS_PASSWD:1:1) = '<'
            or %subst(UPS_LICENSE:1:1) = '<' );
              http_comp('You must be registered with UPS! See +
                         comments in EXAMPLE14 member.');
              *inlr = *on;
              return;
         endif;

         exfmt TrackNo;
         if (ExitKey);
            *inlr = *on;
            return;
         endif;

         TrackingNo = %trim(scTrackNo);

       postData =
         '<?xml version="1.0"?>'                                      +
         '<AccessRequest xml:lang="en-US">'                           +
            '<AccessLicenseNumber>'                                   +
                UPS_LICENSE                                           +
            '</AccessLicenseNumber>'                                  +
            '<UserId>' + UPS_USERID + '</UserId>'                     +
            '<Password>' + UPS_PASSWD + '</Password>'                 +
         '</AccessRequest>'                                           +
         '<?xml version="1.0"?>'                                      +
         '<TrackRequest xml:lang="en-US">'                            +
            '<Request>'                                               +
               '<TransactionReference>'                               +
                  '<CustomerContext>'                                 +
                      'HTTPAPI EXAMPLE14'                             +
                  '</CustomerContext>'                                +
                  '<XpciVersion>1.0001</XpciVersion>'                 +
               '</TransactionReference>'                              +
               '<RequestAction>Track</RequestAction>'                 +
               '<RequestOption>activity</RequestOption>'              +
            '</Request>'                                              +
            '<TrackingNumber>' + TrackingNo + '</TrackingNumber>'     +
         '</TrackRequest>'                                            ;

       rc = http_url_post_xml('https://wwwcie.ups.com/ups.app/xml/Track'
                             : %addr(postData) + 2
                             : %len(postData)
                             : %paddr(StartOfElement)
                             : %paddr(EndOfElement)
                             : *NULL );
       if (rc <> 1);
          scmsg = http_error();
          // FIXME: REPORT ERROR TO USER
          *inlr = *on;
          return;
       endif;

       clear_sfl = *on;
       write SFLCTL;
       clear_sfl = *off;
       empty_sfl = *on;

       for RRN = 1 to act;
           monitor;
             tempDate = %date(activity.date(RRN): *ISO0);
             scDate = %char(tempDate: *USA);
           on-error;
             scDate = *blanks;
           endmon;

           monitor;
             tempTime = %time(activity.time(RRN): *HMS0);
             scTime = %char(tempTime: *HMS);
           on-error;
             scTime = *blanks;
           endmon;

           scDesc = activity.desc(RRN);
           scCity = activity.city(RRN);
           scState = activity.state(RRN);
           scStatus = activity.status(RRN);

           if (scSignedBy = *blanks);
              scSignedBy = activity.SignedBy(RRN);
           endif;

           write SFLREC;
           empty_sfl = *off;
       endfor;

       exfmt SFLCTL;
       *inlr = *on;

      /end-free


     P StartOfElement  B
     D StartOfElement  PI
     D   UserData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      /free

        if path = '/TrackResponse/Shipment/Package' and name='Activity';
           act = act + 1;
        endif;

      /end-free
     P                 E


     P EndOfElement    B
     D EndOfElement    PI
     D   UserData                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      /free

       select;
       when  path = '/TrackResponse/Shipment/Package/Activity';

           select;
           when name = 'Date';
             activity.Date(act) = value;
           when name = 'Time';
             activity.Time(act) = value;
           endsl;

       when  path = '/TrackResponse/Shipment/Package/Activity' +
                    '/ActivityLocation';

           select;
           when name = 'Description';
             activity.Desc(act) = value;
           when name = 'SignedForByName';
             activity.SignedBy(act) = value;
           endsl;

       when  path = '/TrackResponse/Shipment/Package/Activity' +
                    '/ActivityLocation/Address';

           select;
           when name = 'City';
             activity.City(act) = value;
           when name = 'StateProvinceCode';
             activity.State(act) = value;
           endsl;

       when  path = '/TrackResponse/Shipment/Package/Activity' +
                    '/Status/StatusType';

           if   name = 'Description';
               activity.Status(act) = value;
           endif;

       endsl;

      /end-free
     P                 E
      *
      * EXAMPLE15:
      * ----------
      *  This program does the same thing as EXAMPLE4, but uses the
      *  older, pointer-based http_url_post() routine. There are some
      *  advantages to this approach:
      *
      *   - Pointers allow up to 16mb of data to be stored/returned
      *   - the WEBFORM_xxx APIs allow you to encode an entire form
      *       all at once.
      *   - This works on older releases of IBM i (prior to v6r1)
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      *
      * When form data is sent to a web browser, it often has to be
      * 'encoded'. HTTPAPI contains some routines called 'WEBFORM'
      * routines to help you with that encoding.
      *
      * This demonstrates using HTTPAPI's WEBFORM functions
      * to submit a web form.
      *
      * Note that this program performs the same function that your
      * web browser would if you pointed it to:
      *     http://www.scottklement.com/comment/

      /define WEBFORMS
     D/copy httpapi_h

     D cmd             pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D CRLF            C                   CONST(x'0D25')
     D rc              s             10I 0
     D msg             s             52A

     D Form            s                   like(WEBFORM)
     D fromAddr        s            100A   varying
     D Subject         s            100A   varying
     D Message         s           1000A   varying
     D myPointer       s               *
     D dataSize        s             10I 0

      /free

        //
        // CHANGE THIS TO YOUR E-MAIL ADDRESS:
        //
        FromAddr = 'example4@scottklement.com';

        //
        // CHANGE THIS TO THE SUBJECT YOU'D LIKE SENT TO ME:
        //
        Subject = 'EXAMPLE4 from HTTPAPI.';

        //
        // CHANGE THIS TO THE MESSAGE YOU'D LIKE SENT TO ME:
        //
        Message = 'Hi Scott!' + CRLF +
                  '  Just a note to tell you that I''m testing out the +
                  EXAMPLE15 program in HTTPAPI. If you receive this, it +
                  must work!' + CRLF;


        //
        // When a program emulates a form on an HTML page, it's called
        // a 'webform' in HTTPAPI.  You must first open a new web
        // form, and then set variables in it:
        //
        Form = WEBFORM_open();

        WEBFORM_SetVar(Form: 'from': fromAddr );
        WEBFORM_SetVar(Form: 'subject': subject);
        WEBFORM_SetVar(Form: 'Comment': message);

        //
        // The WEBFORM_postData() routine retrieves data suitable for
        // the http_url_post() API.  (there's also a WEBFORM_getData()
        // if you need to call HTTP_url_get).
        //
        WEBFORM_postData( Form : myPointer: dataSize );

        //
        //  The http_url_post() function does an HTTP POST operation
        //  sending any data at the pointer you specify.
        //
        //  The results, in this case, are saved to the IFS in a file
        //  called '/tmp/testpost.html'
        //
        rc = http_url_post( 'http://www.scottklement.com/cgi-bin/' +
                            'email_comment.cgi'
                          : myPointer
                          : dataSize
                          : '/tmp/testpost.html'
                          : HTTP_TIMEOUT
                          : HTTP_USERAGENT
                          : 'application/x-www-form-urlencoded' );

        //
        // This particular web page doesn't give a direct response
        // but instead asks you to visit another page.  This is done
        // by sending back a 302 ("Page Moved") response.  You can
        // call the http_redir_loc() routine in HTTPAPI to get the
        // URL that the redirection points to, and then the http_url_get()
        // routine to ask HTTPAPI to retrieve that page.
        //

        if rc=302;
           rc = http_url_get( http_redir_loc
                            : '/tmp/testpost.html');
        endif;

        //
        // If there's an error, use the DSPLY opcode to show it on the
        // screen.   If not, use the DSPF command from OS/400 to display
        // the data that was returned onto the screen.
        //
        if rc <> 1;
           msg = http_error();
           dsply msg;
        else;
           cmd('DSPF ''/tmp/testpost.html''': 200);
        endif;

        //
        // When done, make sure you call this function to free up
        // the memory that the web form used
        //
        WEBFORM_close(Form);

        *inlr = *on;
      /end-free
      *  This is an example of calling a SOAP Web service w/HTTPAPI.
      *
      *  This sample calls the Currency Exchange Rate Web service
      *  provided by www.RestFulWebServices.net
      *
      *  To Compile
      *     CRTBNDRPG PGM(EXAMPLE16)
      *
      *  To Run:
      *     CALL EXAMPLE16 PARM('USD' 'JPY' 12.00)
      *
      *  (This shows the value of USD 12.00 in Japanese currency.)
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

     D EXAMPLE16       PR                  ExtPgm('EXAMPLE16')
     D   Country1                     3A   const
     D   Country2                     3A   const
     D   parmAmount                  15P 5 const
     D EXAMPLE16       PI
     D   Country1                     3A   const
     D   Country2                     3A   const
     D   parmAmount                  15P 5 const

      /copy httpapi_h

     D URL             s            100a   varying
     D SOAP            s           1000A   varying
     D response        s           1000a   varying
     D Amount          s             12p 2
     D rate            s              9p 4
     D Result          s             12P 2

      /free

       if %parms < 3;
          http_comp( 'Please pass parms. e.g. CALL EXAMPLE16 '
                   + 'PARM(USD JPY 12.00)');
          return;
       endif;

       Amount = parmAmount;

       http_debug(*ON);

       URL = 'http://www.restfulwebservices.net/wcf/CurrencyService.svc';

       http_setOption('SoapAction': '"GetConversionRate"');

       SOAP =
       '<soapenv:Envelope +
            xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
            xmlns:ns="http://www.restfulwebservices.net/+
               ServiceContracts/2008/01">+
           <soapenv:Header/>+
           <soapenv:Body>+
              <ns:GetConversionRate>+
                 <ns:FromCurrency>'+%trim(Country1)+'</ns:FromCurrency>+
                 <ns:ToCurrency>'+%trim(Country2)+'</ns:ToCurrency>+
              </ns:GetConversionRate>+
           </soapenv:Body>+
        </soapenv:Envelope>';

       response = http_string( 'POST': URL: SOAP: 'text/xml');

       xml-into rate %xml(response: 'case=any ns=remove +
           path=Envelope/Body/GetConversionRateResponse+
                /GetConversionRateResult/Rate');

       Result = Amount * Rate;
       http_comp( %trim(Country1) + ' ' + %char(Amount)
                + ' = '
                + %trim(Country2) + ' ' + %char(Result));

       *inlr = *on;

      /end-free

      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')
      *
      *  Example of calling WebserviceX.net's ABA Bank Routing
      *  web service to display details about a bank routing number.
      *
      *  For example:
      *    CALL EXAMPLE17 PARM('021200025')
      *
      *  Note:  This web service wraps an entire XML document
      *         inside the "payload" of it's SOAP message.
      *         So this program parses XML twice.  First it
      *         parses the SOAP message to get the payload,
      *         then it parses the payload to get the data.
      *
      *  Note: If DEBUGGING is defined (below) you'll see what
      *         the XML response looks like at each step of the
      *         process.
      *

      // change the following to "/undefine" if you don't
      // want to see debugging messages
      /define DEBUGGING

     D EXAMPLE17       PR                  ExtPgm('EXAMPLE17')
     D   RoutNo                      32A   const
     D EXAMPLE17       PI
     D   RoutNo                      32A   const

      /copy httpapi_h
      /copy ifsio_h

     D QCMDEXC         PR                  ExtPgm('QCMDEXC')
     D   command                  32702a   const options(*varsize)
     D   len                         15p 5 const
     D   igc                          3a   const options(*nopass)

     D SaveEmbed       PR
     D   embfile                     50a   varying
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    32767A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D bank_t          ds                  qualified
     D                                     based(Template)
     D   rtgno                       20a   varying
     D   name                        30a   varying
     D   addr                        30a   varying
     D   city                        20a   varying
     D   state                        2a   varying
     D   zip                         10a   varying
     D   phone                       15a   varying

     D embedded        PR
     D   bank                              likeds(bank_t)
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    32767A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D SOAP            s           2000A   varying
     D rc              s             10I 0
     D fd              s             10I 0
     D soapfile        s             50a   varying
     D embfile         s             50a   varying
     D cmd             s            200A
     D bank            ds                  likeds(bank_t)
     D wait            s              1A

      /free
      /if defined(DEBUGGING)
        http_debug(*ON);
      /endif
        *inlr = *on;

        if (%parms < 1);
           http_comp('You must pass an ABA Routing number!');
           return;
        endif;

        // ----------------------------------------------
        //  Create SOAP document to tell server
        //    - to call the getABADetailsByRoutingNumber routine
        //    - pass a parameter with the routing number.
        // ----------------------------------------------

        SOAP=
         '<?xml version="1.0" encoding="iso-8859-1" standalone="no"?> +
          <SOAP-ENV:Envelope +
               xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"> +
          <SOAP-ENV:Body> +
             <GetABADetailsByRoutingNumber +
                      xmlns="http://www.webserviceX.NET"> +
                <RoutingNumber>' + RoutNo + '</RoutingNumber> +
             </GetABADetailsByRoutingNumber> +
          </SOAP-ENV:Body> +
          </SOAP-ENV:Envelope>';

        // ----------------------------------------------
        //  Send request to server, and get response
        // ----------------------------------------------

          soapfile = http_tempfile();

          rc = http_url_post( 'http://www.webservicex.net/aba.asmx'
                            : %addr(SOAP)+2
                            : %len(SOAP)
                            : soapfile
                            : HTTP_TIMEOUT
                            : HTTP_USERAGENT
                            : 'text/xml'
                            : 'http://www.webserviceX.NET/+
                               GetABADetailsByRoutingNumber');

          if (rc <> 1);
             unlink(soapfile);
             http_crash();
          endif;

        // ----------------------------------------------
        //   The response from the server will be in
        //   the IFS in a file with a unique name.
        //   that IFS filename is in the "tempfile"
        //   variable at this point.
        //
        //   For debugging purposes, display the
        //   contents of that file, now.
        // ----------------------------------------------
      /if defined(DEBUGGING)
          dsply ('Press <ENTER> to see SOAP response') ' ' wait;
          cmd = 'DSPF STMF(''' + soapfile + ''')';
          QCMDEXC(cmd: %len(cmd));
      /endif


        // ----------------------------------------------
        //  Parse the SOAP document (the one in soapfile)
        //  Inside it will be another XML document that's
        //  embedded within -- save that to a separate
        //  file in the IFS.
        // ----------------------------------------------

          embfile = http_tempfile();

          if (http_parse_xml_stmf( soapfile
                                 : HTTP_XML_CALC
                                 : *null
                                 : %paddr(SaveEmbed)
                                 : %addr(embfile) ) < 0);
              callp close(fd);
              unlink(soapfile);
              unlink(embfile);
              http_crash();
          endif;

          unlink(soapfile);


        // ----------------------------------------------
        //   For the sake of debugging, display the
        //   contents of the embedded XML document
        //   (Remove from production code)
        // ----------------------------------------------

      /if defined(DEBUGGING)
          dsply ('Press <ENTER> to see extracted XML') ' ' wait;
          cmd = 'DSPF STMF(''' + embfile + ''')';
          QCMDEXC(cmd: %len(cmd));
      /endif

        // ----------------------------------------------
        //    Parse the second XML document (the one
        //    that was embedded)
        // ----------------------------------------------
          bank = *allx'00';
          if (http_parse_xml_stmf( embfile
                                 : HTTP_XML_CALC
                                 : *null
                                 : %paddr(Embedded)
                                 : %addr(bank) ) < 0);
              unlink(embfile);
              http_crash();
          endif;

        // ----------------------------------------------
        //   For the sake of demonstration, use DSPLY
        //   to show the results on the screen (you
        //   wouldn't do this in a real program.)
        // ----------------------------------------------

          dsply ('--- Reply from Web Service ---');
          dsply ('name  = ' + bank.name);
          dsply ('phone = ' + bank.phone);
          dsply (' addr = ' + bank.addr);
          dsply ('        ' + bank.city  + ' '
                            + bank.state + ' '
                            + bank.zip );
          dsply ('--- Press ENTER to end ---') ' ' wait;

          return;

      /end-free



     P SaveEmbed       B
     D SaveEmbed       PI
     D   embfile                     50a   varying
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    32767A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D writeConst      PR            10I 0 ExtProc('write')
     D  fildes                       10i 0 value
     D  buf                       65535A   const options(*varsize)
     D  bytes                        10U 0 value

     D xmlhdr          s             80a   varying
     D fd              s             10i 0

      /free
           if (name <> 'GetABADetailsByRoutingNumberResult');
             return;
           endif;

           // ------------------------------------------
           //   create new stream file in IFS
           //   tag it with CCSID 1208 (UTF-8)
           // ------------------------------------------

           unlink(embfile);
           fd = open(embfile: O_CREAT+O_CCSID+O_WRONLY
                            : S_IRUSR + S_IWUSR: 819);
           callp close(fd);

           // ------------------------------------------
           //    Open stream file for appending data
           //    and write embedded XML document to it
           // ------------------------------------------

           fd = open(embfile: O_WRONLY+O_TEXTDATA);

           xmlhdr= '<?xml version="1.0" encoding="iso-8859-1"?>' + x'0d25';
           writeConst(fd: xmlhdr: %len(xmlhdr));
           writeConst(fd: value:  %len(value));

           callp close(fd);
      /end-free
     P                 E


     P embedded        B
     D embedded        PI
     D   bank                              likeds(bank_t)
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    32767A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

      /free
         select;
         when name = 'RoutingNumber';
            bank.rtgno = %trimr(value);
         when name = 'BankName';
            bank.name  = %trimr(value);
         when name = 'Address';
            bank.addr = %trimr(value);
         when name = 'City';
            bank.city = %trimr(value);
         when name = 'State';
            bank.state = %trimr(value);
         when name = 'ZipCode';
            bank.zip   = %trimr(value);
         when name = 'PhoneNumber';
            bank.phone = %trimr(value);
         endsl;
      /end-free
     P                 E
      *  This is a SOAP 1.2 example. This web service is very
      *  similar to the one in EXAMPLE16, except that a different
      *  version of SOAP is used.
      *
      *  EXAMPLE16 uses SOAP 1.1, which is older, but is still
      *  *MUCH* more popular than 1.2.  For some reason, version
      *  1.2 never became popular.
      *
      *  Notice the differences:
      *    - 1.2 uses a Content-Type of application/soap+xml
      *    - 1.2 adds an action= parameter to the content-type
      *           (this replaces the SoapAction parameter)
      *    - 1.2 uses a different namespace for the SOAP
      *            elements.
      *
      *  This sample calls the Currency Exchange Rate Web service
      *  provided by www.WebServiceX.net
      *
      *  To Compile (requires V5R1):
      *     CRTBNDRPG PGM(EXAMPLE18) SRCFILE(libhttp/QRPGLESRC)
      *
      *  To Run:
      *     CALL EXAMPLE18 PARM('USD' 'JPY' 12.00)
      *
      *  (This shows the value of USD 12.00 in Japanese currency.)
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI':'QC2LE')

     D EXAMPLE18       PR                  ExtPgm('EXAMPLE18')
     D   Country1                     3A   const
     D   Country2                     3A   const
     D   Amount                      15P 5 const
     D EXAMPLE18       PI
     D   Country1                     3A   const
     D   Country2                     3A   const
     D   Amount                      15P 5 const

      /copy httpapi_h

     D Incoming        PR
     D   rate                         8F
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D SOAP            s          32767A   varying
     D rc              s             10I 0
     D rate            s              8F
     D Result          s             12P 2

      /free

       if ( %parms < 3 );
          http_comp( 'Please pass parms. e.g. CALL EXAMPLE18 +
                      PARM(USD JPY 12.00)');
          return;
       endif;

       // Note:  http_debug(*ON/*OFF) can be used to turn debugging
       //        on and off.  When debugging is turned on, diagnostic
       //        info is written to an IFS file named
       //        /tmp/httpapi_debug.txt

       http_debug(*ON);

       // Note:  http_XmlStripCRLF(*ON/*OFF) controls whether or not
       //        the XML parser removes CR and LF characters from the
       //        Xml data that's passed to your 'Incoming' procedure.

       http_XmlStripCRLF(*ON);

       SOAP =
       '<?xml version="1.0" encoding="utf-8"?>+
        <soap:Envelope +
              xmlns:soap="http://www.w3.org/2003/05/soap-envelope" +
              xmlns:web="http://www.webserviceX.NET/">+
        <soap:Header/>+
        <soap:Body>+
          <web:ConversionRate>+
            <web:FromCurrency>'+ %trim(Country1) +'</web:FromCurrency>+
            <web:ToCurrency>'+ %trim(Country2) +'</web:ToCurrency>+
          </web:ConversionRate>+
       </soap:Body>+
       </soap:Envelope>';

       http_debug(*ON);

       rc = http_url_post_xml(
                         'http://www.webservicex.net/CurrencyConvertor.asmx'
                         : %addr(SOAP) + 2
                         : %len(SOAP)
                         : *NULL
                         : %paddr(Incoming)
                         : %addr(rate)
                         : HTTP_TIMEOUT
                         : *omit
                         : 'application/soap+xml; charset=UTF-8; +
                            action="http://www.webserviceX.NET/ConversionRate"'
                         );

       if (rc <> 1);
          http_crash();
       else;
          Result = %dech(Amount * rate: 12: 2);
          http_comp(%trim(Country1) + ' ' + %char(%dec(Amount:12:2))
                    + ' = ' + %trim(Country2) + ' '+ %char(Result));
       endif;

       *inlr = *on;

      /end-free

     P Incoming        B
     D Incoming        PI
     D   rate                         8F
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D atof            PR             8F   extproc('atof')
     D   string                        *   value options(*string)

      /free
          if (name = 'ConversionRateResult');
             rate = atof(value);
          endif;
      /end-free
     P                 E
      **  SOAP with attachments
      **
     c                   eval      *inlr = *on
      * THE STORY SO FAR:
      * -----------------
      *  EXAMPLE1 showed the basics of downloading a file with HTTP
      *
      * EXAMPLE2:
      * ----------
      *  This builds on EXAMPLE1, adding some bells and whistles.
      *  (ding-ding, toot-toot).  I will not re-explain what I put
      *  in EXAMPLE1 but instead will explain the following
      *  enhancements:
      *      - How to use the "user agent" parameter.
      *      - How to use the "time out" parameter.
      *      - How to display download progress
      *
      *  For more details, see the comments, below.
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D my_procedure    PR
     D   Received                    10u 0 value
     D   Total                       10u 0 value

     D agent           s             64a
     D rc              s             10I 0
     D URL             S            300A    varying
     D IFS             S            256A    varying
     D timeout         s             10i 0
     D msg             s             80a

     c                   callp     http_debug(*ON)


     c****               callp     http_setproxy( 'proxy.example.com'
     c****                                      : 8080 )
     C****               callp     http_proxy_setauth( HTTP_AUTH_BASIC
     C****                                           : 'userid'
     C****                                           : 'password' )

     c                   eval      URL = 'http://www.scottklement.com'
     c                                 + '/presentations/'
     c                                 + 'Web Services from RPG with '
     c                                 + 'HTTPAPI.pdf'
     c                   eval      IFS = '/tmp/Scott''s HTTPAPI '
     c                                 + 'presentation handout.pdf'


      * Some sites get upset if you're not running Internet Explorer
      * The "user agent" parameter specifies a string that tells the
      * site which "browser" we are.  With the following string, the
      * site will think we're IE 8 running on Windows :)
      *
     c                   eval      agent = 'Mozilla/4.0 (compatible; +
     c                                      MSIE 8.0; +
     c                                      Windows NT 5.1; +
     c                                      Trident/4.0)'

      *
      * The default user agent for HTTPAPI is 'http-api/x.xx' (where
      * (x.xx is the version number).  A named constant, HTTP_USERAGENT
      * will always contain the default user agent
      *

      * Likewise, you can control timeouts.  If the network stops
      * responding, how long should HTTPAPI wait before it gives
      * up?  The default value is 60 seconds and is defined by
      * the constant HTTP_TIMEOUT -- but you can override this
      * if you like and specify your own...
      *
     c                   eval      Timeout = 30


      * Some of HTTPAPI's functions are implemented through "exit
      * procedures" (callback routines).  In this example, I want
      * to display the progress of downloading the PDF document.
      *
      * An exit procedure is a routine that *you* write, but HTTPAPI
      * calls when a certain "thing" happens.  In this case, each
      * time more bytes are received over the wire, I want HTTPAPI
      * to give me an updated byte count... that way I can tell the
      * user how much I've downloaded.
      *
      * To do that, I ask RPG where my subprocedure is stored in memory
      * using the %paddr() built-in function. Then, I tell HTTPAPI
      * the location in memory, so it can call it.
      *
     c                   callp     http_xproc( HTTP_POINT_DOWNLOAD_STATUS
     c                                       : %paddr(my_procedure) )


      *  okay... lets do this thing!
      *
     c                   callp     http_setOption('user-agent': agent)
     c                   callp     http_setOption('timeout': %char(timeout))


      *  http_stmf() will send an error message if something goes wrong
      *      so we can MONITOR for that, like any other error.
      *  http_error() can retrieve the error message into a variable

     c                   monitor
     c                   callp     http_stmf('GET': URL: IFS)
     c                   on-error
     c                   eval      msg = http_error()
     c                   endmon

      *
      * HTTPAPI provides a routine named http_comp() that displays
      * a completion message (like SNDPGMMSG MSGTYPE(*COMP) in CL)
      * this is an easy way to show what happened:
      *
     c                   if        msg = *blanks
     c                   callp     http_comp('Success!')
     c                   else
     c                   callp     http_comp(msg)
     c                   endif

     c                   eval      *inlr = *on


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * my_procedure():  Called by HTTPAPI to display the
      *                  download status.
      *
      * NOTE: HTTPAPI has to stop receiving to call this
      *       routine. So make it run fast, so it doesn't
      *       slow down the transfer!
      *
      * NOTE: The QMHSNDPM API is an IBM-supplied routine to
      *       send a program message (similar to CL SNDPGMMSG
      *       command)
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P my_procedure    B
     D my_procedure    PI
     D   Received                    10u 0 value
     D   Total                       10u 0 value

     D QMHSNDPM        PR                  ExtPgm('QMHSNDPM')
     D   MessageID                    7A   Const
     D   QualMsgF                    20A   Const
     D   MsgData                    256A   Const
     D   MsgDtaLen                   10I 0 Const
     D   MsgType                     10A   Const
     D   CallStkEnt                  10A   Const
     D   CallStkCnt                  10I 0 Const
     D   MessageKey                   4A
     D   ErrorCode                    8a   const

     D Msg             s             52a
     D Pct             s              3s 1
     D Key             s              4a

     c                   eval      Pct = (Received*100) / Total

     c                   eval      msg = 'Received '
     C                                 + %trim(%editc(Received:'P'))
     C                                 + ' of '
     C                                 + %trim(%editc(Total:'P'))
     C                                 + ' (' +%trim(%editc(Pct:'P'))+ '%)'

     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : msg
     c                                     : %size(msg)
     c                                     : '*STATUS'
     c                                     : '*EXT'
     c                                     : 0
     c                                     : Key
     c                                     : x'00000000' )
     P                 E
      ** XML-RPC example
     c                   eval      *inlr = *on
      * Demonstrate http_XmlReturnPtr(*ON)
      * maybe a web service that downloads an XML document containing
      * a video, and the video is larger than 64k?
     c                   eval      *inlr = *on
      ** Scraping an HTML document?
     c                   eval      *inlr = *on
      * EXAMPLE23:  This example demonstrates how to extend the
      *             validity checking of an x.509 certificate.
      *             (sometimes called an "SSL certificate" or "TLS
      *              certificate.")
      *
      *  This demonstrates two ways of adding checking:
      *
      *       https_strict(): tells HTTPAPI to enable/disable
      *                       strict checking of a certificate.
      *
      *       HTTP_POINT_CERT_VAL; is an exit point that provides
      *                        a way to write your own code to
      *                        validate certificate fields.
      *
      *  Note: Although the two techniques are used together in
      *        this sample program, they are only loosely related
      *        to one another.  They can be used independently as
      *        needed.
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h
      /copy ifsio_h
      /copy gskssl_h

     D QCMDEXC         PR                  ExtPgm('QCMDEXC')
     D   cmd                      32702a   const options(*varsize)
     D   len                         15p 5 const
     D   igc                          3a   const options(*nopass)

     D cert_val        pr            10i 0
     D   usrdta                        *   value
     D   id                          10i 0 value
     D   data                     32767a   varying const
     D   errmsg                      80a

     D LO              c                   const('abcdefghij-
     D                                     klmnopqrstuvwxyz')
     D HI              c                   const('ABCDEFGHIJ-
     D                                     KLMNOPQRSTUVWXYZ')

     D filename        s             50a   varying
     D rc              s             10i 0
     D cmd             s            200a   varying
     D url             s           1000a   varying

     D service         s             32a
     D userid          s             32a
     D pass            s             32a
     D host            s            256a
     D port            s             10i 0
     D path            s          32767a   varying

     c                   callp     http_debug(*ON)


      **************************************************************
      * By default, HTTPAPI instructs i5/OS to ignore any SSL
      *    errors related to untrusted root certs, or expired
      *    certificates, as long as they contain enough information
      *    to enable encryption.
      *
      * The https_strict() API can turn "strict checking" on or off.
      *
      * When on, i5/OS will only allow root certificates that are
      * registered as "trusted" in the DCM.  It will also only
      * allow certificates that are not expired.
      **************************************************************
     c                   callp     https_strict(*ON)

      **************************************************************
      * In addition, we'd like to verify that the "common name" in
      * the server's SSL certificate matches the host name that
      * was supplied in the URL.
      *
      * In the following example, the URL points to a host named
      * "www.klements.com".  The HTTP_long_ParseURL() API will be
      * used to extract this hostname from the rest of the URL.
      *
      * The XLATE op-code is used to convert the hostname to
      * uppercase so we don't have to worry about case sensitivity
      * (e.g., it doesn't matter if the URL says "www.klements.com"
      *  but the certificate says "WwW.kLeMenTs.CoM" because both
      *  are converted to all uppercase.)
      **************************************************************
     c                   eval      url = 'https://www.klements.com/+
     c                                    cgi-bin/ssltest'

     c                   callp     http_long_parseURL( url
     c                                               : service
     c                                               : userid
     c                                               : pass
     c                                               : host
     c                                               : port
     c                                               : path )

     C     LO:HI         xlate     host          host

      **************************************************************
      * http_xproc() registers an "exit procedure"... that is a
      *              procedure that HTTPAPI calls during it's
      *              processing.
      *
      *              In this case, our "cert_val" procedure should
      *              be called at the point where HTTPAPI is
      *              validating a certificate.
      *
      *              We'll use the cert_val() subprocedure to
      *              verify that the common name of the certificate
      *              matches the host in the URL
      **************************************************************
     c                   callp     http_xproc( HTTP_POINT_CERT_VAL
     c                                       : %paddr(cert_val) )

      **************************************************************
      *  Request that something be downloaded from the SSL server.
      *
      *  Note: the xproc above will work with all of the
      *        APIs that access a URL (both post & get)
      *        I used get in this sample program just to provide
      *        a simple example -- if you need to use it with
      *        something more complex like http_url_post_xml(),
      *        feel free -- it will work the same way.
      **************************************************************
     c                   eval      filename = http_tempfile + '.txt'

     C                   eval      rc = http_url_get( url: filename)
     c                   if        rc <> 1
     c                   callp     http_crash
     c                   endif

      **************************************************************
      * Display the file downloaded from the HTTP server.
      * then delete it & end program.
      **************************************************************
     c                   eval      cmd = 'DSPF STMF(''' + filename + ''')'
     c                   callp(e)  QCMDEXC(cmd: %len(cmd))

     c                   callp     unlink(filename)
     c                   eval      *inlr = *on


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cert_val():  This procedure was registered (via http_xproc)
      *              so that HTTPAPI will call it when it's time to
      *              validate a certificate.
      *
      *              HTTPAPI will call this procedure in a loop for
      *              every field in the x.509 partner certificate.
      *
      *      usrdta = (input) this lets you pass your own data
      *                       to/from the certificate validation
      *                       routine.  This can be anything...
      *
      *          id = (input) certificate field identifier.
      *                       this corresponds to a CERT_xxx constant
      *                       in the GSKSSL_H copybook. l
      *
      *        data = (input) data contained in the certificate field
      *
      *      errmsg = (output) error message to report if the certificate
      *                        data is not accepted by this procedure.
      *
      *  This procedure should return 0 if the certificate field is
      *  acceptable, or -1 if it is not.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cert_val        B
     D cert_val        pi            10i 0
     D   usrdta                        *   value
     D   id                          10i 0 value
     D   data                     32767a   varying const
     D   errmsg                      80a

     D cn              s            256a

      * In this example, we want to make sure the common name of
      *  the certificate matches the hostname in the URL.
      *
      * So if the id is set to CERT_COMMON_NAME, we make sure
      * they match.
      *
      * for any other certificate field, 0 is returned to indicate
      * that the value is okay -- this way, we can ignore all of
      * the other fields in the certificate.
      *
     c                   if        id = CERT_COMMON_NAME
     c                   eval      cn = %xlate(LO:HI:data)
     c                   if        cn <> host
     c                   eval      errmsg = 'Certificate is for a +
     c                                      different web site!'
     c                   return    -1
     c                   endif
     c                   endif

     c                   return    0
     P                 E
      * EXAMPLE24:  This example demonstrates how to extend the
      *             validity checking of an x.509 certificate.
      *             using the GSKit callback feature (req V5R3+)
      *
      *  Note: This isn't for the feint-of-heart.  For most
      *        the code in EXAMPLE23 will work fine, and be much
      *        easier to implement.
      *
      *        However, this method has the advantage that you can
      *        view the entire certificate chain, including the
      *        CA certificates.
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

     FQSYSPRT   O    F  132        PRINTER

      /copy httpapi_h
      /copy ifsio_h
      /copy gskssl_h

     D QCMDEXC         PR                  ExtPgm('QCMDEXC')
     D   cmd                      32702a   const options(*varsize)
     D   len                         15p 5 const
     D   igc                          3a   const options(*nopass)

     D cert_val        pr            10i 0
     D   cert_chain                    *   value
     D   status                      10i 0 value

     D LO              c                   const('abcdefghij-
     D                                     klmnopqrstuvwxyz')
     D HI              c                   const('ABCDEFGHIJ-
     D                                     KLMNOPQRSTUVWXYZ')

     D Fields          s             33a   dim(19) ctdata

     D filename        s             50a   varying
     D rc              s             10i 0
     D cmd             s            200a   varying
     D url             s           1000a   varying
     D VerifyCert      ds                  likeds(CertCallback_t)

      /free

        http_debug(*ON);
        https_strict(*OFF);

        VerifyCert.vc_proc     = %paddr(cert_val);
        VerifyCert.vc_valreq   = GSK_NO_VALIDATION;
        VerifyCert.vc_certneed = GSK_CERTIFICATE_CHAIN_SENT_VIA_SSL;

        http_xproc( HTTP_POINT_GSKIT_CERT_VAL
                  : *null
                  : %addr(VerifyCert) );

        //**********************************************************
        // Request that something be downloaded from the SSL server.
        //**********************************************************

        filename = http_tempfile + '.txt';
        url = 'https://www.klements.com/cgi-bin/ssltest';

        rc = http_url_get( url: filename );
        if (rc <> 1);
           http_crash();
        endif;

        //**********************************************************
        // Display the file downloaded from the HTTP server.
        // then delete it & end program.
        //**********************************************************
        cmd = 'DSPF STMF(''' + filename + ''')';
        QCMDEXC(cmd: %len(cmd));
        unlink(filename);
        *inlr = *on;

      /end-free


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cert_val():  This procedure was registered with the GSKit
      *              (IBM-supplied SSL routines in i5/OS) for
      *              certificate validation.
      *
      *              IBM documents this callback in the Information
      *              Center.  Here's a link to the V5R4 docs:
      *                http://publib.boulder.ibm.com/infocenter/iseries
      *                  /v5r4/topic/apis/gsk_attribute_set_callback.htm
      *
      *              In this example, the certificates are extracted,
      *              and parsed using the QsyParseCertificate() API.
      *                http://publib.boulder.ibm.com/infocenter/iseries
      *                  /v5r4/topic/apis/QSYPARSC.htm
      *
      *  cert_chain = (input) ASN.1 DER encoded certificate chain
      *                       in raw, binary format.
      *
      *      status = (input) The result of the GSKit validation
      *                       routine.  It can be set to one of the
      *                       following constants from the GSKSSL_H
      *                       copy book:
      *
      *           GSK_VALIDATION_SUCCESSFUL
      *           GSK_IBMI_ERROR_NOT_TRUSTED_ROOT
      *           GSK_KEYFILE_CERT_EXPIRED
      *
      *  This procedure should return GSK_OK if cert is acceptable
      *  or GSK_ERROR_CERT_VALIDATION if unacceptable
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cert_val        B
     D cert_val        pi            10i 0
     D   cert_chain                    *   value
     D   status                      10i 0 value

     D DER_SEQUENCE    C                   x'30'
     D DER_LONGFORM    C                   x'80'
     D DER_BIN_X509    c                   1

     D QsyParseCertificate...
     D                 PR                  extproc('QsyParseCertificate')
     D  certificate                    *   value
     D  type                         10i 0 value
     D  length                       10i 0 value
     D  format                         *   value options(*string)
     D  rcvvar                    65535a   options(*varsize)
     D  rcvvarlen                    10i 0 value
     D  ErrorCode                 32767a   options(*varsize)

     D CERT0200        DS         65535    qualified
     D   len_rtn                     10i 0
     D   len_avail                   10i 0

     D ErrorCode       ds                  qualified
     D   bytes_prov                  10i 0 inz(0)
     D   bytes_avail                 10i 0 inz(0)

     D                 ds
     D  len                          10u 0
     D  bytes                         1a   dim(4) overlay(len)

     D data            s          65535a   based(p_data)
     D cn              s           1000a   varying
     D byte            s              1a   based(p_byte)
     D pos             s             10i 0
     D num_bytes       s              3u 0
     D cert            s               *
     D x               s             10i 0
     D certno          s             10i 0
     D offset          s             10i 0 based(p_offset)
     D dtalen          s             10i 0 based(p_dtalen)

     D printme         ds           132    qualified
     D   certno                       2a
     D   field                       25a
     D                                1a
     D   data                        94a

      /free

         pos    = 1;
         p_byte = cert_chain;
         certno = 0;

         dow byte = DER_SEQUENCE;

            cert = p_byte;

            // ------------------------------------------------
            //  follow DER rules to extract the length of the
            //  DER sequence object.  This outermost sequence
            //  object represents the whole certificate.
            // ------------------------------------------------
            pos += 1;
            p_byte += 1;

            if %bitand(byte:DER_LONGFORM) = x'00';
                len = 0;
                bytes(4) = byte;
                len += pos;
            else;
                len = 0;
                bytes(4) = %bitxor( byte: DER_LONGFORM );
                num_bytes = len;
                len = 0;

                if (num_bytes<1 or num_bytes>4);
                   // this shouldn't happen on a valid certificate...
                   // DER rules forbid num_bytes to be zero
                   // and no certificate should be > 4gb.
                   return GSK_ERROR_CERT_VALIDATION;
                endif;

                for x = num_bytes downto 1;
                   pos += 1;
                   p_byte += 1;
                   bytes(5 - x) = byte;
                endfor;

                len += pos;
            endif;

            // ------------------------------------------------
            //   At this point, cert should point to the start
            //   of a certificate, and len should represent
            //   the length of that certificate.
            // ------------------------------------------------

            certno += 1;
            QsyParseCertificate( cert
                               : DER_BIN_X509
                               : len
                               : 'CERT0200'
                               : CERT0200
                               : %size(CERT0200)
                               : ErrorCode );

            for x = 1 to %elem(fields);
                p_offset = %addr(CERT0200)
                         + %int(%subst(fields(x):26:4));
                p_dtalen = %addr(CERT0200)
                         + %int(%subst(fields(x):30:4));
                if (offset>0 and dtalen>0);
                    p_data = %addr(CERT0200) + offset;
                    printme.certno = %char(certno);
                    printme.field  = %subst(fields(x):1:25);
                    printme.data   = %subst(data:1:dtalen);
                    write QSYSPRT printme;
                endif;
            endfor;

            p_byte = cert + len;
         enddo;

         return GSK_OK;
      /end-free
     P                 E
**
Serial                     24  28
Issuer Common Name         32  36
Issuer Country/Region      40  44
Issuer State/Province      48  52
Issuer Locality            56  60
Issuer Organization        64  68
Issuer Org Unit            72  76
Issuer Postal Code         80  84
Issuer Valid From          88  92
Issuer Valid To            96 100
Subject Common Name       104 108
Subject Country/Region    112 116
Subject State/Province    120 124
Subject Locality          128 132
Subject Organization      136 140
Subject Org Unit          144 148
Subject Postal Code       152 156
Issuer E-mail             184 188
Subject E-mail            192 196
      * EXAMPLE25:
      * ----------
      * This example shows how to GET a web page that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The HTTP APIs used by the program are:
      *    http_url_get()
      *    http_getauth()
      *    http_setauth()
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example25       PR                  extpgm('EXAMPLE25')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D example25       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A    varying
     D IFS             S            256A    varying

     D isBasic         S              1N    inz(*Off)
     D isDigest        S              1N    inz(*Off)
     D Realm           S            124A    inz
     D isNtlm          S              1N    inz(*Off)
     D user            S                    like(i_user     ) inz('Donald')
     D password        S                    like(i_password ) inz('TheSecret')
     D debugLog        S             32A    varying inz
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = %trim(i_debugLog);
         else;
            debugLog = i_debugLog;
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example25.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL points to a place on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.

         URL = 'http://' + Job_getTcpIpAddr() + '/index.html';

         IFS = debugLog + 'httpapi_example25.html';

         // Now call HTTPAPI's "GET" routine.  Pass the above
         //  variables as parameters.  It'll download it to the IFS
         //
         rc = http_url_get(URL: IFS);

         if (rc <> 1);
            http_error(err);
            if (err = HTTP_NDAUTH);
               if (http_getauth(isBasic: isDigest: Realm: isNtlm) = 0);
                  select;
                  when (isNtlm);
                     http_setauth(HTTP_AUTH_NTLM: user: password);
                  when (isDigest);
                     http_setauth(HTTP_AUTH_MD5_DIGEST: user: password);
                  other;
                     http_setauth(HTTP_AUTH_BASIC: user: password);
                  endsl;
                  rc = http_url_get(URL: IFS);
               endif;

            endif;
         endif;

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
            dsply msg;
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E

      * EXAMPLE26:
      * ----------
      * This example shows how to GET a web page that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The program uses a persistent connection to download the
      * the web page twice.
      *
      * The HTTP APIs used by the program are:
      *    http_persist_open()
      *    http_persist_get()
      *    http_getauth()
      *    http_setauth()
      *    http_persist_close()
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example26       PR                  extpgm('EXAMPLE26')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D example26       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A   varying
     D IFS             S            256A   varying

     D isBasic         S              1N   inz(*Off)
     D isDigest        S              1N   inz(*Off)
     D Realm           S            124A   inz
     D isNtlm          S              1N   inz(*Off)
     D user            S                   like(i_user     ) inz('Donald')
     D password        S                   like(i_password ) inz('TheSecret')
     D debugLog        S             32A   varying inz

     D pComm           S               *   inz
     D fd              S             10I 0 inz
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      *
     D O_CREAT         C                   const( 8)                            | Append Mode
     D O_CCSID         C                   const(32)                            | CCSID
     D O_TRUNC         C                   const(64)                            | Truncate Fla
     D O_WRONLY        C                   const( 2)                            | Write Only
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = %trim(i_debugLog);
            debugLog = %trim(i_debugLog);
         else;
            debugLog = '/tmp/';
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example26.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL points to a place on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.

         URL = 'http://' + Job_getTcpIpAddr() + '/index.html';

         IFS = debugLog + 'httpapi_example26.html';

         // Open output file
         fd = open(IFS: O_WRONLY+O_TRUNC+O_CREAT+O_CCSID: 511: 819);

         // Open persistent connection
         pComm = http_persist_open(URL);

         // Now call HTTPAPI's "GET" routine.  Pass the above
         //  variables as parameters.  It'll download it to the IFS!
         //
         rc = http_persist_get(pComm: URL: fd: %paddr('write'));

         if (rc <> 1);
            http_error(err);
            if (err = HTTP_NDAUTH);
               if (http_getauth(isBasic: isDigest: Realm: isNtlm) = 0);

                  // Close connection because usually the
                  // server closes the connection when
                  // requesting NTLM authentication
                  http_persist_close(pComm);

                  // Open connection again and set credentials
                  pComm = http_persist_open(URL);

                  select;
                  when (isNtlm);
                     http_setauth(HTTP_AUTH_NTLM: user: password);
                  when (isDigest);
                     http_setauth(HTTP_AUTH_MD5_DIGEST: user: password);
                  other;
                     http_setauth(HTTP_AUTH_BASIC: user: password);
                  endsl;

                  dou '1';

                     // reopen output file
                     callp close(fd);
                     fd = open(IFS: O_WRONLY+O_TRUNC+O_CREAT+O_CCSID: 511: 819);

                     // get web page the first time
                     if ( http_persist_get(pComm:URL:fd:%paddr('write')) = -1);
                        leave;
                     endif;

                     // and get it a second time
                     if ( http_persist_get(pComm:URL:fd:%paddr('write')) = -1);
                        leave;
                     endif;

                  enddo;

               endif;

            endif;
         endif;

         // Close http connection
         http_persist_close(pComm);

         // Close output file
         callp close(fd);

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E

      * EXAMPLE27:
      * ----------
      * This example shows how to GET a web page that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The program uses a persistent connection to download the
      * the web page twice.
      *
      * Since the devolper knows that the web server requires NTLM
      * negotiation, he does not need to try to GET the web page in
      * order to figure out the authentication mechanism.
      * Instead, he directly calls http_setauth() to specify
      * the credentials for authentication.
      *
      * The HTTP APIs used by the program are:
      *    http_persist_open()
      *    http_setauth()
      *    http_persist_get()
      *    http_persist_close()
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example27       PR                  extpgm('EXAMPLE27')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D example27       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A   varying
     D IFS             S            256A   varying

     D Basic           S              1N   inz(*Off)
     D Digest          S              1N   inz(*Off)
     D Realm           S            124A   inz
     D Ntlm            S              1N   inz(*Off)
     D user            S                   like(i_user     ) inz('Donald')
     D password        S                   like(i_password ) inz('TheSecret')
     D debugLog        S             32A   varying inz

     D pComm           S               *   inz
     D fd              S             10I 0 inz
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      *
     D O_CREAT         C                   const( 8)                            | Append Mode
     D O_CCSID         C                   const(32)                            | CCSID
     D O_TRUNC         C                   const(64)                            | Truncate Fla
     D O_WRONLY        C                   const( 2)                            | Write Only
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = i_debugLog;
            debugLog = %trim(i_debugLog);
         else;
            debugLog = '/tmp/';
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example27.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL points to a place on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.

         URL = 'http://' + Job_getTcpIpAddr() + '/index.html';

         IFS = debugLog + 'httpapi_example27.html';

         // Open output file
         fd = open(IFS: O_WRONLY + O_TRUNC + O_CREAT + O_CCSID: 511: 819);

         // Open persistent connection
         pComm = http_persist_open(URL);

         // Set credentials
         http_setauth(HTTP_AUTH_NTLM: user: password);

         dou '1';

            // Now call HTTPAPI's "GET" routine.  Pass the above
            //  variables as parameters.  It'll download it to the IFS!
            //
            // get web page the first time
            if ( http_persist_get(pComm: URL: fd: %paddr('write')) = -1);
               leave;
            endif;

            // and get it a second time
            if ( http_persist_get(pComm: URL: fd: %paddr('write')) = -1);
               leave;
            endif;

            // Close http connection
            http_persist_close(pComm);

         enddo;

         // Close output file
         callp close(fd);

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E

      * THE STORY SO FAR:
      * -----------------
      *  EXAMPLE1 showed the basics of downloading a file with HTTP
      *  EXAMPLE2 showed how to use some of the more advanced
      *            parameters related to downloading a file.
      *
      * EXAMPLE3:
      * ----------
      *  HTTPAPI supports SSL (TLS) encryption, like a browser would.
      *  To do that, it uses the operating system's built-in
      *  support for SSL.
      *
      *   Note: The term "SSL" is actually outdated, but most people
      *         are familiar with it. Today's term is "TLS" which
      *         stands for Transport Layer Security. TLS is, really,
      *         the same thing as SSL -- it's just a newer revision
      *         of the protocol.  Think of TLS 1.0 as "SSL 4.0" --
      *         it's just a newer version of SSL, with a new name.
      *         Whenever I mention SSL in comments, you can assume
      *         that I mean "either SSL or TLS".
      *
      *  Since HTTPAPI uses the operating system's support for SSL
      *  you have to make sure the operating system has SSL support
      *  installed and configured.  There is a README member included
      *  in the QRPGLESRC file of HTTPAPI that explains that setup.
      *
      *  The comments & code below will explain:
      *    - How to associate your application with a profile in the
      *        Digital Certificate Manager (optional)
      *
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP('HTTPAPI')
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D cmd             pr                  extpgm('QCMDEXC')
     D   cmd                        200a   const
     D   len                         15p 5 const

     D rc              s             10i 0
     D app_id          s            100a

      /free

        http_debug(*on);

        //**************************************************************
        // BASIC USAGE:
        //   Assuming the operating system has SSL installed and
        //   configured the only requirement to use SSL with HTTPAPI is
        //   that your URL must start with https: instead of http:
        //**************************************************************

        http_stmf( 'GET'
                 : 'https://scottklement.com/ssl.php'
                 : '/tmp/httptest.html' );

        // Use the IBM-provided 'DSPF' command to display the output
        //  it should show that SSL works...

        cmd('DSPF ''/tmp/httptest.html''': 200);


        //***************************************************************
        // Also notice that these examples are now using free-format
        // calcs. HTTPAPI can be used from any of the formats supported
        // by your RPG compiler, fixed-format, free-format, or "all-free".
        //
        // Parameters defined as "const" in the HTTPAPI_H member can either
        // accept variables (as in EXAMPLE1 and 2) or they can receive
        // literals, as I coded, above.
        //*****************************************************************


        //*****************************************************************
        // ADVANCED USAGE:
        //   You can optionally associate HTTPAPI with a profile in the
        //   digital certificate manager.  This is useful when you want
        //   to do something more advanced, such as:
        //      - Use client-side certificates
        //      - Control which SSL certificates you trust separately
        //         for one application vs. another.
        //
        //   To configure a profile in the Digital Certificate Manager,
        //   you should:
        //      - Start the DCM if it's not already running
        //          STRTCPSVR *HTTP HTTPSVR(*ADMIN)
        //      - Using the browser on your PC, go to
        //          http://your.system.example:2001
        //      - Sign-in
        //      - Click Digital Certificate Manager
        //      - Click "Select a Certificate Store".
        //      - Select the *SYSTEM store, and then enter it's password
        //      - On the left, click "Manage Applications"
        //      - then click "Add Application"
        //      - make sure you add a "Client Application"
        //      - The application ID should start with your company
        //         name, then an underscore, then your application name,
        //         and finally the particular component of your application
        //         for example:
        //            ACMEINC_HTTPAPI_EXAMPLE3
        //         Remember this value, because you'll have to tell HTTPAPI
        //         this string.  This is how HTTPAPI knows which profile
        //         to use.
        //      - The "Application description" field should describe your
        //         application.
        //      - The other fields can stay at their default values unless
        //         you have a particular need to customize your application
        //         settings (such as defining a trust list)
        //      - Once you've added your application, you can use "update
        //         certificate assignment" to add a client-side certificate
        //         if desired.
        //
        //   Now that you have your profile in the Digital Certificate
        //   manager, you need to tell HTTPAPI the application-id.  This
        //   is how HTTPAPI knows to use your advanced settings.
        //   This is done with the https_init() API call
        //
        //   After you've done that, future SSL connections will use
        //   the DCM profile
        //*****************************************************************

        app_id = 'ACMEINC_HTTPAPI_EXAMPLE3';
        rc = https_init(app_id);
        if rc = -1;
           http_comp(http_error());
           https_cleanup();
           return;
        endif;

        http_stmf( 'GET'
                 : 'https://scottklement.com/ssl.php'
                 : '/tmp/httptest.html' );

        cmd('DSPF ''/tmp/httptest.html''': 200);


        //*****************************************************************
        // By default, HTTPAPI will remember the DCM settings that you
        // configure until one of three things happens:
        //    - you call https_init() again with new settings.
        //    - you call https_cleanup() to tell HTTPAPI to forget its
        //       settings.
        //    - the activation group ends.
        //
        //  Therefore, the following is completely optional, since it'll
        //  be cleaned up with the activation group ends, anyway...
        //
        // However, if your program will use the same DCM profile each
        // time, and will be called repeatedly, omitting the https_cleanup
        // will improve performance.
        //*****************************************************************

        https_cleanup();
        *inlr = *on;

      /end-free
      * EXAMPLE35:
      * ----------
      * This example shows how to call a web service that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The HTTP APIs used by the program are:
      *    http_getauth()
      *    http_setauth()
      *    http_url_post()
      *    http_error()
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example35       PR                  extpgm('EXAMPLE35')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D example35       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A    varying
     D IFS             S            256A    varying

     D isBasic         S              1N    inz(*Off)
     D isDigest        S              1N    inz(*Off)
     D Realm           S            124A    inz
     D isNtlm          S              1N    inz(*Off)
     D user            S                    like(i_user     ) inz('Donald')
     D password        S                    like(i_password ) inz('TheSecret')
     D debugLog        S             32A    varying inz

     D pComm           S               *   inz
     D postData        S            512A   inz varying
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = %trim(i_debugLog);
         else;
            debugLog = '/tmp/';
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example35.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL points to a web service on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.

         URL = 'http://' + Job_getTcpIpAddr() + '/HelloWorld.asmx';

         IFS = debugLog + 'httpapi_example35.xml';

         postData =
            '<soapenv:Envelope +
                xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
                xmlns:tem="http://tempuri.org/">+
                <soapenv:Header/>+
                <soapenv:Body>+
                   <tem:HelloWorld/>+
                </soapenv:Body>+
             </soapenv:Envelope>';

         rc = http_url_post(URL:%addr(postData)+2:%len(postData):IFS);

         if (rc <> 1);
            http_error(err);
            if (err = HTTP_NDAUTH);
               if (http_getauth(isBasic: isDigest: Realm: isNtlm) = 0);

                  select;
                  when (isNtlm);
                     http_setauth(HTTP_AUTH_NTLM: user: password);
                  when (isDigest);
                     http_setauth(HTTP_AUTH_MD5_DIGEST: user: password);
                  other;
                     http_setauth(HTTP_AUTH_BASIC: user: password);
                  endsl;

                  rc = http_url_post(URL:%addr(postData)+2:%len(postData):IFS);
               endif;

            endif;
         endif;

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E

      * EXAMPLE37:
      * ----------
      * This example shows how to call a web service that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The program uses a persistent connection to call the web
      * service twice.
      *
      * Since the devolper knows that the web server requires NTLM
      * negotiation, he does not need to try to GET the web page in
      * order to figure out the authentication mechanism.
      * Instead, he directly calls http_setauth() to specify
      * the credentials for authentication.
      *
      * The HTTP APIs used by the program are:
      *    http_persist_open()
      *    http_setauth()
      *    http_persist_post()
      *    http_persist_close()
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example37       PR                  extpgm('EXAMPLE37')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D example37       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A   varying
     D IFS             S            256A   varying

     D Basic           S              1N   inz(*Off)
     D Digest          S              1N   inz(*Off)
     D Realm           S            124A   inz
     D Ntlm            S              1N   inz(*Off)
     D user            S                   like(i_user     ) inz('Donald')
     D password        S                   like(i_password ) inz('TheSecret')
     D debugLog        S             32A   varying inz

     D pComm           S               *   inz
     D fd              S             10I 0 inz
     D postData        S            512A   inz varying
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      *
     D O_CREAT         C                   const( 8)                            | Append Mode
     D O_CCSID         C                   const(32)                            | CCSID
     D O_TRUNC         C                   const(64)                            | Truncate Fla
     D O_WRONLY        C                   const( 2)                            | Write Only
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = %trim(i_debugLog);
         else;
            debugLog = '/tmp/';
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example37.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL points to a web service on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.

         URL = 'http://' + Job_getTcpIpAddr() + '/HelloWorld.asmx';

         IFS = debugLog + 'httpapi_example37.xml';

         // Open output file
         fd = open(IFS: O_WRONLY + O_TRUNC + O_CREAT + O_CCSID: 511: 819);

         postData =
            '<soapenv:Envelope +
                xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
                xmlns:tem="http://tempuri.org/">+
                <soapenv:Header/>+
                <soapenv:Body>+
                   <tem:HelloWorld/>+
                </soapenv:Body>+
             </soapenv:Envelope>';

         // Open persistent connection
         pComm = http_persist_open(URL);

         // Set credentials
         http_setauth(HTTP_AUTH_NTLM: user: password);

         dou '1';

            // Now call HTTPAPI's "POST" routine.  Pass the above
            //  variables as parameters.  It'll download it to the IFS!
            //
            if ( http_persist_post( pComm: URL: 0: *null
                                  : %addr(postData)+2: %len(postData)
                                  : fd: %paddr('write')) = -1);
                leave;
             endif;

            if ( http_persist_post( pComm: URL: 0: *null
                                  : %addr(postData)+2: %len(postData)
                                  : fd: %paddr('write')) = -1);
                leave;
             endif;

         enddo;

         // Close http connection
         http_persist_close(pComm);

         // Close output file
         callp close(fd);

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E

      * EXAMPLE38:
      * ----------
      * This example shows how to call a web service that is hosted
      * by your IIS on your remote desktop PC. The authentication
      * mechanism used is NTLM, which is the default for IIS
      * servers.
      *
      * The program uses a persistent connection to call the web
      * service twice.
      *
      * Since the devolper knows that the web server requires NTLM
      * negotiation, he does not need to try to GET the web page in
      * order to figure out the authentication mechanism.
      * Instead, he directly calls http_setauth() to specify
      * the credentials for authentication.
      *
      * The HTTP APIs used by the program are:
      *    http_persist_open()
      *    http_setauth()
      *    http_persist_post()
      *    http_persist_close()
      *
      *    http_parser_init()
      *    http_parser_parseChunk()
      *    http_parser_free()
      *
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h

     D Job_getTcpIpAddr...
     D                 PR            15A          varying

      * Note: The BNDDIR, above, tells ILE how to find the HTTPAPIR4
      *       service program which contains the routines.
      *       The /COPY directive provides prototypes and constants
      *       needed to call the routines.

     D example38       PR                  extpgm('EXAMPLE38')
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D EndOfElement    PR
     D  i_UserData                     *   value
     D  i_depth                      10I 0 value
     D  i_name                     1024A   varying const
     D  i_path                    24576A   varying const
     D  i_value                   65535A   varying const
     D  i_attrs                        *   dim(32767)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying

     D example38       PI
     D  i_user                       32A   const
     D  i_password                   32A   const
     D  i_debugLog                   32A   const

     D rc              s             10I 0
     D err             S             10I 0 inz
     D msg             s             52A
     D URL             S            300A   varying
     D IFS             S            256A   varying

     D Basic           S              1N   inz(*Off)
     D Digest          S              1N   inz(*Off)
     D Realm           S            124A   inz
     D Ntlm            S              1N   inz(*Off)
     D user            S                   like(i_user     ) inz('Donald')
     D password        S                   like(i_password ) inz('TheSecret')
     D debugLog        S             32A   varying inz

     D pComm           S               *   inz
     D fd              S             10I 0 inz
     D postData        S            512A   inz varying
     D userData        DS                  likeds(userData_t ) inz
      *
     D userData_t      DS                  qualified  based(pDummy)
     D  srvType                      10A   varying
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      *
     D O_CREAT         C                   const( 8)                            | Append Mode
     D O_CCSID         C                   const(32)                            | CCSID
     D O_TRUNC         C                   const(64)                            | Truncate Fla
     D O_WRONLY        C                   const( 2)                            | Write Only
      /free

         if (%parms() >= 3);
            user = i_user;
            password = i_password;
            debugLog = %trim(i_debugLog);
         else;
            debugLog = '/tmp/';
         endif;

         // ********************************************************
         //  Turning on debugging.
         //
         //     Calling http_debug and passing *ON will turn on
         //     HTTPAPI's debugging support.  It will write a debug
         //     log file to the IFS in /tmp/httpapi_debug.txt
         //     with loads of tech info about the HTTP transaction.
         //
         //     The debug file is crucial if you have problems!
         // ********************************************************
         // http_debug(*ON);
         http_debug(*ON: debugLog + 'httpapi_example38.log');


         // ********************************************************
         //  Setting a proxy (if you need it|)
         // ********************************************************
         // Some corporate networks require you to send HTTP requests
         // through a proxy server (and some do not!) If yours does,
         // you'll need to uncomment these lines and set the right
         // proxy for your network:

         // http_setproxy( 'your.proxy.com': 8080);

         //  If you use a corporate proxy, and it requires a userid/password
         //  you'll have to uncomment the following and set the user/pass
         //  accordingly.
         //
         //  http_proxy_setauth( HTTP_AUTH_BASIC: 'userid': 'password' );
         //

         // More proxy notes:
         //    -- proxy is only required if your network requires it.
         //    -- user/pass is only required if your network requires it,
         //         (you can use a proxy without a user/password by leaving
         //             http_proxy_setauth() commented out...)
         //    -- The parameters for the preceding routines can be set with
         //         variables in place of the constants if you prefer.
         //         it's up to you.


         // ********************************************************
         //   What do I want to get?   Where should I put it?
         // ********************************************************
         // The URL first points to a welcome page on the IIS on your remote
         //   desktop PC.
         // The IFS variable tells HTTPAPI where to put it on your
         //   local i5 computer.
         // Then the URL is changed to point to a web service on the IIS on
         //   your remote desktop PC.

         IFS = debugLog + 'httpapi_example38.html';

         // Open output file
         fd = open(IFS: O_WRONLY + O_TRUNC + O_CREAT + O_CCSID: 511: 819);

         postData =
            '<soapenv:Envelope +
                xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
                xmlns:tem="http://tempuri.org/">+
                <soapenv:Header/>+
                <soapenv:Body>+
                   <tem:HelloWorld/>+
                </soapenv:Body>+
             </soapenv:Envelope>';

         dou '1';

            // Set first URL to GET the welcome page.
            URL = 'http://' + Job_getTcpIpAddr() + '/index.html';

            // Open persistent connection
            pComm = http_persist_open(URL);

            // Set credentials
            http_setauth(HTTP_AUTH_NTLM: user: password);

            // Now call HTTPAPI's "GET" routine.
            //  It'll download the welcome page to the IFS.
            rc = http_persist_get( pComm: URL: fd: %paddr('write'));
            if ( rc <> 1);
               sndMsg('Could not download welcome page');
               leave;
            endif;

            sndMsg('Welcome page save to: ' + IFS);

            // Initialize XML parser
            http_parser_init(
                  *omit: *null: %paddr(EndOfElement): %addr(userData));

            // Then call HTTPAPI's "POST" routine.  Pass the above
            //  variables as parameters.  It'll call the web service and
            //  parse the result.
            URL = 'http://' + Job_getTcpIpAddr() + '/HelloWorld.asmx';
            userData.srvType = 'good';
            rc = http_persist_post( pComm: URL: 0: *null
                                  : %addr(postData)+2: %len(postData)
                                  : 0: %paddr(http_parser_parseChunk));

            if ( rc <> 1);
               http_parser_free(*off);   // Free the parser in case of an error.
               sndMsg('Failed to call ''' + userData.srvType +
                      ''' web service at: ' + URL);
               leave;
            endif;

            // Now call HTTPAPI's "POST" routine.  Pass the above
            //  variables as parameters.  It'll produce an error
            //  because of an invalid URL.
            URL = 'http://' + Job_getTcpIpAddr() + '/HelloWorld.error';
            userData.srvType = 'bad';
            rc = http_persist_post( pComm: URL: 0: *null
                                  : %addr(postData)+2: %len(postData)
                                  : 0: %paddr(http_parser_parseChunk));
            if ( rc <> 1);
               http_parser_free(*off);   // Free the parser in case of an error.
               sndMsg('Failed to call ''' + userData.srvType +
                      ''' web service at: ' + URL);
               leave;
            endif;

            http_parser_free(*on);

         enddo;

         // Close http connection
         http_persist_close(pComm);

         // Close output file
         callp close(fd);

         // ********************************************************
         //  Error handling...
         //
         //  http_url_get() returns 1 when successful.
         //
         //  if it's unsuccessful, you can call the http_error()
         //  routine to learn what went wrong.  In this example,
         //  the error is put in the 'msg' variable.  You would
         //  then add code to display it to a user, or write it
         //  to a log file, or whatever is appropriate.
         // ********************************************************

         if (rc <> 1);
            msg = http_error;
            sndMsg(msg);
         endif;

         *inlr = *on;
      /end-free

      *===============================================================*
      *  End-Of-Element callback procedure, used by eXpat parser.
      *===============================================================*
     P EndOfElement...
     P                 B
     D                 PI
     D  i_UserData                     *   value
     D  i_depth                      10I 0 value
     D  i_name                     1024A   varying const
     D  i_path                    24576A   varying const
     D  i_value                   65535A   varying const
     D  i_attrs                        *   dim(32767)
      *
     D userData        DS                  likeds(userData_t) based(i_UserData)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_path = '/soap:Envelope/soap:Body/HelloWorldResponse');
            if (i_name = 'HelloWorldResult');
               sndMsg('Response of ''' + userData.srvType +
                      ''' web service is: ' + i_value);
            endif;
         endif;

         return;

      /END-FREE
     P                 E

      *===============================================================*
      *  Returns the IP address of the 5250 client of the
      *  specified job.
      *===============================================================*
     P Job_getTcpIpAddr...
     P                 B                   export
     D                 PI            15A          varying
      *
      *  Retrieve Job Information (QUSRJOBI) API
     D QUSRJOBI...
     D                 PR                  extpgm('QUSRJOBI')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_format                      8A   const
     D  i_qJob                       26A   const
     D  i_intJobID                   16A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    OptGrp 1
     D  i_resPrfStat                  1A   const  options(*nopass)              OptGrp 2
      *
     D qJob            DS                  qualified
     D  name                         10A   inz('*')
     D  user                         10A   inz
     D  nbr                           6A   inz
      *
     D jobi0600        DS                  qualified
     D  jobType               61     61A
     D  jobSubType            62     62A
     D  device               127    136A
      *
      *  Retrieve Device Description (QDCRDEVD) API
     D QDCRDEVD...
     D                 PR                         extpgm('QDCRDEVD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_devName                    10A   const
     D  io_errCode                65535A          options(*varsize)

     D devd0600        DS          1024    qualified
     D  tcpIpDotAddr         878    892A

     D errCode         DS                  inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         QUSRJOBI(jobi0600:%size(jobi0600):'JOBI0600':qJob:'':errCode);
         QDCRDEVD(devd0600:%size(devd0600):'DEVD0600':jobi0600.device:errCode);
         return %trim(devd0600.tcpIpDotAddr);
      /END-FREE
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
      *
     D sndMsg...
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';

         clear errCode;
         errCode.bytPrv = %size(errCode);

         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);

         return;

      /END-FREE
      *
     P sndMsg...
     P                 E

      * THE STORY SO FAR:
      * -----------------
      *  EXAMPLE1 showed the basics of downloading a file with HTTP
      *  EXAMPLE2 showed how to use some of the more advanced
      *            parameters related to downloading a file.
      *  EXAMPLE3 showed how you can use SSL/TLS to protect your
      *            HTTP data transferred with HTTPAPI
      *
      * EXAMPLE4:
      * ----------
      *  HTTPAPI is not limited to simply downloading a document from
      *  an HTTP server. It's also capable of performing other operations
      *  including POST, PUT, DELETE, etc.
      *
      *  With POST, you specify a program on the HTTP server to call
      *  and you upload data to that program.
      *
      *  Then you get back a download from the program. (And the down
      *  load part works just like it did in a GET request)
      *
      *  This example attempts to:
      *    - Show how to encode data the way a browser would when you
      *       fill in a form in a browser window.
      *    - Show how to use the HTTP POST method to send that data
      *       to an HTTP server.
      *    - Show how to handle "redirects".  i.e. when a web page
      *       returns a code that asks you to visit another web
      *       page, how to view that page.
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      *
      * Note that this program performs the same function that your
      * web browser would if you pointed it to:
      *     http://www.scottklement.com/comment/
      *
      * There is also a more advanced example that does the same
      * thing using pointers. The advantage is that it isn't limited
      * in data size.  See EXAMPLE15.
      *

      /define WEBFORMS
     D/copy httpapi_h

     D cmd             pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D CRLF            C                   CONST(x'0D25')
     D rc              s             10I 0
     D msg             s             52A
     D fromAddr        s            100A   varying
     D Subject         s            100A   varying
     D Message         s           1000A   varying
     D myPointer       s               *
     D dataSize        s             10I 0
     D formData        s          32767a   varying

      /free
        http_debug(*on);

        //
        // CHANGE THIS TO YOUR E-MAIL ADDRESS:
        //
        FromAddr = 'example4@scottklement.com';

        //
        // CHANGE THIS TO THE SUBJECT YOU'D LIKE SENT TO ME:
        //
        Subject = 'EXAMPLE4 from HTTPAPI.';

        //
        // CHANGE THIS TO THE MESSAGE YOU'D LIKE SENT TO ME:
        //
        Message = 'Hi Scott!' + CRLF +
                  '  Just a note to tell you that I''m testing out the +
                  EXAMPLE4 program in HTTPAPI. If you receive this, it +
                  must work!' + CRLF;

        //
        // Encode the data as it would appear on a web form
        //

        formData = 'from=' + http_urlEncode(FromAddr)
                 + '&subject=' + http_urlEncode(Subject)
                 + '&Comment=' + http_urlEncode(message);

        //
        // When sending data, the server will want to know what
        // type of data we're sending. This is done by specifying
        // a "content-type".  In this case, "x-www-form-urlencoded"
        // is the Internet name for a web form.
        //

        http_setOption( 'content-type'
                      : 'application/x-www-form-urlencoded' );

        //
        // This example uses http_req(), which is similar to
        // http_stmf() from the previous examples, except:
        //   - data can be sent from either a stmf or a string
        //   - data can be received into either a stmf or a string
        //   - no error message is sent, instead there's a "return code"
        //       (or 'rc' as I like to abbreviate it)
        //
        // There are two parameters each for the data to receive and
        // the data to send, but you can only use one of each.
        //
        // this example
        //    - passes /tmp/testpost.html for the file to receive into
        //       and *OMIT for the string to receive into.
        //    - passes *OMIT for the file to send data from,
        //       and a variable (with our form data) for a string to send
        //

        rc = http_req( 'POST'
                     : 'http://www.scottklement.com/cgi-bin' +
                       '/email_comment.cgi'
                     : '/tmp/testpost.html'       // File to receive
                     : *omit                      // String to receive
                     : *omit                      // File to send
                     : formData );                // String to send

        //
        // This particular web page doesn't give a direct response
        // but instead asks you to visit another page.  This is done
        // by sending back a 302 ("Page Moved") response.  You can
        // call the http_redir_loc() routine in HTTPAPI to get the
        // URL that the redirection points to, and then the http_url_get()
        // routine to ask HTTPAPI to retrieve that page.
        //

        if rc=302;
           rc = http_req( 'GET'
                        : http_redir_loc()
                        : '/tmp/testpost.html' );
        endif;

        //
        // If there's an error, use the DSPLY opcode to show it on the
        // screen.   If not, use the DSPF command from OS/400 to display
        // the data that was returned onto the screen.
        //
        if rc <> 1;
           msg = http_error();
           dsply msg;
        else;
           cmd('DSPF ''/tmp/testpost.html''': 200);
        endif;

        *inlr = *on;
      * This example demonstrates posting multipart/related to a
      * web server.
      *
      * It is intended to call a SOAP WebService using MTOM to send an attachment.
      * The service is a brief example that you can find here:
      *   https://github.com/zenovalle/MTOMService/raw/master/MTOMService.war
      * and install into one application server (you have to adjust the url
      * to the server you use).
      *----------------------------------------------------------------
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h
      /copy ifsio_h

     D QCMDEXC         pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D SOAP            s           1000A   varying
     D tempFile        s            200A   varying
     D ContentType     s            256A
     D enc             s               *
     D msg             s             52A
     D rc              s             10I 0

      /free

          http_debug(*on);
          *inlr = *on;

          //  Ask HTTPAPI for a temporary filename that won't
          //  conflict with another job.

          tempFile = http_tempfile();

          //  HTTPAPI's multipart/related encoding function output
          //    two things:
          //
          //       1) A stream file field suitable for use with
          //            http_url_post_stmf()
          //       2) A content-type field suitable for use with
          //            http_url_post_stmf()
          //
          //  The http_mfd_encoder_open() API opens the stream file
          //  and initializes the encoding routines.  You must call
          //  that first, passing the type of the message, and
          //  eventually the starting part id and info:

          enc = http_mpr_encoder_open( tempFile
                                     : 'application/xop+xml'
                                     : ContentType
                                     : '<roothttpapi.org>'
                                     : 'text/xml' );
          if (enc = *NULL);
             msg = http_error();
             dsply msg;
             return;
          endif;

          //
          //  now you can add the root part that is our SOAP:
          //

       SOAP =
       '<soapenv:Envelope +
        xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
        xmlns:exam="http://examples.zenovalle.it/"> +
           <soapenv:Header/> +
           <soapenv:Body> +
              <exam:archiveFile> +
                 <request> +
                    <fileLoad><inc:Include href="cid:testfile.pdf" +
        xmlns:inc="http://www.w3.org/2004/08/xop/include"/></fileLoad> +
                    <description>This is a test file</description> +
        <fileName>Scott''s HTTPAPI presentation handout.pdf</fileName> +
                    <fileType>application/pdf</fileType> +
                    <key>1234567890</key> +
                 </request> +
              </exam:archiveFile> +
           </soapenv:Body> +
        </soapenv:Envelope>';

           http_mpr_encoder_addstr_s( enc
                                    : SOAP
                                    : 'application/xop+xml; type="text/xml"'
                                    : '<roothttpapi.org>' );

          //
          //  then you can add other parts, for our example add
          //  the pdf file from EXAMPLE1.
          //

          http_mpr_encoder_addstmf( enc
                                  :'/tmp/Scott''s HTTPAPI '
                                   + 'presentation handout.pdf'
                                  : 'application/pdf'
                                  : '<testfile.pdf>' );

          //
          // once all of the variables/files have been added, the
          // http_mpr_encoder_close() API must be called to clean
          // up. (The stream file will remain on disk so that you
          // can use it with http_url_post_stmf)
          //

          http_mpr_encoder_close( enc );


          //
          //  post the results to the web server
          //

          rc = http_url_post_stmf('http://localhost:8080/MTOMService'
                                    + '/services/archiveServer'
                                 : tempFile
                                 : '/tmp/http_result.txt'
                                 : HTTP_TIMEOUT
                                 : HTTP_USERAGENT
                                 : ContentType
                                 : 'archiveFile' );

          if (rc <> 1);
             msg = http_error();
             dsply msg;
             return;
          endif;

          QCMDEXC('DSPF ''/tmp/http_result.txt''': 200);

          //
          //  delete temp files, we're done
          //

          unlink('/tmp/http_result.txt');
          unlink(tempFile);

          return;
      /end-free

      * This example demonstrates how to parse a multipart/related response
      * in order to get an attachment.
      *
      * It is intended to call a SOAP WebService using MTOM to retrieve an attachment.
      * The service is a brief example that you can find here:
      *   https://github.com/zenovalle/MTOMService/raw/master/MTOMService.war
      * and install into one application server (you have to adjust the url
      * to the server you use).
      *----------------------------------------------------------------
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h
      /copy ifsio_h

     D QCMDEXC         pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D SOAP            s           1000A   varying
     D dec             s               *
     D msg             s             52A
     D rc              s             10I 0
     D fileinfo        ds
     D  filename                    256A
     D  fd                           10I 0

     D StartPrc        PR
     D   userdata                      *   value
     D   isRoot                        N   const

     D PartPrc         PR
     D   userdata                      *   value
     D   data                          *   value
     D   datalen                     10I 0 const

     D EndPrc          PR
     D   userdata                      *   value

      /free

       http_debug(*on);
       *inlr = *on;

       SOAP =
       '<soapenv:Envelope +
        xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" +
        xmlns:exam="http://examples.zenovalle.it/">+
           <soapenv:Header/>+
           <soapenv:Body>+
              <exam:getFile>+
                 <key>1234567890</key>+
              </exam:getFile>+
           </soapenv:Body>+
        </soapenv:Envelope>';

       //
       //  post the results to the web server
       //

       rc = http_url_post('http://localhost:8080/MTOMService'
                               + '/services/archiveServer'
                            : %addr(SOAP) + 2
                            : %len(SOAP)
                            : '/tmp/http_result.txt'
                            : HTTP_TIMEOUT
                            : HTTP_USERAGENT
                            : 'text/xml'
                            : 'getFile' );

          if (rc <> 1);
             msg = http_error();
             dsply msg;
             return;
          endif;

          //
          //  create a parser for the multipart/related response.
          //  It must be passed the reference to the procedure used
          //  by the parsing process in order to save the
          //  attachment on disk
          //

          dec = http_mpr_decoder_open( '/tmp/http_result.txt'
                                     : http_header('content-type')
                                     : %addr(fileinfo)
                                     : %paddr(StartPrc)
                                     : %paddr(PartPrc)
                                     : %paddr(EndPrc) );

          //
          //  parse the thing
          //

          if not http_mpr_decoder_parse(dec);
             msg = 'Parsing error.';
             dsply msg;
             return;
          endif;

          //
          // once all is completed, the http_mpr_decoder_close()
          // API must be called to clean up.
          //

          http_mpr_decoder_close(dec);


          QCMDEXC('DSPF ''/tmp/http_result_root.xml''': 200);
          QCMDEXC('DSPF ''' + %trim(filename) + '''': 200);

          //
          //  delete temp files, we're done
          //

          unlink('/tmp/http_result.txt');
          unlink('/tmp/http_result_root.xml');
          unlink(%trim(filename));

          return;
      /end-free


     P StartPrc        B
     D StartPrc        PI
     D   userdata                      *   value
     D   isRoot                        N   const

     D fileinfo        ds                  based(userdata)
     D  filename                    256A
     D  fd                           10I 0

     D id              s             64A   varying
      /free

       if isRoot;
          filename = '/tmp/http_result_root.xml';
          fd = open( %trim(filename)
                   : O_CREAT + O_TRUNC + O_CCSID + O_WRONLY
                   : S_IRUSR + S_IWUSR
       //          : 819 );
                   : 1208 );
       else;
          id = %trim(http_mpr_part_header('content-id'));
          id = %subst(id : 2 : %len(id) - 2);
          filename = '/tmp/' + %trim(id) + '.pdf';
          fd = open( %trim(filename)
                   : O_CREAT + O_TRUNC + O_CCSID + O_WRONLY
                   : S_IRUSR + S_IWUSR
       //          : 819 );
                   : 1208 );
       endif;

      /end-free
     P                 E


     P PartPrc         B
     D PartPrc         PI
     D   userdata                      *   value
     D   data                          *   value
     D   datalen                     10I 0 const

     D fileinfo        ds                  based(userdata)
     D  filename                    256A
     D  fd                           10I 0
      /free
        callp write(fd: data: datalen);
      /end-free
     P                 E


     P EndPrc          B
     D EndPrc          PI
     D   userdata                      *   value

     D fileinfo        ds                  based(userdata)
     D  filename                    256A
     D  fd                           10I 0
      /free
        callp close(fd);
      /end-free
     P                 E

      * THE STORY SO FAR:
      * -----------------
      *  EXAMPLE1 showed the basics of downloading a file with HTTP
      *  EXAMPLE2 showed how to use some of the more advanced
      *            parameters related to downloading a file.
      *  EXAMPLE3 showed how you can use SSL/TLS to protect your
      *            HTTP data transferred with HTTPAPI
      *  EXAMPLE4 showed how to encode data like a browser would,
      *            how to POST data to a web site, and how to
      *            handle a "redirect" message from the site.
      *
      * EXAMPLE5:
      * ----------
      *  Some web sites aren't available to the public.  They ask
      *  you for a userid/password in order to view their content.
      *  This is especially common with Intranets and Extranets.
      *
      *  Now, there are several ways to ask a user for a userid/password.
      *  One way is to display a form in a browser where you'd fill in
      *  the username and password, and that would work exactly as
      *  the code in the previous member (EXAMPLE4) demonstrated.
      *  However, sometimes the userid/password is not part of the form
      *  data on the screen, but is requested separately by the browser.
      *  This example (EXAMPLE5) demonstrates how to handle that data
      *  with HTTPAPI.
      *
      *  Under the covers, this is handled by the www-authenticate
      *  HTTP keyword. HTTPAPI supports two different methods of
      *  doing this type of authentication, they are the "basic"
      *  (clear text) method and the "digest" (encrypted) method.
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

      * This is an example of how your application detects that
      * a userid/password is required for a web site.  It can then
      * ask the user for userid/password and try again.
      *
      * Note: This method supports both Basic & Digest authentication
      *
      *  NOTE:  UserId = testuser
      *       Password = testpass
      *

     D/copy httpapi_h

     D cmd             pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D rc              S             10I 0
     D err             S             10I 0
     D basic           S              1N
     D digest          S              1N
     D realm           S            124A
     D userid          S             50A
     D pass            S             50A
     D URL             s            256A
     D msg             S             50A

     c                   eval      *inlr = *on

      ** EXAMPLE:
      **   This document requires you to sign in with
      **   user=testuser, password=testpass
      **
     c                   eval      URL = 'http://www.scottklement.com' +
     c                                   '/locked/index.html'

      * If you try to retrieve this URL, and you haven't provided a
      * valid userid/password, HTTPAPI will return a -1, and will
      * set it's error code to HTTP_NDAUTH.
      *
      * If that happens, we do the getpasswd subroutine, which asks
      * for a userid/password.
      *
     c                   dou       rc = 1

     c                   eval      rc = http_url_get( URL
     c                                              : '/tmp/testauth.html')

     c                   if        rc <> 1
     c                   callp     http_error(err)
     c                   if        err <> HTTP_NDAUTH
     c                   callp     http_crash
     c                   return
     c                   endif
     c                   exsr      getpasswd
     c                   endif

     c                   enddo

     c                   callp     cmd('DSPF ''/tmp/testauth.html''': 200)

      *-------------------------------------------------------------
      * this is called when the web server requests a userid/passwd
      *
      * http_getauth(): gets information about the request.
      *     "realm" is a string that the browser would normally
      *        show to the user to tell them what they're logging
      *        into.  It might say "Acme's web server" so the user
      *        knows he/she is logging into that server.
      *     "digest" is an indicator specifying whether digest
      *        authentication is allowed or not.
      *     "basic" is an indicator specifying whether basic
      *        authentication is allowed or not.
      *
      *  http_setauth() sets the authentication type (digesst or basic)
      *      as well as the actual userid/password that will be sent
      *      for future http requests.
      *
      * BASIC authentication sends your userid and password over
      * the Internet. I recommend only using this if your session
      * is SSL-encrypted. Without SSL, this password is sent over
      * the Internet unencrypted, and therefore can be intercepted
      * by a miscreant.
      *
      * Note that if you know in advance that you'll need basic
      * authentication, it's possible to set the userid and
      * password by calling http_setauth prior to the http_url_get
      * routine above.
      *
      * In my experience, 99% of the sites that require this sort
      * of userid/password use basic authentication.
      *
      * DIGEST authentication is encrypted, and is safe to use in
      * unencrypted transactions.
      *
      * Digest authentication will only work AFTER http_url_get
      * has failed, and returned HTTP_NDAUTH. This is because there
      * are some encryption parameters that are set by the HTTP
      * server when the first request fails, and HTTPAPI needs that
      * information to encrypt the userid/password that it sends
      * back.
      *
      * If both types of encryption are allowed, it makes sense
      * to use Digest, because it's more secure. However, I have
      * found that Digest authentication is rarely used on the web.
      *
      * HTTPAPI does not (currently) support other authetnication
      * methods such as NTLM/NTLMv2 (which is a Microsoft technique
      * that was not developed by the open standards committees that
      * created the HTTP protocol.)
      *-------------------------------------------------------------
     csr   getpasswd     begsr

     c                   eval      rc = http_getauth(basic: digest: realm)
     c                   if        rc < 0
     c                   eval      msg = HTTP_ERROR
     c                   dsply                   msg
     c                   return
     c                   endif

     c                   eval      userid = 'enter userid for ' + realm
     c                   dsply                   userid

     c                   eval      pass = 'enter passwd for ' + realm
     c                   dsply                   pass

     c                   if        Digest
     c                   callp     http_setauth(HTTP_AUTH_MD5_DIGEST:
     c                                          userid: pass)
     c                   else
     c                   callp     http_setauth(HTTP_AUTH_BASIC:
     c                                          userid: pass)
     c                   endif

     csr                 endsr
      * THE STORY SO FAR:
      * -----------------
      *  EXAMPLE1 showed the basics of downloading a file with HTTP
      *  EXAMPLE2 showed how to use some of the more advanced
      *            parameters related to downloading a file.
      *  EXAMPLE3 showed how you can use SSL/TLS to protect your
      *            HTTP data transferred with HTTPAPI
      *  EXAMPLE4 showed how to encode data like a browser would,
      *            how to POST data to a web site, and how to
      *            handle a "redirect" message from the site.
      *  EXAMPLE5 showed how to supply a username/password to let
      *            you authenticate with a site that uses
      *            www-authentication (HTTP authentication)
      *
      * EXAMPLE6:
      * ----------
      *
      *  Where some sites use HTTP authentication, many do not.
      *  a URL encoded form and no file upload.
     c                   eval      *inlr = *on
      * This example demonstrates posting multipart/form-data to a
      * web server.
      *
      * It is intended to mimic the following HTML form:
      *----------------------------------------------------------------
      *
      * <form method="post" enctype="multipart/form-data"
      *       action="http://www.scottklement.com/httpapi/upload.php">
      *
      *   <input type="hidden" name="operation" value="VERIFY">
      *
      *   File Format:
      *   <input type="radio"  name="data_format" value="HTML" checked>HTML
      *   <input type="radio"  name="data_format" value="PDF">PDF
      *   <input type="radio"  name="data_format" value="PTF">RTF<br>
      *
      *   File to send:
      *   <input type="file" name="handout"><br>
      *
      *   <input type="submit">
      *
      * </form>
      *
      *----------------------------------------------------------------
      *
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO)
      /endif
     H BNDDIR('HTTPAPI')

      /copy httpapi_h
      /copy ifsio_h

     D QCMDEXC         pr                  extpgm('QCMDEXC')
     D  command                     200A   const
     D  length                       15P 5 const

     D tempFile        s            200A   varying
     D ContentType     s             64A
     D enc             s               *
     D msg             s             52A
     D rc              s             10I 0

      /free

          http_debug(*on);
          *inlr = *on;

          //  Ask HTTPAPI for a temporary filename that won't
          //  conflict with another job.

          tempFile = http_tempfile();

          //  HTTPAPI's multipart/form-data encoding functions output
          //    two things:
          //
          //       1) A stream file field suitable for use with
          //            http_url_post_stmf()
          //       2) A content-type field suitable for use with
          //            http_url_post_stmf()
          //
          //  The http_mfd_encoder_open() API opens the stream file
          //  and initializes the encoding routines.  You must call
          //  that first:

          enc = http_mfd_encoder_open( tempFile : ContentType );
          if (enc = *NULL);
             msg = http_error();
             dsply msg;
             return;
          endif;

          //
          //  now you can add variables to the encoded stream file:
          //

           http_mfd_encoder_addvar_s(enc: 'operation'  : 'VERIFY');
           http_mfd_encoder_addvar_s(enc: 'data_format': 'PDF'   );

          //
          //  and you can even add the contents of another stream
          //  file, compatible with the <input type="file"> HTML
          //  keyword.
          //
          //  In this case, the HTTPAPI handout that was downloaded
          //  in EXAMPLE1 will be added to the temp file
          //

          http_mfd_encoder_addstmf( enc
                                  : 'handout'
                                  : '/tmp/Scott''s HTTPAPI +
                                    presentation handout.pdf'
                                  : 'application/octet-stream');

          //
          // once all of the variables/files have been added, the
          // http_mfd_encoder_close() API must be called to clean
          // up. (The stream file will remain on disk so that you
          // can use it with http_url_post_stmf)
          //

          http_mfd_encoder_close( enc );


          //
          //  post the results to the web server
          //

          rc = http_url_post_stmf('http://www.scottklement.com/httpapi'
                                    + '/upload.php'
                                 : tempFile
                                 : '/tmp/http_result.txt'
                                 : HTTP_TIMEOUT
                                 : HTTP_USERAGENT
                                 : ContentType );

          if (rc <> 1);
             msg = http_error();
             dsply msg;
             return;
          endif;

          QCMDEXC('DSPF ''/tmp/http_result.txt''': 200);

          //
          //  delete temp files, we're done
          //

          unlink('/tmp/http_result.txt');
          unlink(tempFile);

          return;
      /end-free
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP(*NEW)
      /endif
     H BNDDIR('HTTPAPI')

     D/copy httpapi_h

     D status          PR
     D   BytesRecv                   10U 0 value
     D   BytesTotal                  10U 0 value

     D rc              s             10I 0
     D msg             s             52A

     c                   eval      *inlr = *on

     C* Register our "STATUS" procedure as the procedure for HTTPAPI
     C* to call to tell us about the download progress...
     C*
     c                   if        HTTP_xproc(HTTP_POINT_DOWNLOAD_STATUS:
     c                                        %paddr('STATUS')) < 0
     c                   eval      msg = http_error
     c                   dsply                   msg
     c                   endif

     C* Retrieve Scott Klement's sockets tutorial:

     c                   eval      rc = http_url_get(
     c                             'http://www.scottklement.com/rpg/'+
     c                             'socktut/tutorial.pdf':
     c                             '/tmp/sock_tutorial.pdf')

     c                   if        rc <> 1
     c                   eval      msg = http_error
     c                   dsply                   msg
     c                   endif

     c                   eval      *inlr = *on


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Because we registered it (above) HTTPAPI will call this proc
      *  each time more data is received from the HTTP server.
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P status          B
     D status          PI
     D   BytesRecv                   10U 0 value
     D   BytesTotal                  10U 0 value

     D LastPct         s              3P 0 static
     D Pct             s              3P 0
     D Msg             s             52A

      ** When using the "chunked" encoding, the web server will not
      ** tell us the full file size, so we can only display "bytes received"
     c                   if        BytesTotal = 0
     c                   eval      Msg = %trim(%editc(BytesRecv:'P'))
     c                                 + ' bytes have been received'
     c     Msg           dsply
     c                   return
     c                   endif

      **
      **  When chunked encoding is not used, we'll display a percent
      **
     c                   eval(h)   Pct = (BytesRecv*100) / BytesTotal

     c                   if        Pct <> LastPct
     c                   eval      Msg = 'Download is '
     c                                 + %trim(%editc(Pct:'P'))
     c                                 + '% completed.'
     c     Msg           dsply
     c                   eval      LastPct = Pct
     c                   endif

     P                 E
      /if defined(*CRTBNDRPG)
     H DFTACTGRP(*NO) ACTGRP('KLEMENT')
      /endif
     H BNDDIR('HTTPAPI')

      *  Example of using the html2pdf RESTful web service to create
      *  a PDF document for a given web site
      *
      *  To compile:
      *   * Make sure HTTPAPI is installed and in your *LIBL
      *   *> CRTBNDRPG EXAMPLE9 SRCFILE(QRPGLESRC)
      *   *> CRTCMD CMD(EXAMPLE9) SRCFILE(QCMDSRC) -
      *   *>        PGM(EXAMPLE9)
      *
      *  To run, use the *CMD interface.
      *
      *    EXAMPLE9 URL('http://www.google.com')
      *             STMF('/tmp/google.pdf')
      *
      *
      *  More info on this web service is here:
      *    http://www.html2pdf.biz/api.php
      *
      *  NOTE: This web service is usually very slow. They claim
      *        to offer a better service if you pay for their
      *        commercial edition.  (I haven't tried it.  See
      *        the link, above, for details.)
      *

      /define WEBFORMS
      /copy httpapi_h

     D EXAMPLE9        PR                  ExtPgm('EXAMPLE5')
     D   inputURL                  5000a   varying const
     D   outputStmf                5000a   varying const
     D   outputFormat                 5a   const
     D EXAMPLE9        PI
     D   inputURL                  5000a   varying const
     D   outputStmf                5000a   varying const
     D   outputFormat                 5a   const

     D uri             s           5050a   varying
     D form            s                   like(WEBFORM)
     D rc              s             10i 0

      /free
         http_debug(*on: '/tmp/example9-debug.txt');

         if %parms < 3;
            http_comp('To call, type: +
         EXAMPLE9 URL(''http://google.com'') STMF(''/tmp/google.pdf'')');
            return;
         endif;

         // -----------------------------------------------
         //  service takes 2 parameters:
         //    'url' = the URL of the web site to convert
         //    'ret' = output format. (pdf, json or png)
         // -----------------------------------------------

         form = webform_open();
         webform_setVar(form: 'url': inputURL);
         webform_setVar(form: 'ret': %trimr(%subst(outputFormat:2)));
         uri = 'http://html2pdf.biz/api?' + webform_getData(form);
         webform_close(form);

         // -----------------------------------------------
         //  service will send a redirect (301 or 302) to tell
         //  you where to get the file...
         //
         //  Note: The third parameter to http_url_get()
         //        is the "timeout" parameter. Because this
         //        site is slow, I've overridden it to 300
         //        seconds (= 5 minutes)
         // -----------------------------------------------

         dou (rc<>301 and rc<>302);
            rc = http_url_get(uri: outputStmf: 300);
            if (rc=301 or rc=302);
               uri = http_redir_loc();
            endif;
         enddo;

         if (rc <> 1);
           http_crash();
         endif;

         *inlr = *on;
      /end-free
     /*-                                                                            +
      * Copyright (c) 2006-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

      *  This member is to contain routines for parsing HTTP headers
      *  and for working with cookies.
      *-
      *
      *  Cookie Information is found in RFC 2109
      *    http://www.ietf.org/rfc/rfc2109.txt
      *  Also, the original Netscape specification can be found here:
      *    http://wp.netscape.com/newsref/std/cookie_spec.html
      *
      *  FIXME:  The cookie standard was changed in April 2011
      *          this code should be updated accordingly.
      *           http://tools.ietf.org/html/rfc6265
      *
      *>  chgcurlib curlib(libhttp)
      *>  crtrpgmod headerr4 srcfile(libhttp/qrpglesrc) dbgview(*list)
      *>  updsrvpgm httpapir4 module(headerr4)
      *-
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /define HTTP_WSDL2RPG_STUFF
      /copy header_h
      /copy private_h
      /copy ifsio_h
      /copy httpapi_h
      /copy errno_h

     D upper           C                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           C                   'abcdefghijklmnopqrstuvwxyz'

     D header_clean    PR
     D header_find     PR            10I 0
     D   name                       256A   varying const
     D   pos                         10I 0 value
     D skipWhiteSpaces...
     D                 PR            10I 0
     D   buffer                   32500A   const  options(*varsize)
     D   len                         10I 0 value
     D   pos                         10I 0 value
     D isWhiteSpace    PR              N
     D   char                         1A   const
     D skipToSubType...
     D                 PR            10I 0
     D   buffer                   32500A   const  options(*varsize)
     D   len                         10I 0 value
     D   pos                         10I 0 value
     D removeQuotes...
     D                 PR         32500A   varying
     D   string                   32500A   const  options(*varsize)
     D   len                         10I 0 const
     D   quote                        1A   const  options(*nopass)
     D cookie_parse    PR
     D   dft_path                   256A   varying const
     D   dft_domain                 256A   varying const
     D   cookie                   32500A   varying const
     D   data                              like(cookie_data)
     D cookie_reset    PR
     D   data                              like(cookie_data)
     D cookie_attr     PR
     D   count                       10I 0
     D   name                              like(cd_name)
     D   value                             like(cd_value)
     D cookie_match    PR             1N
     D   domain                            like(cd_domain) const
     D   path                              like(cd_path) const
     D   exact                        1N   const
     D cookie_reject   PR             1N
     D   cookie                            like(cookie_data)
     D   req_domain                 256A   varying const
     D   req_path                   256A   varying const
     D cookie2ts       PR              Z
     D   cookie                      50A   varying value
     D cookie_alloc    PR              *
     D cookie_find     PR              *
     D   name                              like(cd_name) const
     D   domain                            like(cd_domain) const
     D   path                              like(cd_path) const
     D   secure                       1N   const
     D   exact                        1N   const
     D cookie_set      PR
     D    cookie                           like(cookie_data)
     D cookie_dump     PR             1N
     D   filename                   256A   varying const
     D cookie_write    PR            10I 0
     D   fd                          10I 0 value
     D cookie_read     PR            10I 0
     D   filename                   256A   varying const
     D cookie_readfld  PR
     D   fieldno                     10I 0 value
     D   data                     32767A   varying const

     D hdrs            s             10I 0 inz(0)

     D hdr             ds                  occurs(4000)
     D  hdr_name                    256A   varying
     D  hdr_idx                      10I 0
     D  hdr_len                      10I 0
     D  hdr_fill                      8A
     D  hdr_ptr                        *

     D header          s          32500A   based(p_header)

     D cookie_data     ds                  based(p_cookie_data)
     D   cd_name                    256A   varying
     D   cd_lcname                  256A   varying
     D   cd_value                  8192A   varying
     D   cd_domain                  256A   varying
     D   cd_path                    256A   varying
     D   cd_expires                    Z
     D   cd_recv                       Z
     D   cd_version                   1A
     D   cd_secure                    1N
     D   cd_gotdom                    1N
     D   cd_gotpath                   1N
     D   cd_temp                      1N

     D cookie_file     s            256A   varying inz('')
     D cookie_count    s             10I 0
     D cookie_list     s               *   dim(1024)
     D dump_session    s              1n   inz(*OFF)
     D UCS2_DOLLAR     c                   const(u'0024')


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Parse HTTP header & protocol information
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P header_parse    B                   export
     D header_parse    PI
     D   resp                     32767A   varying const
     D   userdata                      *   value

     D name            s            256A   varying
     D val             s          32500A   varying
     D CRLF            c                   x'0d25'
     D next            s             10I 0 inz(1)
     D eoh             s             10I 0
     D eok             s             10I 0
     D len             s             10I 0

     c                   callp     header_clean

      ***********************************************
      * Break response chain into individual headers
      *   and call header_process for each
      ***********************************************
     c                   dow       next < %len(resp)

      * Find end of HTTP header
     c                   eval      eoh = %scan(CRLF:resp:next)
     c                   if        eoh  = 0
     c                   leave
     c                   endif

      * Find end of keyword, start of value
     c                   eval      eok = %scan(':':resp:next)
     c                   if        eok=0 or eok=next or eok>eoh
     c                   eval      next = eoh + 2
     c                   iter
     c                   endif

      * get name of header & value
     c                   eval      len = eok - next
     c                   eval      name = %subst(resp:next:len)
     c     upper:lower   xlate     name          name
     c                   eval      len = (eoh - eok) - 1

     c                   if        len = 0
     c                   eval      %len(val) = 0
     c                   else
     c                   eval      val = %subst(resp:eok+1:len)
     c                   endif

      * process them
     c                   if        hdrs < %elem(hdr)

     c                   if        len = 0
     c                   eval      p_Header = *null
     c                   else
     c                   eval      p_Header = xalloc(len)
     c                   eval      %subst(header:1:len) = val
     c                   endif

     c                   eval      hdrs = hdrs + 1
     C     hdrs          occur     hdr
     c                   eval      hdr_name = name
     c                   eval      hdr_idx = hdrs
     c                   eval      hdr_len = len
     c                   eval      hdr_ptr = p_header

     c                   endif

      * look for next header
     c                   eval      next = eoh + 2
     c                   enddo

      /if defined(MEMCOUNT)
     c                   callp     http_dmsg( 'saved '
     c                                      + %char(hdrs)
     c                                      + ' to actgrp')
     c                   callp     http_dmsg( 'NOTE: headers +
     c                             saved to actgrp are cleaned +
     c                             up in the next request')
      /endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * header_clean(): free up all header data
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P header_clean    B
     D header_clean    PI
     D i               s             10I 0
     c     1             do        hdrs          i
     c     i             occur     hdr
     c                   eval      hdr_idx = 0
     c                   eval      hdr_len = 0
     c                   if        hdr_ptr <> *null
     c                   callp     xdealloc(hdr_ptr)
     c                   endif
     c                   enddo
     c                   eval      hdrs = 0
     c                   eval      p_header = *NULL
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * header_find():  returns the position of a given header
      *                in the header list
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P header_find     B
     D header_find     PI            10I 0
     D   name                       256A   varying const
     D   pos                         10I 0 value

     D x               s             10I 0
     D count           s             10I 0
     D found           s             10I 0

     c                   eval      count = 0
     c                   eval      found = 0

     c     1             do        hdrs          x
     c     x             occur     hdr

     c                   if        hdr_name = name
     c                   eval      count = count + 1
     c                   if        count = pos
     c                   eval      found = x
     c                   leave
     c                   endif
     c                   endif

     c                   enddo

     c                   return    found
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * skipWhiteSpaces: skips whhite spaces starting at a given
      *                  position
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P skipWhiteSpaces...
     P                 B
     D skipWhiteSpaces...
     D                 PI            10I 0
     D   buffer                   32500A   const  options(*varsize)
     D   len                         10I 0 value
     D   pos                         10I 0 value

     D p               s             10I 0

     c                   eval      p = pos

     c                   dow       (p <= len and
     c                              isWhiteSpace(%subst(buffer: p: 1)))
     c                   eval      p = p + 1
     c                   enddo

     c                   return    p
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * isWhiteSpace: returns true if a given character is a
      *               white space character, else false.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P isWhiteSpace    B
     D isWhiteSpace    PI              N
     D   char                         1A   const

      * SPACE, HTAB, VTAB, FF, CR, LF, IFS, IGS, IRS, IUS
     D whiteSpaces     c                   const(x'40050B0C0D251C1D1E1F')

     c                   if        (%scan(char: whiteSpaces) = 0)
     c                   return    *OFF
     c                   endif

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * skipToSubType: skips to the sub type of a given header
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P skipToSubType...
     P                 B
     D skipToSubType...
     D                 PI            10I 0
     D   buffer                   32500A   const  options(*varsize)
     D   len                         10I 0 value
     D   pos                         10I 0 value

     D p               s             10I 0

     c                   eval      p = pos
     c                   dow       (p < len and
     c                              %subst(buffer: p: 1) <> '/' and
     c                              %subst(buffer: p: 1) <> ';')
     c                   eval      p = p + 1
     c                   enddo

     c                   return    p
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * removeQuotes: removes the quotes from a quoted string
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P removeQuotes...
     P                 B
     D removeQuotes...
     D                 PI         32500A   varying
     D   string                   32500A   const  options(*varsize)
     D   len                         10I 0 const
     D   quote                        1A   const  options(*nopass)

     D q               s              1A   inz('"')

     c                   if        (%parms() >= 3)
     c                   eval      q = quote
     c                   endif

     c                   if        (len < 2)
     c                   return    ''
     c                   endif

     c                   if        (%subst(string:1:1) <> q or
     c                              %subst(string: len: 1) <> q)
     c                   return    string
     c                   endif

     c                   if        (len = 2)
     c                   return    ''
     c                   endif

     c                   return    %subst(string: 2: len-2)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_header():  retrieve the value of an HTTP header
      *
      *      name = (input) name of header to look for
      *       pos = (input/optional) position of header if there's
      *                 more than one with the same name
      *
      * returns the value of the HTTP header, or '' if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_header     B                   export
     D http_header     PI         32500A   varying
     D   name                       256A   varying const
     D   pos                         10I 0 value options(*nopass)

     D lname           s            256a   varying
     D p               s             10I 0 inz(1)
     D found           s             10I 0

     c                   if        %parms >= 2
     c                   eval      p = pos
     c                   endif

     c                   eval      lname = name
     c     upper:lower   xlate     lname         lname

     c                   eval      found = header_find(lname: p)
     c                   if        found < 1
     c                   return    ''
     c                   endif

     c     found         occur     hdr
     c                   if        hdr_len = 0
     c                   return    ''
     c                   else
     c                   eval      p_header = hdr_ptr
     c                   return    %subst(header:1:hdr_len)
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_getContentType():  returns the content type of the
      *                         HTTP response stream
      *
      * returns the content type of the HTTP stream, or '' if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_getContentType...
     P                 B                   export
     D http_getContentType...
     D                 PI         32500A   varying

     D found           s             10I 0
     D s               s             10I 0
     D i               s             10I 0

     c                   eval      found = header_find('content-type': 1)
     c                   if        found < 1
     c                   return    ''
     c                   endif

     c     found         occur     hdr
     c                   if        hdr_len = 0
     c                   return    ''
     c                   endif

     c                   eval      p_header = hdr_ptr

      *  skip white spaces
     c                   eval      i = skipWhiteSpaces(header: hdr_len: 1)
     c                   if        (i > hdr_len)
     c                   return    ''
     c                   endif

      *  skip to subtype
     c                   eval      s = i
     c                   eval      i = skipToSubType(header: hdr_len: i)

     c                   if        (i - s <= 0)
     c                   return    ''
     c                   endif

      *  return content type
     c                   return    %xlate(upper:lower:%subst(header:s:i-s))
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_getContentSubType():  returns the content sub type of the
      *                            HTTP response stream
      *
      * returns the content sub type of the HTTP stream, or '' if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_getContentSubType...
     P                 B                   export
     D http_getContentSubType...
     D                 PI         32500A   varying

     D found           s             10I 0
     D s               s             10I 0
     D i               s             10I 0

     c                   eval      found = header_find('content-type': 1)
     c                   if        found < 1
     c                   return    ''
     c                   endif

     c     found         occur     hdr
     c                   if        hdr_len = 0
     c                   return    ''
     c                   endif
     c                   eval      p_header = hdr_ptr

      *  skip white spaces
     c                   eval      i = skipWhiteSpaces(header: hdr_len: 1)
     c                   if        (i > hdr_len)
     c                   return    ''
     c                   endif

      *  skip to subtype
     c                   eval      i = skipToSubType(header: hdr_len: i) + 1
     c                   if        (i > hdr_len)
     c                   return    ''
     c                   endif

      *  skip to end of sub type
     c                   eval      s = i
     c                   dow       (i < hdr_len and
     c                              %subst(header: i: 1) <> ';' and
     c                              %subst(header: i: 1) <> ',')
     c                   eval      i = i + 1
     c                   enddo

     c                   if        (i > hdr_len)
     c                   return    ''
     c                   endif

      *  return content sub type
     c                   return    %xlate(upper:lower:%subst(header:s:i-s))
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_getContentAttr(): returns the value of the specified
      *                        attribute of the content type header
      *                        of the HTTP response stream
      *
      *      attr = (input) name of content-type header attribute to look for
      *
      * returns the value of the content-type header attribute, or '' if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_getContentTypeAttr...
     P                 B                   export
     D http_getContentTypeAttr...
     D                 PI         32500A   varying
     D   attr                       256A   varying const

     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_delimiters                   *   value  options(*string)

     D strlen...
     D                 PR            10U 0 extproc('strlen')
     D  i_string                       *   value

     D found           s             10I 0
     D pToken          s               *
     D token           s          32500A   based(pToken)
     D i               s             10I 0
     D s               s             10I 0
     D len             s             10I 0
     D attr_name       s                   like(attr)

     c                   eval      found = header_find('content-type': 1)
     c                   if        found < 1
     c                   return    ''
     c                   endif

     c     found         occur     hdr
     c                   if        hdr_len = 0
     c                   return    ''
     c                   endif
     c                   eval      p_header = hdr_ptr

      *  spin through all parts of the header, start with 2. token
      *  (first token is content type and content sub type)
     c                   eval      pToken =
     c                                strtok(%subst(header: 1: hdr_len): ';')
     c                   eval      pToken = strtok(*NULL: ';')

     c                   dow       (pToken <> *NULL)
     c                   eval      attr_name = ''
     c                   eval      len = strlen(pToken)
      *  skip white spaces
     c                   eval      i = skipWhiteSpaces(token: len: 1)
     c                   dow       (i <= len and %subst(token: i: 1) <> '=')
     c                   eval      attr_name = attr_name + %subst(token: i: 1)
     c                   eval      i = i + 1
     c                   enddo

     c                   if        (%xlate(upper: lower: attr_name) = attr)
     c                   eval      i = i + 1
     c                   eval      s = i
      *  skip to end of value or white spaces
     c                   dow       (i <= len and (
     c                              %subst(token: i: 1) <> ';') and
     c                              not isWhiteSpace(%subst(token: i: 1)))
     c                   eval      i = i + 1
     c                   enddo
     c                   if        (i-s <= 0)
     c                   return    ''
     c                   else
     c                   return    removeQuotes(%subst(token: s: i-s): i-s)
     c                   endif
     c                   endif

     c                   eval      pToken = strtok(*NULL: ';')
     c                   enddo

     c                   return    ''
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Parse the cookies in the HTTP headers and load them into
      * the cookie list.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P header_load_cookies...
     P                 B                   export
     D header_load_cookies...
     D                 PI
     D   req_domain                 256A   varying const
     D   req_path                   256A   varying const

     D fd              s             10I 0

     D x               s             10I 0
     D rawCookie       s          32750A   varying
     D cookie          s                   like(cookie_data)
     D temp_domain     s            256a   varying

     c                   eval      temp_domain = '.' + req_domain
     c                   callp     http_dmsg('header_load_cookies() entered')

     c                   if        cookie_file <> ''
     c                   callp     cookie_read(cookie_file)
     c                   endif

     c                   eval      x = 1
     c                   eval      rawCookie = http_header('set-cookie':x)

     c                   dow       rawCookie <> ''

     c                   callp     cookie_parse( req_path
     c                                         : temp_domain
     c                                         : rawCookie
     c                                         : cookie )

     c                   if        cookie_reject( cookie
     c                                          : temp_domain
     c                                          : req_path ) = *OFF
     c                   callp     cookie_set( cookie )
     c                   endif

     c                   eval      x = x + 1
     c                   eval      rawCookie = http_header('set-cookie':x)
     c                   enddo

     c                   if        cookie_file <> ''
     c                   callp     cookie_dump(cookie_file)
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This parses a cookie into a cookie data structure.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_parse    B
     D cookie_parse    PI
     D   dft_path                   256A   varying const
     D   dft_domain                 256A   varying const
     D   cookie                   32500A   varying const
     D   data                              like(cookie_data)

     D p_save          s               *
     D state           s             10I 0
     D count           s             10I 0
     D name            s                   like(cd_name)
     D value           s                   like(cd_value)
     D pos             s             10I 0
     D ch              s              1A
     D len             s             10I 0

     c                   callp     http_dmsg('cookie_parse() entered')
     c                   callp     http_dmsg('cookie = ' + cookie)

     c                   eval      p_save = p_cookie_data
     c                   eval      p_cookie_data = %addr(data)
     c                   eval      state      = 0
     c                   eval      count      = 0
     c                   eval      name       = ''
     c                   eval      value      = ''
     c                   callp     cookie_reset(data)
     c                   eval      cd_domain  = dft_domain
     c                   eval      cd_path    = dft_path
     c                   time                    cd_recv

     c                   eval      len = %len(cookie)
     c     1             do        len           pos

     c                   eval      ch = %subst(cookie:pos:1)

      *************************************************
      * State 0: skipping whitespace until the
      * start of the attribute name.
      *************************************************
     c                   select
     c                   when      state = 0
     c                   if        ch <> ' '
     c                   eval      name = ch
     c                   eval      value = ''
     c                   eval      state = 1
     c                   endif

      *************************************************
      * State 1: Reading the attribute name
      *************************************************
     c                   when      state = 1

     c                   select
     c                   when      ch = '='
     c                   eval      state = 2
     c                   when      ch = ';' or ch = ','
     c                   callp     cookie_attr(count: name: value)
     c                   eval      state = 0
     c                   other
     c                   eval      name = name + ch
     c                   endsl

      *************************************************
      * State 2: Reading the start of the attribute
      *          and checking for a quoted value
      *************************************************
     c                   when      state = 2

     c                   select
     c                   when      ch = '"'
     c                   eval      state = 4
     c                   when      ch = ';'
     c                   callp     cookie_attr(count: name: value)
     c                   eval      state = 0
     c                   other
     c                   eval      value = ch
     c                   eval      state = 3
     c                   endsl

      *************************************************
      *  state 3: reading the remainder of the
      *           attribute value
      *************************************************
     c                   when      state = 3

     c                   select
     c                   when      ch = ';'
     c                   callp     cookie_attr(count: name: value)
     c                   eval      state = 0
     c                   other
     c                   eval      value = value + ch
     c                   endsl

      *************************************************
      *  state 4: reading until next quote found
      *************************************************
     c                   when      state = 4

     c                   select
     c                   when      ch = '"'
     c                   eval      state = 3
     c                   other
     c                   eval      value = value + ch
     c                   endsl

     c                   endsl

     c                   enddo

     c                   callp     cookie_attr(count: name: value)

     c                   eval      p_cookie_data = p_save
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Reset all fields in cookie to their default values.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_reset    B
     D cookie_reset    PI
     D   data                              like(cookie_data)

     D p_save          s               *

     c                   eval      p_save = p_cookie_data
     c                   eval      p_cookie_data = %addr(data)

     c                   eval      cd_version = '0'
     c                   eval      cd_name    = ''
     c                   eval      cd_lcname  = ''
     c                   eval      cd_value   = ''
     c                   eval      cd_expires = *loval
     c                   eval      cd_domain  = ''
     c                   eval      cd_path    = ''
     c                   eval      cd_secure  = *off
     c                   eval      cd_gotpath = *off
     c                   eval      cd_gotdom  = *off
     c                   eval      cd_temp    = *on
     c                   eval      cd_recv    = *loval

     c                   eval      p_cookie_data = p_save
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Set cookie attribute
      *  This is only intended to be called by cookie_parse()
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_attr     B
     D cookie_attr     PI
     D   count                       10I 0
     D   name                              like(cd_name)
     D   value                             like(cd_value)

     D offset          s             10I 0
     D lcname          s                   like(cd_name) static

     c                   eval      count = count + 1
     c                   eval      lcname = name
     c     upper:lower   xlate     lcname        lcname

     c                   callp     http_dmsg('cookie attr ' + name
     c                                               + '=' + value )
      *****************************
      * cookie's name & value
      *****************************
     c                   select
     c                   when      count = 1
     c                   eval      cd_name   = name
     c                   eval      cd_lcname = lcname
     c                   eval      cd_value  = value

      ****************************
      * cookie spec version number
      ****************************
     c                   when      lcname = 'version'
     c                   eval      cd_version = value

      ****************************
      * is this a secure cookie?
      ****************************
     c                   when      lcname = 'secure'
     c                   eval      cd_secure = *on

      ****************************
      * domain specified
      ****************************
     c                   when      lcname = 'domain'
     c                   eval      cd_domain = value
     c                   eval      cd_gotdom = *on

      ****************************
      * path specified
      ****************************
     c                   when      lcname = 'path'
     c                   eval      cd_path = value
     c                   eval      cd_gotpath = *on

      ****************************
      * expiration age (version 1)
      ****************************
     c                   when      lcname = 'max-age'

     c                   eval      offset = atoi(value)
     c                   if        offset < 1
     c                   eval      cd_expires = *loval
     c                   else
     c                   time                    cd_expires
     c                   adddur    offset:*S     cd_expires
     c                   endif
     c                   eval      cd_temp  = *off

      ****************************
      * expiration timestamp
      ****************************
     c                   when      lcname = 'expires'
     c                   eval      cd_expires = cookie2ts(value)
     c                   eval      cd_temp  = *off

      ****************************
      * comment about cookie
      ****************************
     c                   when      lcname = 'comment'
     C**                 IGNORED FOR NOW...

     c                   endsl

      /if defined(DEBUG_COOKIES)
     c                   eval      cd_temp = *OFF
     c                   eval      cd_expires = *hival
      /endif

     c                   eval      name = ' '
     c                   eval      value = ' '
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Convert a cookie timestamp to an RPG timestamp
      *   and convert it to the current time zone
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie2ts       B
     D cookie2ts       PI              Z
     D   cookie                      50A   varying value

     D CEEUTCO         PR                  ExtProc('CEEUTCO')
     D   hours                       10I 0
     D   minutes                     10I 0
     D   seconds                      8F
     D   feedback                    12A   options(*omit)

     D junk1           s             10I 0
     D junk2           s             10I 0
     D junk3           s              8F
     D utc_offset      s             10I 0 static inz(*hival)

     D day             s             10A   varying
     D mon             s             15A   varying
     D year            s             10A   varying
     D hour            s             10A   varying
     D min             s             10A   varying
     D sec             s             10A   varying
     D tz              s             10A   varying

     D result          s               Z

     D parsed          ds
     D  yyyy                          4S 0
     D  sep1                          1A   inz('-')
     D  mm                            2S 0
     D  sep2                          1A   inz('-')
     D  dd                            2S 0
     D  sep3                          1A   inz('-')
     D  hh                            2S 0
     D  sep4                          1A   inz('.')
     D  mi                            2S 0
     D  sep5                          1A   inz('.')
     D  ss                            2S 0
     D  sep6                          1A   inz('.')
     D  milli                         6S 0 inz(0)

     D len             s             10I 0
     D state           s             10I 0
     D pos             s             10I 0
     D found           s             10I 0
     D ch              s              1A
     D NUMBERS         c                   '0123456789'

     c     lower:upper   xlate     cookie        cookie

      *********************************************************
      * Loop through the timestamp character by character, and
      * save the results of everything we find
      *********************************************************
     c                   eval      len = %len(cookie)
     c     1             do        len           pos

     c                   eval      ch = %subst(cookie:pos:1)

      *******************************************
      * State 0:  Skipping over the (irrelevant)
      *           day of week
      *******************************************
     c                   select
     c                   when      state = 0

     c                   if        ch = ','
     c                   eval      state = 1
     c                   endif

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      day = ch
     c                   eval      state = 1
     c                   endif

      *******************************************
      * State 1: Reading the "day of month"
      *          (2-digit number)
      *******************************************
     c                   when      state = 1

     c                   if        ch = ' ' and day = *blanks
     c                   iter
     c                   endif

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      day = day + ch
     c                   else
     c                   eval      state = 2
     c                   endif

      *******************************************
      * State 2: Reading the month name
      *          (3-char abbreviation)
      *******************************************
     c                   when      state = 2

     c                   if        ch = ' ' and mon = *blanks
     c                   iter
     c                   endif

     C     UPPER         check     ch            Found
     c                   if        found = 0
     c                   eval      mon = mon + ch
     c                   else
     c                   eval      state = 3
     c                   endif

      *******************************************
      * State 3: Reading the year
      *          (2 or 4 digit number)
      *******************************************
     c                   when      state = 3

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      year = year + ch
     c                   else
     c                   eval      state = 4
     c                   endif

      *******************************************
      * State 4: reading the hour
      *******************************************
     c                   when      state = 4

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      hour = hour + ch
     c                   else
     c                   eval      state = 5
     c                   endif

      *******************************************
      * State 5: reading the minutes
      *******************************************
     c                   when      state = 5

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      min = min + ch
     c                   else
     c                   eval      state = 6
     c                   endif

      *******************************************
      * State 6: reading the seconds
      *******************************************
     c                   when      state = 6

     C     NUMBERS       check     ch            Found
     c                   if        found = 0
     c                   eval      sec = sec + ch
     c                   else
     c                   eval      state = 7
     c                   endif

      *******************************************
      * State 7: reading the time zone
      *******************************************
     c                   when      state = 7
     c                   eval      tz = tz + ch
     c                   endsl

     c                   enddo

      *********************************************************
      *  Check it out... make sure everything is legal
      *********************************************************
     c                   eval      result = *loval

     c                   select
     c                   when      mon = 'JAN' or mon = 'JANUARY'
     c                   eval      mm = 1
     c                   when      mon = 'FEB' or mon = 'FEBRUARY'
     c                   eval      mm = 2
     c                   when      mon = 'MAR' or mon = 'MARCH'
     c                   eval      mm = 3
     c                   when      mon = 'APR' or mon = 'APRIL'
     c                   eval      mm = 4
     c                   when      mon = 'MAY' or mon = 'MAI'
     c                   eval      mm = 5
     c                   when      mon = 'JUN' or mon = 'JUNE'
     c                   eval      mm = 6
     c                   when      mon = 'JUL' or mon = 'JULY'
     c                   eval      mm = 7
     c                   when      mon = 'AUG' or mon = 'AUGUST'
     c                   eval      mm = 8
     c                   when      mon = 'SEP' or mon = 'SEPTEMBER'
     c                   eval      mm = 9
     c                   when      mon = 'OCT' or mon = 'OCTOBER'
     c                   eval      mm = 10
     c                   when      mon = 'NOV' or mon = 'NOVEMBER'
     c                   eval      mm = 11
     c                   when      mon = 'DEC' or mon = 'DECEMBER'
     c                   eval      mm = 12
     c                   other
     c                   return    result
     c                   endsl

     c                   eval      dd = atoi(day)
     c                   if        dd < 1 or dd > 31
     c                   return    result
     c                   endif

     c                   eval      yyyy = atoi(year)
     c                   if        yyyy < 0
     c                   return    result
     c                   endif

     c                   if        yyyy < 100
     c                   if        yyyy < 70
     c                   eval      yyyy = 2000 + yyyy
     c                   else
     c                   eval      yyyy = 1900 + yyyy
     c                   endif
     c                   endif

     c                   eval      hh = atoi(hour)
     c                   if        hh < 0 or hh > 24
     c                   return    result
     c                   endif

     c                   eval      mi = atoi(min)
     c                   if        mi < 0 or mi > 59
     c                   return    result
     c                   endif

     c                   eval      ss = atoi(sec)
     c                   if        ss < 0 or ss > 59
     c                   return    result
     c                   endif

     c                   if        %trim(tz) <> 'GMT'
     c                   return    result
     c                   endif

     c                   test(ez)                parsed
     c                   if        %error
     c                   return    result
     c                   endif

      *********************************************************
      *  Get current timezone
      *********************************************************
     c                   if        utc_offset = *hival
     c                   callp     CEEUTCO(junk1: junk2: junk3: *omit)
     c                   eval      utc_offset = junk3
     c                   endif

      *********************************************************
      *  If everything is good, return it.
      *********************************************************
     c     *ISO          move      parsed        result
     c                   adddur    utc_offset:*S result
     c                   return    result
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * This checks to see if a cookie should be rejected
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_reject   B
     D cookie_reject   PI             1N
     D   cookie                            like(cookie_data)
     D   req_domain                 256A   varying const
     D   req_path                   256A   varying const

     c                   eval      p_cookie_data = %addr(cookie)

     c                   if        cookie_match(req_domain:req_path:*OFF)
     c                               = *OFF
     c                   callp     http_dmsg('cookie rejected, path/dom ' +
     c                                       'doesn''t match request.')
     c                   return    *ON
     c                   endif

     c                   if        cd_gotdom = *On
     c                             and %scan('.':cd_domain) = 0
     c                   callp     http_dmsg('cookie rejected, dotless domain')
     c                   return    *ON
     c                   endif

     c                   if        %len(cd_value) > 8191
     c                   callp     http_dmsg('cookie rejected, too long')
     c                   return    *ON
     c                   endif

     c                   return    *OFF
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Check to see if the domain & path match the currently
      *  loaded cookie
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_match    B
     D cookie_match    PI             1N
     D   domain                            like(cd_domain) const
     D   path                              like(cd_path) const
     D   exact                        1N   const

     D start           s             10I 0
     D len             s             10I 0

     c                   eval      len = %len(cd_path)
     c                   if        len > %len(path)
     c                   return    *OFF
     c                   endif

     c                   if        %subst(path:1:len) <> cd_path
     c                   return    *OFF
     c                   endif

     c                   if        exact = *ON
     c                             and path <> cd_path
     c                   return    *OFF
     c                   endif

     c                   eval      len = %len(cd_domain)
     c                   eval      start = (%len(domain) - len) + 1

     c                   if        start<1 or start>%len(domain)
     c                   return    *OFF
     c                   endif

     c                   if        %subst(domain:start:len)
     c                               <> cd_domain
     c                   return    *OFF
     c                   endif

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Find a cookie in the cookie cache
      *
      *        name = name of cookie to find
      *      domain = domain that cookie belongs to
      *        path = path of URLs in domain that cookie matches
      *      secure = Turn *ON if secure cookies should be returned
      *       exact = path has to be exactly the same (*ON or *OFF)
      *
      * returns a pointer to the cookie record, or *NULL if not found
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_find     B                   export
     D cookie_find     PI              *
     D   name                              like(cd_name) const
     D   domain                            like(cd_domain) const
     D   path                              like(cd_path) const
     D   secure                       1N   const
     D   exact                        1N   const

     D x               s             10I 0
     D p_save          s               *
     D current         s               Z
     D retval          s               *

     c                   time                    current
     c                   eval      p_save = p_cookie_data
     c                   eval      retval = *NULL

     c     1             do        cookie_count  x

     c                   eval      p_cookie_data = cookie_list(x)

     c                   if        cd_temp=*OFF and cd_expires<current
     c                   iter
     c                   endif

     c                   if        cd_secure = *ON
     c                             and secure = *OFF
     c                   iter
     c                   endif

     c                   if        cd_lcname = name
     c                             and cookie_match(domain:path:exact)=*ON
     c                   eval      retval = cookie_list(x)
     c                   endif

     c                   enddo

     c                   eval      p_cookie_data = p_save
     c                   return    retval
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cookie_set():  Set the value of a cookie in the cookie cache
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_set      B                   export
     D cookie_set      PI
     D    cookie                           like(cookie_data)

     D name            s                   like(cd_name)
     D dom             s                   like(cd_domain)
     D path            s                   like(cd_path)
     D x               s             10I 0
     D p_save          s               *

     D newcookie       s                   like(cookie_data)
     D                                     based(match)

      **
      **  Extract the name, domain, and path from the cookie
      **
     c                   eval      p_save = p_cookie_data
     c                   eval      p_cookie_data = %addr(cookie)

     c                   eval      name = cd_lcname
     c                   eval      dom  = cd_domain
     c                   eval      path = cd_path

      **
      **  If this cookie already exists, replace it.
      **  otherwise, allocate a new one.
      **
     c                   eval      match = cookie_find( name
     c                                                : dom
     c                                                : path
     c                                                : *ON
     c                                                : *ON )

     c                   if        match = *NULL
     c                   eval      match = cookie_alloc
     c                   endif

     c                   if        match <> *NULL
     c                   eval      newcookie = cookie
     c                   endif

     c                   eval      p_cookie_data = p_save
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cookie_alloc(): Allocate a new cookie in the cookie cache
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_alloc    B                   export
     D cookie_alloc    PI              *

     D x               s             10I 0
     D p_save          s               *
     D current         s               Z
     D oldest          s               Z   inz(*hival)
     D p_oldest        s               *   inz(*NULL)
     D retval          s               *
     D size            s             10I 0

      **
      ** Check for an expired cookie to re-use
      **
     c                   time                    current

     c     1             do        cookie_count  x

     c                   eval      p_cookie_data = cookie_list(x)
     c                   if        cd_temp=*OFF and cd_expires<current
     c                   eval      retval = cookie_list(x)
     c                   leave
     c                   endif

     c                   if        cd_recv < oldest
     c                   eval      oldest = cd_recv
     c                   eval      p_oldest = cookie_list(x)
     c                   endif

     c                   enddo

      **
      ** Check if there's room for a new cookie in the cache
      **
     c                   if        retval = *NULL
     c                   if        cookie_count < %elem(cookie_list)
     c                   eval      size = %size(cookie_data)
     c                   eval      retval = xalloc(size)
     c                   eval      cookie_count = cookie_count + 1
     c                   eval      cookie_list(cookie_count) = retval
     c                   endif
     c                   endif

      **
      ** If the cache is full _and_ there's no expired cookies
      ** then re-use the oldest one.
      **
     c                   if        retval = *NULL
     c                   eval      retval = p_oldest
     c                   endif

     c                   return    retval
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cookie_dunp(): Dump the cookie cache to disk
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_dump     B                   export
     D cookie_dump     PI             1N
     D   filename                   256A   varying const
     D fd              s             10I 0
     D x               s             10I 0
     D current         s               Z
     D p_save          s               *

     c                   callp     http_dmsg('cookie_dump() entered.')
     c                   callp     http_dmsg('cookie file is ' + filename)

     c                   eval      fd = open( %trimr(filename)
     c                                      : O_CREAT+O_TRUNC+O_WRONLY
     c                                      : S_IRUSR+S_IWUSR )
     c                   if        fd < 0
     c                   callp     SetError(HTTP_CKDUMP
     c                                     : %str(strerror(errno)))
     c                   return    *OFF
     c                   endif

     c                   time                    current
     c                   eval      p_save = p_cookie_data

     C     1             do        cookie_count  x

     c                   eval      p_cookie_data = cookie_list(x)

     c                   if        cd_temp = *ON
     c                             and dump_session = *OFF
     c                   iter
     c                   endif

     c                   if        cd_temp = *off
     c                             and cd_expires<current
     c                   iter
     c                   endif

     c                   callp     cookie_write(fd)
     c                   enddo

     c                   callp     close(fd)
     c                   eval      p_cookie_data = p_save
     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * header_get_req_cookies(): Get the cookies to be sent back in
      *      a given request header
      *
      *    Host = (input) host that request is being made to
      *    Path = (input) URL path of the request
      *  Secure = (input) is this a secure request?
      *
      * Returns the Cookie: request header, or '' if there are none
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P header_get_req_cookies...
     P                 B                   export
     D header_get_req_cookies...
     D                 PI         32767A   varying
     D   host                       256A   varying const
     D   path                     32767A   varying const
     D   Secure                       1N   const

     D myPath          s            256A   varying
     D pos             s             10I 0
     D x               s             10I 0
     D p_save          s               *
     D retval          s          32767A   varying
     D count           s             10I 0
     D current         s               Z
     D CRLF            c                   x'0d25'
     D temp_host       s            256a   varying

     c                   if        cookie_file <> ''
     c                   callp     cookie_read(cookie_file)
     c                   endif

     c                   eval      temp_host = '.' + host
     c                   eval      pos = %scan('?': path)
     c                   eval      pos = pos - 1
     c                   if        pos>0 and pos<%len(path)
     c                   eval      myPath = %subst(path:1:pos)
     c                   else
     c                   eval      myPath = path
     c                   endif

     c                   eval      p_save = p_cookie_data
     c                   eval      retval = 'Cookie:'
     c                   eval      count = 0
     c                   time                    current

     c                   callp     http_dmsg('There are '
     c                             + %trim(%editc(cookie_count:'P'))
     c                             + ' cookies in the cache')

     C     1             do        cookie_count  x

     c                   eval      p_cookie_data = cookie_list(x)

      * skip expired cookies
     c                   if        cd_temp=*OFF and cd_expires<current
     c                   callp     http_dmsg('cookie=' + cd_name
     c                                      + ' not sent (expired)')
     c                   iter
     c                   endif

      * skip secure cookies unless the connection
      * is also secure
     c                   if        cd_secure=*ON and secure=*OFF
     c                   callp     http_dmsg('cookie=' + cd_name
     c                                      + ' not sent (insecure)')
     c                   iter
     c                   endif

      * skip cookies for other domains/paths
     c                   if        cookie_match( temp_host
     c                                         : myPath
     c                                         : *OFF   ) = *OFF
     c                   callp     http_dmsg('cookie=' + cd_name
     c                                      + ' not sent (wrong path'
     c                                      + ' or domain)')
     c                   iter
     c                   endif

      *
      * Cookie string should look like this:
      *   Cookie: $Version='1'; MyCookie=Foo; $Path=/;
      *   with all cookies listed in the same string.
      *
     c                   eval      count = count + 1
     c                   eval      retval = retval + ' '
     c                                    + %char(UCS2_DOLLAR)
     c                                    + 'Version='
     c                                    + cd_version + ';'

     c                   eval      retval = retval + ' '
     c                                    + cd_name
     c                                    + '='
     c                                    + cd_value + ';'

     c                   if        cd_gotpath = *on
     c                   eval      retval = retval + ' '
     c                                    + %char(UCS2_DOLLAR)
     c                                    + 'Path='
     c                                    + cd_path + ';'
     c                   endif

     c                   if        cd_gotdom = *on
     c                   eval      retval = retval + ' '
     c                                    + %char(UCS2_DOLLAR)
     c                                    + 'Domain='
     c                                    + cd_domain + ';'
     c                   endif

     c                   enddo

     c                   if        count = 0
     c                   eval      retval = ''
     c                   else
     c                   eval      retval = retval + CRLF
     c                   endif

     c                   eval      p_cookie_data = p_save
     c                   return    retval
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Write the current cookie record to disk
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_write    B
     D cookie_write    PI            10I 0
     D   fd                          10I 0 value

     D TAB             C                   x'05'
     D CRLF            c                   x'0d25'

     D dpass           s              5A   varying
     D ppass           s              5A   varying

     D expires         ds
     D   exp                           Z
     D recvd           ds
     D   rec                           Z

     D rcd             s          32767A   varying

     c                   if        cd_gotdom = *ON
     c                   eval      dpass = 'TRUE'
     c                   else
     c                   eval      dpass = 'FALSE'
     c                   endif

     c                   if        cd_gotpath = *ON
     c                   eval      ppass = 'TRUE'
     c                   else
     c                   eval      ppass = 'FALSE'
     c                   endif

     c                   eval      exp = cd_expires
     c                   eval      rec = cd_recv

     c                   eval      rcd = cd_domain  + TAB
     c                                 + dpass      + TAB
     c                                 + cd_path    + TAB
     c                                 + ppass      + TAB
     c                                 + expires    + TAB
     c                                 + recvd      + TAB
     c                                 + cd_version + TAB
     c                                 + cd_secure  + TAB
     c                                 + cd_name    + TAB
     c                                 + cd_value

     c                   if        cd_temp = *on
     c                   eval      rcd = rcd + TAB + 'SESSION' + CRLF
     c                   else
     c                   eval      rcd = rcd + CRLF
     c                   endif

     c                   return    write(fd
     c                                  : %addr(rcd) + VARPREF
     c                                  : %len(rcd) )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Read the cookie file into memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_read     B
     D cookie_read     PI            10I 0
     D   filename                   256A   varying const

     D TAB             C                   x'05'
     D CR              c                   x'0d'
     D LF              c                   x'25'

     D fd              s             10I 0
     D statbuf         s                   like(statds)
     D char            s              1A   based(p_char)
     D size            s             10I 0
     D p_cookies       s               *
     D offset          s             10I 0
     D fieldno         s             10I 0
     D count           s             10I 0
     D field           s          32767A   varying
     D data            s                   like(cookie_data)
     D p_save          s               *

     c                   callp     http_dmsg('cookie_read(): read cookies +
     c                                         from ' + filename)

      *************************************************
      * Load the entire cookie file into memory
      *************************************************
     c                   eval      fd = open( %trimr(filename)
     c                                      : O_RDONLY )
     c                   if        fd = -1
     c                   if        errno = ENOENT
     c                   callp     http_dmsg('No cookie file found. ' +
     c                             '(This may mean that no cookies have ' +
     c                             'been received yet.)')
     c                   return    0
     c                   else
     c                   callp     SetError(HTTP_CKSTAT: 'cookie open(): '
     c                              + %str(strerror(errno)))
     c                   return    -1
     c                   endif
     c                   endif

     c                   if        fstat(fd: %addr(statbuf)) = -1
     c                   callp     SetError(HTTP_CKSTAT: 'cookie stat(): '
     c                              + %str(strerror(errno)))
     c                   return    -1
     c                   endif

     c                   eval      p_statds = %addr(statbuf)
     c                   eval      size = st_size

     c                   if        size < 2
     c                   callp     close(fd)
     c                   return    0
     c                   endif

     C                   eval      p_cookies = xalloc(size)
     c                   callp     read(fd: p_cookies: size)
     c                   callp     close(fd)

      *************************************************
      * Loop through the cookie file, loading each one
      * into the cookie cache
      *************************************************
     c                   eval      p_save = p_cookie_data
     c                   eval      p_cookie_data = %addr(data)

     c                   eval      offset = 0
     c                   eval      fieldno = 0
     c                   eval      count = 0
     c                   callp     cookie_reset(data)
     c                   eval      cd_temp = *off

     c                   dow       offset < size

     c                   eval      p_char = p_cookies + offset

      ** LF means "end of record".  At this point, add the
      ** cookie to the cookie cache
     c                   select
     c                   when      char = LF
     c                   callp     cookie_set(data)
     c                   eval      count = count + 1
     c                   eval      fieldno = 0
     c                   callp     cookie_reset(data)
     c                   eval      cd_temp = *off

      ** CR and TAB end a field.  At this point, add the field
      ** to the data structure.
     c                   when      char = CR or char = TAB
     c                   eval      fieldno = fieldno + 1
     c                   callp     cookie_readfld(fieldno: field)
     c                   eval      field = ''

      ** any other characters are part of the cookie data, and should
      ** be added to the current field.
     c                   other
     c                   eval      field = field + char
     c                   endsl

     c                   eval      offset = offset + 1
     c                   enddo

      *************************************************
      * when done, free up the memory.
      *************************************************
     C                   callp     xdealloc(p_cookies)
     C                   eval      p_cookie_data = p_save
     c                   return                  count
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * cookie_readfld(): One cookie field has been read.  Add it
      *                   to the current cookie_data DS.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cookie_readfld  B
     D cookie_readfld  PI
     D   fieldno                     10I 0 value
     D   data                     32767A   varying const

     D expires         ds
     D   exp                           Z
     D recvd           ds
     D   rec                           Z

     c                   select
     c                   when      fieldno = 1
     c                   eval      cd_domain = data

     c                   when      fieldno = 2
     c                   if        data = 'TRUE'
     c                   eval      cd_gotdom = *ON
     c                   else
     c                   eval      cd_gotdom = *OFF
     c                   endif

     c                   when      fieldno = 3
     c                   eval      cd_path = data

     c                   when      fieldno = 4
     c                   if        data = 'TRUE'
     c                   eval      cd_gotpath = *ON
     c                   else
     c                   eval      cd_gotpath = *OFF
     c                   endif

     c                   when      fieldno = 5
     c                   eval      expires = data
     c                   eval      cd_expires = exp

     c                   when      fieldno = 6
     c                   eval      recvd = data
     c                   eval      cd_recv = rec

     c                   when      fieldno = 7
     c                   eval      cd_version = data

     c                   when      fieldno = 8
     c                   eval      cd_secure = data

     c                   when      fieldno = 9
     c                   eval      cd_name = data
     c                   eval      cd_lcname = %xlate(upper:lower:cd_name)

     c                   when      fieldno = 10
     c                   eval      cd_value = data

     c                   when      fieldno = 11
     c                   if        data = 'SESSION'
     c                   eval      cd_temp = *on
     c                   endif

     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_cookie_file():  Set the name of the file that HTTPAPI
      *          will use to store cookies.
      *
      *    peFilename = (input) Filename (IFS path) to store cookie
      *                  data into.
      *     peSession = (input) include session cookies (temp cookies)
      *                  in cookie file?  Default = *OFF
      *
      *  If the filename is set to '', or if you do not call this API,
      *  cookies will only be saved until the activation group is
      *  reclaimed.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_cookie_file...
     P                 B                   export
     D http_cookie_file...
     D                 PI
     D   peFilename                 256A   varying const
     D   peSession                    1n   const options(*nopass:*omit)
     c                   eval      cookie_file  = %trim(peFilename)
     c                   eval      dump_session = *OFF
     c                   if        %parms >= 2 and %addr(peSession)<>*null
     c                   eval      dump_session = peSession
     c                   endif
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_header_count(): Returns the number of headers saved to
      *                      the activation group
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_header_count...
     P                 B                   export
     D                 PI            10i 0
     c                   return    hdrs
     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy ERRNO_H
     /*-                                                                            +
      * Copyright (c) 2001-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * HTTPAPIR4 -- Hypertext transfer protocol API
      *
      *   A suite of routines for doing HTTP from ILE programs.
      *
      *   Requires:
      *       ILE RPG/400 licensed program from IBM.  V4R2 or later.
      *
      *       Optional TLS/SSL capabilities require V4R5 or later.
      *       and require the HTTP server, Client Encryption and
      *       Digital Certificate Manger Licensed programs.
      *
      *       See the README member, included in this package for details.
      *
      *   To Compile:
      *      - Edit the CONFIG_H member to set options.
      *      CRTCLPGM INSTALL SRCFILE(libhttp/QCLSRC)
      *      CALL INSTALL
      *
      *  To Update this module (HTTPAPIR4) without running
      *     the whole install procedure:
      *
      *>      CRTRPGMOD HTTPAPIR4 SRCFILE(LIBHTTP/QRPGLESRC) DBGVIEW(*LIST) -
      *>                OPTION(*SECLVL)
      *>      UPDSRVPGM SRVPGM(LIBHTTP/HTTPAPIR4) MODULE(HTTPAPIR4) -
      *>                EXPORT(*CURRENT)
      */

      /copy VERSION

      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*NOSHOWCPY: *SRCSTMT: *NODEBUGIO)
      /endif
     H NOMAIN

      /copy NTLM_H

      /define HTTP_ORIG_SHORTFIELD
      /copy RDWR_H
      /copy HTTPAPI_H
      /copy PRIVATE_H
      /copy HEADER_H
      /copy ERRNO_H
      /copy IFSIO_H
      /copy COMM_H

      /if defined(HTTP_USE_CCSID)
     D CCSID_OR_CP     S             10I 0 inz(O_CCSID)
      /else
     D CCSID_OR_CP     S             10I 0 inz(O_CODEPAGE)
      /endif

      ***  Local procedures ***
     D do_oper         PR            10I 0
     D  peOper                       10a   varying const
     D  peSaveProc                     *   value procptr
     D  peSendProc                     *   value procptr
     D  pePostData                     *   value
     D  pePostDataLen                20I 0 value
     D  peComm                         *   value
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                 32767A   const varying options(*varsize)
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent               16384A   varying options(*omit)
     D  peContentType             16384A   varying options(*omit)
     D  peSoapAction              32767A   varying options(*omit)
     D  pePostProc                     *   value procptr
     D  pePostFD                     10I 0 value
     D  pePort                       10I 0 value
     D  peSecure                      1N   value
     D  peServ                       32A   const
     D  peExtendedCb                  1n   const

     D SendReq         PR            10I 0
     D   peComm                        *   value
     D   peData                        *   value
     D   peDataLen                   10I 0 value
     D   peTimeout                   10I 0 value

     D recvresp        PR            10I 0
     D   peComm                        *   value
     D   peRespChain              32767A   varying options(*varsize)
     D   peRespLen                   10I 0 value
     D   peTimeOut                   10P 3 value
     D   peUse100                     1N   const

     D recvdoc         PR            10I 0
     D   peComm                        *   value
     D   peProcedure                   *   value procptr
     D   peFD                        10I 0 value
     D   peTimeout                   10I 0 value
     D   peCLen                      10U 0 value
     D   peUseCL                      1N   const

     D recvchunk       PR            10I 0
     D   peComm                        *   value
     D   peProcedure                   *   value procptr
     D   peFD                        10I 0 value
     D   peTimeout                   10I 0 value

     D SendDoc         PR            10I 0
     D  peComm                         *   value
     D  pePostData                     *   value
     D  pePostDataLen                20I 0 value
     D  peTimeout                    10I 0 value
     D  peUnused1                      *   value procptr
     D  peUnused2                    10I 0 value

     D SendRaw         PR            10I 0
     D  peComm                         *   value
     D  peUnused1                      *   value
     D  peDataSize                   20I 0 value
     D  peTimeout                    10I 0 value
     D  pePostProc                     *   value procptr
     D  pePostFD                     10I 0 value

     d get_chunk_size  PR            10I 0
     d   peComm                        *   value
     d   peTimeout                   10I 0 value

     D interpret_auth  PR
     D   peRespChain               2048A   const
     D   peKwdPos                    10I 0 value
     D   peResetAuth                   N   value

     D interpret_proxy_auth...
     D                 PR
     D   peRespChain               2048A   const
     D   peKwdPos                    10I 0 value

     D mkdigest        PR         32767A   varying
     D   peMethod                    10A   varying const
     D   peURI                    32767A   varying const options(*varsize)

     D parse_resp_chain...
     D                 PR            10I 0
     D  peRespChain               32767A   varying const
     D  peRC                         10I 0
     D  peTE                         32A
     D  peCLen                       10u 0
     D  peUseCL                       1N
     D  peAuthErr                     1N
     D  peProxyAuthErr...
     D                                1N
     D  peHost                      256A   varying const
     D  pePath                      256A   varying const

     D setUrlAuth      PR
     D   peUsername                  80A   const
     D   pePasswd                  1024A   const

     D upload_sts      PR                  ExtProc(wkUplProc)
     D   peBytesSent                 10U 0 value
     D   peBytesTot                  10U 0 value
     D   peUserData                    *   value

     D download_sts    PR                  ExtProc(wkDwnlProc)
     D   peBytesSent                 10U 0 value
     D   peBytesTot                  10U 0 value
     D   peUserData                    *   value

     D addl_headers    PR                  ExtProc(wkAddHdrProc)
     D   peAddlHdrs               32767A   varying
     D   peUserData                    *   value

     D parse_hdrs      PR                  ExtProc(wkParseHdrProc)
     D   peHdrData                 2048A   const
     D   peUserData                    *   value

     D parse_hdr_long  PR                  ExtProc(wkParseHdrLong)
     D   peHdrData                32767A   const varying
     D   peUserData                    *   value

     D proxy_tunnel    PR            10I 0
     D   peComm                        *   value
     D   peServ                      32a   const
     D   peHost                     256a   const
     D   pePort                      10i 0 value
     D   peTimeout                   10i 0 value

     D getSA           PR         16384A   varying
     D                                     ExtProc('GETREALSA')
     D   peSoapAction                 2a   const
     D getRealSA       PR         16384A   varying
     D   peSoapAction                 2a

     D Buffer_t        ds                  qualified
     D                                     based(TEMPLATE)
     D   Len                         10u 0
     D   Data                          a   len(16000000)

     D getBufferInfo_REAL...
     D                 PR
     D   Buf                               likeds(Buffer_t)
     D   DataPtr                       *
     D   DataLen                     20i 0

     D getBufferInfo   PR                  extproc('GETBUFFERINFO_REAL')
     D   Buf                           a   varying len(16000000)
     D                                     const options(*omit:*varsize)
     D   DataPtr                       *
     D   DataLen                     20i 0

     D rcvToBuf        PR            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10i 0 value

     D ValidateRDWR    PR            10i 0
     D   handle                            like(RDWR_HANDLE) value
     D   Usage                        3u 0 value

     D http_redir_loc_long...
     D                 PR         32767A   varying

      ***  Global Constants  ***

     D CRLF            C                   CONST(x'0d25')
     D upper           C                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           C                   'abcdefghijklmnopqrstuvwxyz'
     D SEND_CHUNK_SIZE...
     D                 C                   CONST(8192)

      ***  Global Variables  ***

     D wkRedirLoc      s          32767A   varying inz('')

     D dsAuth          DS
     D   dsAuthType                   1A   inz(HTTP_AUTH_NONE)
     D   dsAuthBasic                  1N   inz(*OFF)
     D   dsAuthDigest                 1N   inz(*OFF)
     D   dsAuthRealm                124A
     D   dsAuthNonce                128A
     D   dsAuthOpaque               128A
     D   dsAuthQOP                   32A
     D   dsAuthCnonce                16A
     D   dsAuthNC                     7P 0 inz(0)
     D   dsAuthUser                  80A
     D   dsAuthPasswd              1024A
     D   dsAuthStr                16384A   varying inz('')

     D dsProxyAuth     DS
     D   dsProxyAuthType...
     D                                1A   inz(HTTP_AUTH_NONE)
     D   dsProxyAuthBasic...
     D                                1N   inz(*OFF)
     D   dsProxyAuthRealm...
     D                              124A
     D   dsProxyAuthUser...
     D                               80A
     D   dsProxyAuthPasswd...
     D                             1024A
     D   dsProxyAuthStr...
     D                             1476A   varying inz('')

     D dsProxy         DS
     D   dsProxyHost               2048A   inz(*blanks)
     D   dsProxyPort                 10I 0 inz(*zeros)
     D   dsProxyTun                   1N   inz(*off)

     D wkSaveAuth      s                   like(dsAuth)

     D wkUplProc       S               *   procptr inz(*NULL)
     D wkUplUdata      S               *   inz(*NULL)
     D wkDwnlProc      S               *   procptr inz(*NULL)
     D wkDwnlUdata     S               *   inz(*NULL)
     D wkAddHdrProc    S               *   procptr inz(*NULL)
     D wkAddHdrData    S               *   inz(*NULL)
     D wkParseHdrProc  S               *   procptr inz(*NULL)
     D wkParseHdrData  S               *   inz(*NULL)
     D wkParseHdrLong  S               *   procptr inz(*NULL)
     D wkParseHdrLongData...
     D                 S               *   inz(*NULL)

     D RcvStrBuf       ds                  qualified
     D   Size                        10u 0 inz(0)
     D   Len                         10u 0 inz(0)
     D   Ptr                           *   inz(*null)

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Close HTTP connection
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_close      B                   export
     D http_close      PI            10I 0
     D  peSock                       10I 0 value
     D  peComm                         *   value

     c                   callp     http_dmsg('http_close(): entered')

     c                   if        %parms < 2
     c                   callp     SetError(HTTP_NOTSUPP
     c                                     : ' using old format of '
     c                                     + 'http_close')
     c                   return    -1
     c                   endif

     c                   callp     http_dclose

     c                   if        peComm <> *null
     c                   eval      p_commdriver = peComm
     c                   if        comm_hangup ( peComm ) = *off
     c                   return    -1
     c                   endif
     c                   callp     comm_cleanup( peComm )
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs at close')
      /endif

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * do_oper():  Perform HTTP operation
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P do_oper         B
     D do_oper         PI            10I 0
     D  peOper                       10a   varying const
     D  peSaveProc                     *   value procptr
     D  peSendProc                     *   value procptr
     D  pePostData                     *   value
     D  pePostDataLen                20I 0 value
     D  peComm                         *   value
     D  peFile                       10I 0 value
     D  peTimeout                    10I 0 value
     D  peAbsPath                 32767A   const varying options(*varsize)
     D  peHost                      256A   const
     D  peModTime                      Z   options(*omit)
     D  peUserAgent               16384A   varying options(*omit)
     D  peContentType             16384A   varying options(*omit)
     D  peSoapAction              32767A   varying options(*omit)
     D  pePostProc                     *   value procptr
     D  pePostFD                     10I 0 value
     D  pePort                       10I 0 value
     D  peSecure                      1N   value
     D  peServ                       32A   const
     D  peExtendedCb                  1n   const

     D SendProc        PR            10I 0 extproc(peSendProc)
     D  peComm                         *   value
     D  pePostData                     *   value
     D  pePostDataLen                20I 0 value
     D  peTimeout                    10I 0 value
     D  pePostProc                     *   procptr value
     D  pePostFD                     10I 0 value

     D wwReqChain      S          32767A   varying
     D wwRespChain     S          32767A   varying
     D wwAddlHdr       s          32767A   varying
     D wwModString     S             29A
     D rc              S             10I 0
     D wwPos           S             10I 0
     D wwPos2          S             10I 0
     D wwTE            S             32A
     D wwAuthErr       S              1N   inz(*OFF)
     D wwProxyAuthErr...
     D                 S              1N   inz(*OFF)
     D wwCLen          S             10U 0
     D wwCL            S             32A
     D wwUseCL         s              1N
     D wwFinRC         S             10I 0
     D wwErrorNo       s             10I 0
     D wwErrorMsg      s                   like(http_error)
     D wwErr           s             10I 0
     d wwPathPfx       s           1024A   varying
     D wwSendReqBody   s              1n   inz(*off)

     D wwSaveProc      s                   like(peSaveProc) inz
     D wwFile          s                   like(peFile    ) inz

     c                   callp     http_dmsg( 'do_oper(' + peOper + '): '
     c                                      + 'entered')
     c                   eval      p_global = getGlobalPtr()

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs do_oper start')
      /endif

     c                   if        peExtendedCB = *off
     c                   eval      RDWR_Reader_p = *null
     c                   eval      RDWR_Writer_p = *null
     c                   endif

     C*********************************************************
     C* Determine whether there's a message body to upload
     C* with the request
     C*********************************************************
     c                   if        pePostDataLen >= 0 and
     c                             (pePostData<>*null or pePostProc<>*null)
     c                   eval      wwSendReqBody = *on
     c                   endif

     C*********************************************************
     C*  Build an HTTP/1.1 request chain:
     C*********************************************************
     c* If Connection is done via Proxy, an URI instead of just the path has to be sent.
     c                   if        dsProxyHost <> *blanks
     c                               and dsProxyTun = *Off
     c                   eval      wwPathPfx = %trim(peServ) + '://' +
     c                             %trim(peHost)
     c                   if        pePort <> 0
     c                   eval      wwPathPfx = wwPathPfx + ':' +
     c                                        %trim(%editc(pePort:'L'))
     c                   endif
     c                   else
     c                   eval      wwPathPfx = ''
     c                   endif

     c                   eval      wwReqChain = peOper + ' '
     c                             + wwPathPfx + %trim(peAbsPath)
     c                             + ' HTTP/1.1' + CRLF
     c                             + 'Host: ' + %trim(peHost)

     c                   if        pePort = 0
     c                   eval      wwReqChain = wwReqChain + CRLF
     c                   else
     c                   eval      wwReqChain = wwReqChain + ':'
     c                                        + %trim(%editc(pePort:'L'))
     c                                        + CRLF
     c                   endif

     c                   if        %addr(peModTime) <> *NULL
     c                   eval      wwModString = httpdate(peModTime)
     c                   eval      wwReqChain = wwReqChain +
     c                             'If-Modified-Since: '+wwModString+CRLF
     c                   endif

     c                   if        %addr(peUserAgent)<>*NULL
     c                   if        peUserAgent <> *blanks
     c                   eval      wwReqChain = wwReqChain +
     c                             'User-Agent: '+%trimr(peUserAgent)+CRLF
     c                   endif
     c                   else
     c                   eval      wwReqChain = wwReqChain +
     c                             'User-Agent: ' + HTTP_USERAGENT + CRLF
     c                   endif

     c                   if        wwSendReqBody = *on
     c                   if        %addr(peContentType) <> *NULL
     c                   if        peContentType <> *blanks
     c                   eval      wwReqChain = wwReqChain +
     c                             'Content-Type: '+%trimr(peContentType)+
     c                             CRLF
     c                   endif
     c                   else
     c                   eval      wwReqChain = wwReqChain +
     c                             'Content-Type: ' + HTTP_CONTTYPE + CRLF
     c                   endif
     c                   endif

     c                   if        %len(global.acceptHdr) > 0
     c                   eval      wwReqChain = wwReqChain +
     c                             'Accept: ' + global.acceptHdr + CRLF
     c                   endif

     c                   if        %addr(peSOAPAction) <> *NULL
     c                   if        %len(peSOAPAction)>0
     c                              and peSoapAction<>*blanks
     c                   eval      wwReqChain = wwReqChain +
     c                             'SOAPAction: ' +%trimr(peSOAPAction)+
     c                             CRLF
     c                   else
     c                   eval      wwReqChain = wwReqChain +
     c                             'SOAPAction:  ' + CRLF
     c                   endif
     c                   endif

     c                   if        wwSendReqBody=*on and global.timeout100>0
     c                   eval      wwReqChain = wwReqChain +
     c                             'Expect: 100-continue' + CRLF
     c                   endif

     c                   if        wwSendReqBody = *on
     c                   eval      wwReqChain = wwReqChain +
     c                             'Content-Length: ' +
     c                             %trim(%editc(pePostDataLen:'P')) + CRLF
     c                   endif

     c                   if        dsProxyAuthType = HTTP_AUTH_BASIC
     c                                and dsProxyTun = *off
     c                   eval      wwReqChain = wwReqChain +
     c                             'Proxy-Authorization: Basic '+
     c                             dsProxyAuthStr + CRLF
     c                   endif

     c                   select
     c                   when      dsAuthType = HTTP_AUTH_BASIC
     c                   eval      wwReqChain = wwReqChain +
     c                             'Authorization: Basic ' +
     c                              dsAuthStr + CRLF
     c                   when      dsAuthType = HTTP_AUTH_MD5_DIGEST
     c                   eval      wwReqChain = wwReqChain +
     c                             'Authorization: Digest ' +
     c                              mkdigest(peOper:peAbsPath) + CRLF
     c                   when      dsAuthType = HTTP_AUTH_BEARER
     c                             or dsAuthType = HTTP_AUTH_USRDFN
     c                   eval      wwReqChain = wwReqChain +
     c                             'Authorization: ' + dsAuthStr + CRLF
      /if defined(NTLM_SUPPORT)
     c                   other
      *        Add NTLM authentication header for type-1
      *        and type-3 messages.
     c                   callp     AuthPlugin_produceAuthenticationHeader(
     c                                                              wwReqChain)
      /endif
     c                   endsl

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs do_oper reqchain1')
      /endif

     c                   if        global.use_cookies = *on
     c                   eval      wwReqChain = wwReqChain +
     c                             header_get_req_cookies( %trim(peHost)
     c                                                   : peAbsPath
     c                                                   : peSecure )
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs do_oper reqchain2')
      /endif

     c                   eval      %len(wwAddlHdr) = 0
     c                   if        wkAddHdrProc <> *NULL
     c                   callp     addl_headers(wwAddlHdr: wkAddHdrData)
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs do_oper reqchain3')
      /endif

      *********************************************************
      *  Send request chain
      *********************************************************
     c                   if        %len(wwAddlHdr) = 0
     c                   eval      wwReqChain = wwReqChain + CRLF
     c                   endif

     c                   eval      rc = SendReq( peComm
     c                                         : %addr(wwReqChain)+VARPREF
     c                                         : %len(wwReqChain)
     c                                         : peTimeout )
     c                   if        rc < 1
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif

     c                   if        %len(wwAddlHdr) > 0

     c                   eval      rc = SendReq( peComm
     c                                         : %addr(wwAddlHdr)+VARPREF
     c                                         : %len(wwAddlHdr)
     c                                         : peTimeout )
     c                   if        rc < 1
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif

     c                   eval      wwReqChain = CRLF
     c                   eval      rc = SendReq( peComm
     c                                         : %addr(wwReqChain)+VARPREF
     c                                         : %len(wwReqChain)
     c                                         : peTimeout )
     c                   if        rc < 1
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif

     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after sendreq')
      /endif

      *********************************************************
      * If this request requires a request-body
      * then it should be sent, here.
      *
      * Some servers send a "100 Continue" block of HTTP
      * headers -- but this is optional.  So we will also
      * attempt to get these in this section, if they are
      * sent.
      *********************************************************
     c                   if        wwSendReqBody = *on

     c                   if        global.timeout100 <= 0
     c                   eval      rc = 0
     c                   else
     c                   eval      rc = RecvResp( peComm
     c                                          : wwRespChain
     c                                          : %size(wwRespChain)
     c                                          : global.timeout100
     c                                          : *ON )
     c                   if        rc < 0
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after recvresp1')
      /endif

     c                   if        rc = 0

     c                   eval      wwFinRC = 100
     c                   eval      wwErrorMsg = 'CONTINUE'

     c                   else

     c                   eval      rc = parse_resp_chain( wwRespChain
     c                                                  : rc
     c                                                  : wwTE
     c                                                  : wwCLen
     c                                                  : wwUseCL
     c                                                  : wwAuthErr
     c                                                  : wwProxyAuthErr
     c                                                  : %trim(peHost)
     c                                                  : peAbsPath)
     c                   if        rc<100 or rc=204 or rc=304
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif

     c                   eval      wwFinRC = rc
     c                   eval      wwErrorMsg = http_error(wwErrorNo)

     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after parseresp1')
      /endif

     c                   if        wwFinRC = 100
     c                   eval      rc = SendProc( peComm
     c                                          : pePostData
     c                                          : pePostDataLen
     c                                          : peTimeout
     c                                          : pePostProc
     c                                          : pePostFD )
     c                   if        rc < 1
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif
     c                   endif

     c                   endif

      *********************************************************
      *  Receive response chain from server
      *********************************************************
     c                   eval      rc = RecvResp( peComm
     c                                          : wwRespChain
     c                                          : %size(wwRespChain)
     c                                          : peTimeout
     c                                          : *Off )
     c                   if        rc < 1
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after recvresp2')
      /endif

     c                   eval      rc = parse_resp_chain( wwRespChain
     c                                                  : rc
     c                                                  : wwTE
     c                                                  : wwCLen
     c                                                  : wwUseCL
     c                                                  : wwAuthErr
     c                                                  : wwProxyAuthErr
     c                                                  : %trim(peHost)
     c                                                  : peAbsPath )

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after parseresp2')
      /endif

     c                   eval      wwSaveProc = peSaveProc
     c                   eval      wwFile = peFile

     c                   if        wwAuthErr and wwCLen > 0
      /if defined(NTLM_SUPPORT)
     c                             and AuthPlugin_mustReceiceAuthErrorPage(
     c                                wwSaveProc: wwFile)
      /endif
      *      ignore 401 error for type-1 and type-2 messages
     c                   else
     c                   if        rc<100 or rc=204 or rc=304
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   endif
     c                   endif

     c                   eval      wwFinRC = rc
     c                   eval      wwErrorMsg = http_error(wwErrorNo)

     C*********************************************************
     C* receive the document from the server
     C*********************************************************
     c                   if        peOper = 'HEAD'
     c                   eval      wwUseCL = *ON
     c                   eval      wwCLen = 0
     c                   endif

     c                   if        %scan('chunked': wwTE) > 0
     c                   eval      rc = RecvChunk( peComm
     c                                           : wwSaveProc
     c                                           : wwFile
     c                                           : peTimeout )
     c                   else
     c                   eval      rc = RecvDoc( peComm
     c                                         : wwSaveProc
     c                                         : wwFile
     c                                         : peTimeout
     c                                         : wwCLen
     c                                         : wwUseCL )
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after recvdoc')
      /endif

     c                   select
     c                   when      rc<1 or wwFinRC=200
     c                   callp     SetRespCode(rc)
     c                   return    rc
     c                   when      wwFinRC=401 or wwFinRC=407
     c                   callp     SetError(wwErrorNo: wwErrorMsg)
     c                   callp     SetRespCode(wwFinRC)
     c                   return    -1
     c                   other
     c                   callp     SetError(wwErrorNo: wwErrorMsg)
     c                   callp     SetRespCode(wwFinRC)
     c                   return    wwFinRC
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * SendReq():  Send request chain
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SendReq         B
     D SendReq         PI            10I 0
     D   peComm                        *   value
     D   peData                        *   value
     D   peDataLen                   10I 0 value
     D   peTimeout                   10I 0 value
     D p_deref         s               *
     D wwDeref         s              1A   based(p_deref)

     c                   callp     http_xlatep( peDataLen
     c                                        : peData
     c                                        : TO_ASCII )

     c                   return    comm_BlockWrite( peComm
     c                                            : peData
     c                                            : peDataLen
     c                                            : peTimeout )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  recvresp():  Receives an HTTP response chain from the server.
      *
      *      peComm = Comm driver to use when receiving
      * peRespChain = complete request chain to sent
      *   peRespLen = length of request chain data
      *  peTimeOut  = Timeout value in seconds.  If no data can be sent
      *         for this amount of time, it will return a timeout.
      *    peUse100 = Return from recvresp() if a 100-continue comes up
      *
      *  Returns 1 upon success, 0 upon timeout, -1 upon error
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P recvresp        B
     D recvresp        PI            10I 0
     D   peComm                        *   value
     D   peRespChain              32767A   varying options(*varsize)
     D   peRespLen                   10I 0 value
     D   peTimeOut                   10P 3 value
     D   peUse100                     1N   const

     D wwPos           S               *
     D wwRec           S             10I 0
     D wwLen           S             10I 0
     D p_saveaddr      S               *
     D p_check         S               *
     D wwCheck         S              4A   based(p_check)
     D wwRespCode      S             10I 0
     D forever         S              1N   inz(*On)
     D repeating       S              1N   inz(*Off)
     D wwSecs          s             10I 0
     D wwMicroSecs     s             10I 0
     D wwLeft          s             10I 0
     D wwErr           s             10I 0
     D CR              S              1A   inz(x'0d') static

     c                   callp     http_dmsg('recvresp(): entered')
     c                   eval      p_global = getGlobalPtr()

     c                   dou       not repeating

     c                   eval      wwPos = %addr(peRespChain) + VARPREF
     c                   eval      wwLeft = peRespLen - VARPREF
     c                   eval      %len(peRespChain) = wwLeft
     c                   eval      wwLen = 0

     c                   dow       wwLeft > 0

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('recvresp: reading response +
     c                             header, space left=' + %char(wwLeft))
     c                   endif

     c                   eval      wwRec = comm_lineread( peComm
     c                                                  : wwPos
     c                                                  : wwLeft
     c                                                  : peTimeout )

     c                   if        wwRec < 1
     c                   callp     http_error(wwErr)
     c                   if        wwErr = HTTP_BRTIME
     c                   callp     http_dmsg('recvresp(): end with timeout')
     c                   return    0
     c                   else
     c                   callp     http_dmsg('recvresp(): end with err')
     c                   return    -1
     c                   endif
     c                   endif

     c                   eval      wwLeft = wwLeft - wwRec
     c                   eval      wwLen = wwLen + wwRec
     c                   if        wwLeft > 0
     c                   eval      wwPos = wwPos + wwRec
     c                   endif

     c                   eval      p_check = wwPos - wwRec
     c                   if        (wwRec=1
     c                             and %subst(wwCheck:1:1)=x'0a')
     c                             or (wwRec=2
     c                             and %subst(wwCheck:1:2)=x'0d0a')
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('recvresp: empty line, ending +
     c                                header, number of eol chars=' +
     c                                %char(wwRec))
     c                   endif
     c                   leave
     c                   endif

     c                   enddo

     c                   eval      %len(peRespChain) = wwLen

     C* translate response chain to EBCDIC
     c                   if        wwLen > 0
     c                   callp     http_xlatep( wwLen
     c                                        : %addr(peRespChain)+VARPREF
     c                                        : TO_EBCDIC )
     c                   endif

     C* check for "continue" type codes:
     C* if we get them, we'll look for a whole new chain :)
     c                   if        %subst(peRespChain:1:2) = x'0d25'
     c                   eval      p_check = %addr(peRespChain) + 13
     c                   else
     c                   eval      p_check = %addr(peRespChain) + 11
     c                   endif
     c                   eval      wwRespCode = atoi(wwCheck)

     c                   select
     c                   when      peUse100 and wwRespCode = 100
      *                 we are handling this specially in do_oper
     c                   eval      repeating = *off
     c                   when      wwRespCode > 99 and wwRespCode < 200
     c                   eval      repeating = *on
     c                   when      wwRespCode = 0
     c                   eval      repeating = *on
     c                   other
     c                   eval      repeating = *off
     c                   endsl

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('recvresp: header resp code +
     c                                = ' + wwCheck + ' repeating=' +
     c                               repeating)
     c                   endif

     c                   if        %scan(CR:peRespChain) > 1
     c                   callp     SetError(HTTP_RESP: %subst(peRespChain:1:
     c                                 %scan(CR:peRespChain)-1) )
     c                   else
     c                   callp     SetError(HTTP_RESP: peRespChain)
     c                   endif

     c                   enddo

     c                   callp     http_dmsg('recvresp(): end with '
     c                                 + %char(wwRespCode))
     c                   return    wwRespCode
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * recvdoc(): receive (Download) http document
      *
      *       peComm = Comm driver to receive with
      *  peProcedure = procedure to call with received data.
      *    peTimeout = time-out in seconds.  If no data is received
      *          for this amount of time, proc will time out.
      *
      *  returns 1 upon success, 0 upon timeout, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P recvdoc         B
     D recvdoc         PI            10I 0
     D   peComm                        *   value
     D   peProcedure                   *   value procptr
     D   peFD                        10I 0 value
     D   peTimeout                   10I 0 value
     D   peCLen                      10U 0 value
     D   peUseCL                      1N   const

     D saveproc        PR            10I 0 ExtProc(peProcedure)
     D  fd                           10I 0 value
     D  data                           *   value
     D  length                       10I 0 value

     D wwData          S           8192A
     D forever         S              1N   inz(*on)
     D wwErr           S             10I 0
     D p_saveaddr      S               *
     D wwTimeout       S              8A
     D wwLen           S             10I 0
     D rc              S             10I 0
     D wwChunked       S              1N
     D wwChunk         S             10I 0
     D wwReceived      S             10U 0
     D wwRet           s             10I 0

     c                   callp     http_dmsg('recvdoc(): entered')
     c                   eval      p_global = getGlobalPtr()

     c                   callp     SetError(0: *blanks)
     c                   eval      wwReceived = 0

     c                   if        peUseCL = *OFF
     c                   callp     http_dmsg('recvdoc(): No content-length: +
     c                               receiving until disconnect')
     c                   eval      wwRet = 1
     c                   else
     c                   callp     http_dmsg('recvdoc(): Receiving ' +
     c                                %char(peCLen) + ' bytes.')
     c                   eval      wwRet = -1
     c                   endif

     c                   if        peUseCL=*ON and peCLen=0
     c                   callp     http_dmsg('recvdoc(): Nothing to +
     c                               receive, exiting...')
     c                   return    1
     c                   endif

     c                   dow       forever

     c                   eval      wwLen = comm_read( peComm
     c                                              : %addr(wwData)
     c                                              : %size(wwData)
     c                                              : peTimeout     )

     c                   if        global.debugLevel > 2
     c                   callp     http_dmsg('recvdoc(): comm_read rc = ' +
     c                               %char(wwLen))
     c                   endif

     c                   if        wwLen < 0
     c                   return    wwRet
     c                   endif

     c                   if        global.debugLevel > 2
     c                   callp     http_dmsg('recvdoc(): Calling saveproc +
     c                                for ' + %char(wwLen) + ' bytes')
     c                   endif

     c                   if        RDWR_Writer_p <> *null
     c                   eval      rc = Writer_Write( RDWR_Writer_p
     c                                              : %addr(wwData)
     c                                              : wwLen )
     c                   else
     c                   eval      rc = saveproc( peFD
     c                                          : %addr(wwData)
     c                                          : wwLen )
     c                   endif

     c                   if        global.debugLevel > 2
     c                   callp     http_dmsg('recvdoc(): saveproc returns ' +
     c                                %char(rc) + ' saved')
     c                   endif
     c
     c                   if        rc < wwLen
     c                   callp     SetError(HTTP_RDWERR
     c                                     : 'errno is currently '
     c                                     + %trim(%editc(errno:'L')))
     c                   callp     SetError(HTTP_RDWERR:'recvdoc: saveproc:'+
     c                              ' Not all data was written!')
     c                   return    -1
     c                   endif

     c                   eval      wwReceived = wwReceived + wwLen

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('recvdoc():'
     c                                      + ' have ' + %char(wwReceived)
     c                                      + ' of ' + %char(peCLen))
     c                   endif

     c                   if        peUseCL=*ON and wwReceived>=peCLen
     c                   return    1
     c                   endif

     C* Call status proc if defined
     c                   if        wkDwnlProc <> *NULL
     c                   if        global.debugLevel > 2
     c                   callp     http_dmsg('recvdoc(): calling user +
     c                                supplied download_sts routine')
     c                   endif
     c                   callp     download_sts(wwReceived: peCLen
     c                                         : wkDwnlUdata)
     c                   if        global.debugLevel > 2
     c                   callp     http_dmsg('recvdoc(): download_sts +
     c                                 returned')
     c                   endif
     c                   endif

     c                   enddo

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * recvchunk(): receive (download) data using chunked transfer-encoding
      *
      *       peComm = Comm driver to receive from
      *  peProcedure = procedure to call with received data.
      *    peTimeout = time-out in seconds.  If no data is received
      *          for this amount of time, proc will time out.
      *
      *  returns 1 upon success, 0 upon timeout, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P recvchunk       B
     D recvchunk       PI            10I 0
     D   peComm                        *   value
     D   peProcedure                   *   value procptr
     D   peFD                        10I 0 value
     D   peTimeout                   10I 0 value

     D saveproc        PR            10I 0 ExtProc(peProcedure)
     D  fd                           10I 0 value
     D  data                           *   value
     D  length                       10I 0 value

     D wwData          s           8192A
     D forever         S              1N   inz(*on)
     D rc              S             10I 0
     D wwLeft          S             10I 0
     D wwRecSize       S             10I 0
     D wwCRLF          s              2A
     D wwReceived      S             10U 0

     c                   callp     http_dmsg('recvchunk(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   eval      wwReceived = 0

     c                   dow       Forever

     C*********************************************************
     C* Receive the size of the next chunk of data:
     C*********************************************************
     c                   eval      wwLeft = get_chunk_size(peComm:peTimeout)
     c                   callp     http_dmsg('get_chunk_size returned ' +
     c                                          %trim(%editc(wwLeft:'P')))
     c                   select
     c                   when      wwLeft = 0
     c                   return    1
     c                   when      wwLeft = -2
     c                   return    0
     c                   when      wwLeft = -1
     c                   return    -1
     c                   endsl

     C*********************************************************
     c* Receive data until we have an entire chunk:
     C*********************************************************
     c                   dou       wwLeft = 0

     c                   eval      wwRecSize = %size(wwData)
     c                   if        wwLeft < wwRecSize
     c                   eval      wwRecSize = wwLeft
     c                   endif

     c                   callp     http_dmsg('calling comm_blockread')

     c                   if        comm_BlockRead( peComm
     c                                           : %addr(wwData)
     C                                           : wwRecSize
     c                                           : peTimeout ) < wwRecSize
     c                   callp     http_dmsg('comm_blockread failed!')
     c                   return    -1
     c                   endif

     c                   callp     http_dmsg('comm_blockread returned ' +
     c                              %trim(%editc(wwRecSize:'P')) )

     C* Write any received data to the save procedure:
     C                   if        RDWR_Writer_p <> *null
     C                   eval      rc = Writer_write( RDWR_Writer_p
     C                                              : %addr(wwData)
     C                                              : wwRecSize )
     C                   else
     c                   eval      rc = saveproc( peFD
     c                                          : %addr(wwData)
     c                                          : wwRecSize)
     c                   endif

     c                   if        rc < wwRecSize
     c                   callp     SetError(HTTP_RDWERR:'recvchunk: saveproc:'+
     c                              ' Not all data was written!')
     c                   return    -1
     c                   endif

     c                   if        wkDwnlProc <> *NULL
     c                   eval      wwReceived = wwReceived + wwRecSize
     c                   callp     download_sts(wwReceived: 0: wkDwnlUData)
     c                   endif

     c                   eval      wwLeft = wwLeft - wwRecSize
     c                   enddo

     C*********************************************************
     c* Receive the CRLF that follows each chunk
     C*********************************************************
     c                   if        comm_BlockRead( peComm
     c                                           : %addr(wwCRLF)
     c                                           : %size(wwCRLF)
     c                                           : peTimeout ) < 2
     c                             or wwCRLF <> x'0d0a'
     c                   callp     SetError(HTTP_RDCRLF: 'recvchunk: '+
     c                                'No CRLF after reading chunk!')
     c                   return    -1
     c                   endif

     c                   enddo
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This sends a document body, such as those used by the PUT
      *  or POST HTTP commands.
      *
      *  returns 0 for timeout, -1 for error or 1 if successful
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SendDoc         B
     D SendDoc         PI            10I 0
     D  peComm                         *   value
     D  pePostData                     *   value
     D  pePostDataLen                20I 0 value
     D  peTimeout                    10I 0 value
     D  peUnused1                      *   value procptr
     D  peUnused2                    10I 0 value

     D wwPos           S               *
     D wwLeft          S             20I 0
     D wwTimeout       S              8A
     D wwErr           S             10I 0
     D wwSent          S             10I 0
     D wwChunk         S             10I 0
     D wwTotSent       s             20i 0
     D reportTotal     s             10u 0
     D reportSent      s             10u 0

     c                   callp     http_dmsg('senddoc(): entered')
     c                   eval      p_global = getGlobalPtr()

     c                   eval      wwPos = pePostData
     c                   eval      wwLeft = pePostDataLen

     c                   if        pePostDataLen > 4294967295
     c                   eval      reportTotal = 4294967295
     c                   else
     c                   eval      reportTotal = pePostDataLen
     c                   endif

     c                   dow       wwLeft > 0

     c                   if        wwLeft > SEND_CHUNK_SIZE
     c                   eval      wwChunk = SEND_CHUNK_SIZE
     c                   else
     c                   eval      wwChunk = wwLeft
     c                   endif

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('senddoc()' +
     c                                 ': data left=' + %char(wwLeft) +
     c                                 ', chunk size=' + %char(wwChunk) +
     c                                 ', timeout=' + %char(peTimeout) +
     c                                 ', calling comm_blockWrite...')
     c                   endif

     c                   eval      wwSent = comm_BlockWrite( peComm
     c                                                     : wwPos
     c                                                     : wwChunk
     c                                                     : peTimeout )
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('senddoc(): comm_blockWrite ' +
     c                                 'returned ' + %char(wwSent))
     c                   endif

     c                   if        wwSent < 0
     c                   return    -1
     c                   endif

     c                   eval      wwLeft = wwLeft - wwSent
     c                   if        wwLeft > 0
     c                   eval      wwPos  = wwPos + wwSent
     c                   endif

     c                   if        wkUplProc <> *NULL
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('senddoc(): calling user ' +
     c                                 'defined upload_sts routine')
     c                   endif
     c                   eval      wwTotSent = pePostDataLen - wwLeft
     c                   if        wwTotSent > 4294967295
     c                   eval      reportSent = 4294967295
     c                   else
     c                   eval      reportSent = wwTotSent
     c                   endif
     c                   callp     upload_sts( reportSent
     c                                       : reportTotal
     c                                       : wkUplUData )
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('senddoc(): upload_sts ' +
     c                                 'returned')
     c                   endif
     c                   endif

     c                   enddo

     c                   return    1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This sends a document body, such as those used by the PUT
      *  or POST HTTP commands, but uses a callback instead of a buffer
      *
      *  returns 0 for timeout, -1 for error or 1 if successful
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SendRaw         B
     D SendRaw         PI            10I 0
     D  peComm                         *   value
     D  peUnused1                      *   value
     D  peDataSize                   20I 0 value
     D  peTimeout                    10I 0 value
     D  pePostProc                     *   value procptr
     D  pePostFD                     10I 0 value

     D Callback        PR            10I 0 extproc(pePostProc)
     D   fd                          10I 0 value
     D   data                      8192A
     D   size                        10I 0 value

     D wwLen           S             10I 0
     D wwBuf           s           8192A
     D wwSent          S             20I 0
     D wwNeed          S             10I 0
     D rc              s             10i 0
     D reportTotal     s             10u 0
     D reportSent      s             10u 0

     c                   callp     http_dmsg('sendraw(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   eval      wwSent = 0

     c                   if        peDataSize > 4294967295
     c                   eval      reportTotal = 4294967295
     c                   else
     c                   eval      reportTotal = peDataSize
     c                   endif

     c                   dow       peDataSize > wwSent

     c                   eval      wwNeed = %size(wwBuf)
     c                   if        wwNeed > peDataSize
     c                   eval      wwNeed = peDataSize
     c                   endif

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('sendraw()' +
     c                                 ': data sent=' + %char(wwSent) +
     c                                 ', chunk size=' + %char(wwNeed) +
     c                                 ', calling Callback to get data...')
     c                   endif

     c                   if        RDWR_Reader_p <> *null
     c                   eval      wwLen = Reader_read( RDWR_Reader_p
     c                                                : %addr(wwBuf)
     c                                                : wwNeed )
     c                   else
     c                   eval      wwLen = Callback( pePostFD
     c                                             : wwBuf
     c                                             : wwNeed )
     c                   endif

     c                   if        wwLen < 1
     c                   callp     SetError( HTTP_SWCERR
     c                                     : 'SendRaw(): callback '
     c                                     + 'returned an error.')
     c                   return    -1
     c                   endif

     c                   if        wwLen > wwNeed
     c                   callp     SetError( HTTP_SWCERR
     c                                     : 'SendRaw(): callback '
     c                                     + 'supplied too much data.')
     c                   return    -1
     c                   endif

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('sendraw()' +
     c                                 ': data sent=' + %char(wwSent) +
     c                                 ', chunk len=' + %char(wwLen) +
     c                                 ', timeout=' + %char(peTimeout) +
     c                                 ', calling comm_BlockWrite...')
     c                   endif

     c                   eval      rc = comm_BlockWrite( peComm
     c                                                 : %addr(wwBuf)
     c                                                 : wwLen
     c                                                 : peTimeout
     c                                                 )

     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('sendraw(): comm_blockWrite ' +
     c                                 'returned ' + %char(rc))
     c                   endif

     c                   if        rc < wwLen
     c                   return    -1
     c                   endif

     c                   eval      wwSent = wwSent + wwLen

     c                   if        wkUplProc <> *NULL
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('sendraw(): calling user ' +
     c                                 'defined upload_sts routine')
     c                   endif
     c                   if        wwSent > 4294967295
     c                   eval      reportSent = 4294967295
     c                   else
     c                   eval      reportSent = wwSent
     c                   endif
     c                   callp     upload_sts( reportSent
     c                                       : reportTotal
     c                                       : wkUplUData )
     c                   if        global.debugLevel > 1
     c                   callp     http_dmsg('sendraw(): upload_sts ' +
     c                                 'returned')
     c                   endif
     c                   endif

     c                   enddo

     c                   return    1
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This receives the chunk size from the http stream.  We use
      *   it so we know how big the next chunk of data is.
      *
      *  XXX: This will crash if 2gb or larger chunks are used.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P get_chunk_size  B
     d get_chunk_size  PI            10I 0
     d   peComm                        *   value
     d   peTimeout                   10I 0 value

     d sscanf          PR            10I 0 extproc('sscanf')
     D  str                            *   value options(*string)
     D  format                         *   value options(*string)
     D  sexyfun                      10U 0

     D wwLen           s             10I 0
     D rc              s             10I 0
     D wwBuf           s             15A
     D wwChunkSize     S             10U 0
     D wwErr           s             10I 0

     c                   callp     http_dmsg('get_chunk_size(): entered')
     c                   eval      p_global = getGlobalPtr()

     c                   eval      wwLen = comm_LineRead( peComm
     c                                                  : %addr(wwBuf)
     c                                                  : %size(wwBuf)
     c                                                  : peTimeout )

     c                   if        wwLen < 1
     c                   callp     http_error(wwErr)
     c                   if        wwErr = HTTP_BRTIME
     c                   return    -2
     c                   else
     c                   return    -1
     c                   endif
     c                   endif

     c                   callp     http_xlate( wwLen
     c                                       : wwBuf
     c                                       : TO_EBCDIC )

     c                   eval      rc = %scan(';': wwBuf)
     c                   if        rc > 1
     c                   eval      wwBuf = %subst(wwBuf:1:rc-1)
     c                   endif

     c                   callp     sscanf(wwBuf: '%x': wwChunkSize)

     c                   callp     http_dmsg('chunk size = ' +
     c                                  %trim(%editc(wwChunkSize:'P')))

     c                   return    wwChunkSize
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_getauth(): Get HTTP Authentication Information
      *
      *   Call this proc after you receive a HTTP_NDAUTH error
      *   to determine the authentication credentials that are required
      *
      *  The following parms are returned to your program:
      *
      *     peBasic = *ON if BASIC auth is allowed
      *    peDigest = *ON if MD5 DIGEST auth is allowed
      *     peRealm = Auth realm.  Present this to the user to identify
      *               which password you're looking for.  For example
      *               if peRealm is "secureserver.com" you might say
      *               "enter password for secureserver.com" to user.
      *      peNTLM = *ON if NTLM auth is allowed
      *
      *   After getting the userid & password from the user (or database)
      *   you'll need to call http_setauth()
      *
      *  Returns -1 upon error, or 0 if successful
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_getauth    B                   export
     D http_getauth    PI            10I 0
     D   peBasic                      1N
     D   peDigest                     1N
     D   peRealm                    124A
     D   peNTLM                       1N   options(*nopass)

     D wwNTLM          S              1N   inz(*OFF)

     c                   callp     http_dmsg('http_getauth(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   if        dsAuthRealm = *blanks
      /if defined(NTLM_SUPPORT)
     c                             and not
     c                             AuthPlugin_isAuthenticationRequired()
      /endif
     c                   callp     SetError(HTTP_NOAUTH: 'Server did ' +
     c                              'not ask for authentication!')
     c                   return    -1
     c                   endif

      /if defined(NTLM_SUPPORT)
     c                   if        (AuthPlugin_isAuthenticationRequired())
     c                   eval      dsAuthRealm = AuthPlugin_getRealm()
     c                   eval      wwNTLM = *ON
     c                   endif
     c                   if        %parms() >= 4
     c                   eval      peNTLM = wwNTLM
     c                   endif
      /endif

     c                   eval      peBasic = dsAuthBasic
     c                   eval      peDigest = dsAuthDigest
     c                   eval      peRealm = dsAuthRealm

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_setauth():   Set HTTP Authentication Information
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_setauth    B                   export
     D http_setauth    PI            10I 0 opdesc
     D   peAuthType                   1A   const
     D   peUsername                  80A   const
     D   pePassword               15000A   const options(*varsize)

     D wwPasswd        s          15000A   varying
     D wwString        S           1105A
     D wwEncoded       S           1476A
     D wwEncLen        S             10I 0

     D descType        s             10i 0
     D dataType        s             10i 0
     D descInf1        s             10i 0
     D descInf2        s             10i 0
     D dataLen         s             10i 0

     D feedback        ds                  qualified
     D   Condition_ID                 4A
     D     MsgSev                     2A   overlay(Condition_ID:1)
     D     MsgNo                      2A   overlay(Condition_ID:3)
     D   Flags                        1a
     D   Facility_ID                  3A
     D   I_S_Info                     4A

     c                   callp     http_dmsg('http_setauth(): entered')
     c                   eval      p_global = getGlobalPtr()

     C*************************************************
     C* Get an OPDESC for the pePassword parameter.
     C* This is used to check its length
     C*************************************************
     c                   callp     CEEDOD( 3
     c                                   : descType
     c                                   : dataType
     c                                   : descInf1
     c                                   : descInf2
     c                                   : dataLen
     c                                   : feedback )

     C*************************************************
     C* Older releases of HTTPAPI had pePassword
     C* defined as char(1024) to maintain compatibility,
     C* if we're unable to get an OPDESC, assume that
     C* it's still passed that way.
     C*************************************************
     c                   if        feedback.Condition_ID <> x'00000000'
     c                   eval      descType = 2
     c                   eval      dataType = 2
     c                   eval      dataLen  = 1024
     c                   endif

     C*************************************************
     C* We currently only support fixed-length strings
     C*************************************************
     C                   if        descType <> 2 or dataType <> 2
     c                   callp     SetError( HTTP_ATHPDT
     c                             : 'Password must be a CHAR field.')
     c                   return    -1
     c                   endif

     C*************************************************
     C* Only use the length that was provided
     C*************************************************
     c                   if        dataLen <= 0 or dataLen > %size(pePassword)
     c                   eval      wwPasswd=''
     c                   else
     c                   eval      wwPasswd=%trim(%subst(pePassword:1:dataLen))
     c                   endif

     C*************************************************
     C* Give any authorization plugins (NTLM) a chance
     C* to handle things
     C*************************************************
      /if defined(NTLM_SUPPORT)
     c                   if        AuthPlugin_setAuthentication(
     c                                   peAuthType: peUsername: wwPasswd)
     c                   return    0
     c                   endif
      /endif

     C*************************************************
     C*  Validate the auth type
     C*************************************************
     c                   if        peAuthType<>HTTP_AUTH_BASIC
     c                               and peAuthType<>HTTP_AUTH_MD5_DIGEST
     c                               and peAuthType<>HTTP_AUTH_BEARER
     c                               and peAuthType<>HTTP_AUTH_USRDFN
     c                               and peAuthType<>HTTP_AUTH_NONE
     c                   callp     SetError(HTTP_ATHTYP: 'Invalid authenti'+
     c                                   'cation type!')
     c                   return    -1
     c                   endif

     C*************************************************
     c* Calculate strings for NO authentication
     C*************************************************
     c                   if        peAuthType = HTTP_AUTH_NONE
     c                   eval      dsAuthType = HTTP_AUTH_NONE
     c                   eval      dsAuthStr = ''
     c                   return    0
     c                   endif

     C*************************************************
     c* BASIC or DIGEST
     C*************************************************
     c                   if        peAuthType = HTTP_AUTH_BASIC
     c                             or peAuthType = HTTP_AUTH_MD5_DIGEST

     c                   if        %scan(':':peUserName) > 0
     c                   callp     SetError(HTTP_ATHVAL: 'HTTP Auth value' +
     c                               's cannot contain a colon!')
     c                   return    -1
     c                   endif

     c                   eval      dsAuthUser = peUserName
     c                   eval      dsAuthPasswd = wwPasswd

     c                   eval      wwString = %trimr(peUserName) + ':' +
     c                                        wwPasswd
     c                   callp     http_xlate( %len(%trimr(wwString))
     c                                       : wwString
     c                                       : TO_ASCII )

     c                   eval      wwEncLen = base64_encode(%addr(wwString):
     c                                             %len(%trimr(wwString)):
     c                                             %addr(wwEncoded):
     c                                             %size(wwEncoded))

     c                   eval      dsAuthStr = %subst(wwEncoded:1:wwEncLen)
     c                   endif

     c*************************************************
     c* BEARER TOKEN (OAuth2, et al)
     c*************************************************
     c                   if        peAuthType = HTTP_AUTH_BEARER
     c                   eval      dsAuthUser = ''
     c                   eval      dsAuthPasswd = ''
     c                   eval      dsAuthStr = 'Bearer ' + wwPasswd
     c                   endif

     c*************************************************
     c* User Defined
     c*************************************************
     c                   if        peAuthType = HTTP_AUTH_USRDFN
     c                   eval      dsAuthUser = peUserName
     c                   eval      dsAuthPasswd = wwPasswd
     c                   eval      dsAuthStr = %trim(peUserName)
     c                                       + ' ' + wwPasswd
     c                   endif

     c                   eval      dsAuthType = peAuthType
     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * setUrlAuth(): Set auth credentials if found in the URL
      *      peUsername = username found in URL
      *      pePasswd   = password found in URL
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P setUrlAuth      B
     D setUrlAuth      PI
     D   peUsername                  80A   const
     D   pePasswd                  1024A   const
     c                   if        peUsername = *blanks
     c                              and pePasswd = *blanks
     c                   eval      wkSaveAuth = *blanks
     c                   return
     c                   endif

     c                   eval      wkSaveAuth = dsAuth

     c                   if        dsAuthRealm = *blanks
     c                               or dsAuthDigest = *OFF
     c                   callp     http_setAuth( HTTP_AUTH_BASIC
     c                                         : peUsername
     c                                         : pePasswd )
     c                   else
     c                   callp     http_setAuth( HTTP_AUTH_MD5_DIGEST
     c                                         : peUsername
     c                                         : pePasswd )
     c                   endif
     c                   return
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  mkdigest():  Create a digest authorization string
      *
      *      peMethod = HTTP method in use (GET or POST)
      *
      *  Returns the digest authorization response
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P mkdigest        B
     D mkdigest        PI         32767A   varying
     D   peMethod                    10A   varying const
     D   peURI                    32767A   varying const options(*varsize)

     D wwRet           S          32767A   varying
     D wwWork          S          32767A   varying
     D wwA1            S             32A
     D wwA2            S             32A
     D wwResp          S             32A

     c                   callp     http_dmsg('mkdigest(): entered')
     c                   eval      p_global = getGlobalPtr()
     C*  Authorization: Digest username="Mufasa",
     C*         realm="testrealm@host.com",
     C*         nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     C*         uri="/dir/index.html",
     C*         nc=00000001,
     C*         cnonce="0a4f113b",
     C*         response="6629fae49393a05397450978507c4ef1",
     C*         opaque="5ccc069c403ebaf9f0171e9517f40e41"

     c*  response =
     C*     md5(md5(A1) + ':' + nonce + ':' + nc-value + ':' +
     c*          cnonce + ':' + qop + ':' md5(A2))
     C*  A1 = username + ':' + realm + ':' + passwd
     C*  A2 = method + ':' + uri
     C*
     C*  realm = passed from server
     C*  nonce = passed from server
     C*  nc = count of uses of nonce so far
     C*  qop = auth (if that's a choice on this server)
     C*  cnonce = 8-char hex string that we make up
     C*  opaque = passed by server
     C*  method = GET or POST
     C*  username & password are supplied by the user
     C*  we should know the URI when the request is made

      * FIXME: This CNonce ("client nonce") should be different
      *    with every request, not a fixed string.
     c                   eval      dsAuthCNonce = '7248e2a3711545e8'
     c                   eval      dsAuthNC = dsAuthNC + 1

     c                   eval      wwWork = %trim(dsAuthUser) + ':' +
     c                                      %trim(dsAuthRealm) + ':' +
     c                                      %trim(dsAuthPasswd)
     c                   if        md5( %addr(wwWork)+VARPREF
     c                                : %len(wwWork)
     c                                : wwA1 ) = *OFF
     c                   return    '*error'
     c                   endif

     c                   eval      wwWork = %trim(peMethod) + ':' +
     c                                      %trim(peURI)
     c                   if        md5( %addr(wwWork)+VARPREF
     c                                : %len(wwWork)
     c                                : wwA2 ) = *OFF
     c                   return    '*error'
     c                   endif

     c                   if        %scan('auth': dsAuthQop) > 0
     c                   eval      wwWork = wwA1 + ':' +
     c                                      %trim(dsAuthNonce) + ':' +
     c                                      '0'+%editc(dsAuthNC:'X') + ':' +
     c                                      dsAuthCnonce + ':' +
     c                                      'auth' + ':' +
     c                                      wwA2
     c                   else
     c                   eval      wwWork = wwA1 + ':' +
     c                                      %trim(dsAuthNonce) + ':' +
     c                                      wwA2
     c                   endif

     c                   if        md5( %addr(wwWork)+VARPREF
     c                                : %len(wwWork)
     c                                : wwResp ) = *OFF
     c                   return    '*error'
     c                   endif

     c                   eval      wwRet =
     c                               'username="' +%trim(dsAuthUser)+ '", '+
     c                               'realm="' +%trim(dsAuthRealm)+ '", '+
     c                               'nonce="' +%trim(dsAuthNonce)+ '", '+
     c                               'uri="' +%trim(peURI)+ '", '+
     c                               'response="' + wwResp + '"'

     c                   if        %scan('auth': dsAuthQop) > 0
     c                   eval      wwRet = %trimr(wwRet) + ', ' +
     c                               'algorithm=MD5, ' +
     c                               'nc=0' + %editc(dsAuthNC:'X') + ', ' +
     c                               'cnonce="' + dsAuthCNonce +'", ' +
     c                               'qop="auth"'
     c                   endif

     c                   if        dsAuthOpaque <> *blanks
     c                   eval      wwRet = %trimr(wwRet) + ', ' +
     c                                 'opaque="' + %trim(dsAuthOpaque)+'"'
     c                   endif

     c                   return    wwRet
     P                 E


     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P* Interpret (parse & save) the WWW-Authenticate: header
     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P interpret_auth  B
     D interpret_auth  PI
     D   peRespChain               2048A   const
     D   peKwdPos                    10I 0 value
     D   peResetAuth                   N   value

     D wwCh            S              1A
     D wwAuth          S           2048A
     D wwPos1          S             10I 0
     D wwPos2          S             10I 0
     D wwLen           S             10I 0
     D p_Word          S               *
     D p_Next          S               *
     D wwWord          S             30A
     D TAB             C                   CONST(x'05')
     D wwOrigNonce     S            128A
     D LF              S              1A   inz(x'25') static

     d strtok          PR              *   extproc('strtok')
     d   nextpos                       *   value
     d   delim                         *   value options(*string)

     c                   callp     http_dmsg('interpret_auth(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   eval      wwOrigNonce = dsAuthNonce

     c                   if        peResetAuth
     c                   eval      dsAuthBasic = *OFF
     c                   eval      dsAuthDigest = *OFF
     c                   eval      dsAuthDigest = *OFF
     c                   eval      dsAuthRealm = *blanks
     c                   eval      dsAuthNonce = *blanks
     c                   eval      dsAuthOpaque = *blanks
     c                   eval      dsAuthQOP = *blanks
     c                   eval      dsAuthCNonce = *blanks
      /if defined(NTLM_SUPPORT)
     c                   callp     AuthPlugin_resetAuthentication()
      /endif
     c                   endif

     C*********************************************************
     C* extract the value of this keyword (and nothing else)
     C*********************************************************
     c                   eval      wwPos1 =%scan(':':peRespChain:peKwdPos+1)
     c                   eval      peKwdPos = wwPos1 + 1

     c                   dou       wwCh<>' ' and wwCh<>TAB
     c                   eval      wwPos2 = %scan(LF: peRespChain:
     c                                            wwPos1)
     c                   if        wwPos2 < wwPos1
     c                   leave
     c                   endif
     c                   eval      wwPos1 = wwPos2
     c                   eval      wwCh = %subst(peRespChain:wwPos2+1:1)
     c                   enddo

     c                   if        wwPos1 < peKwdPos
     C*             shouldn't happen
     c                   return
     c                   endif

     c                   eval      wwLen = (wwPos1 - peKwdPos) + 1
     c                   eval      wwAuth = %subst( peRespChain:
     c                                              peKwdPos: wwLen) + x'00'
     c                   eval      p_Next = %addr(wwAuth)

      *********************************************************
      * First let the authentication plugin interpret the
      * authentication header, because strtok() damages
      * wwAuth.
      *********************************************************
      /if defined(NTLM_SUPPORT)
     c                   callp     AuthPlugin_interpretAuthenticationHeader(
     c                                                                 wwAuth)
      /endif

     C*********************************************************
     C* Extract one word at a time from the list.  If the word
     C* is something we can use, save it's value to our DS
     C*********************************************************
     c                   dow       1 = 1

     c                   eval      p_Word = strtok(p_Next: ' =,'+TAB)
     c                   if        p_Word = *NULL
     c                   leave
     c                   endif
     c                   eval      p_Next = *NULL

     c                   eval      wwWord = %str(p_Word)

     c     upper:lower   xlate     wwWord        wwWord

     c                   select
     c                   when      wwWord=*blanks
     c                   iter

     c                   when      wwWord = 'basic'
     c                   eval      dsAuthBasic = *on

     c                   when      wwWord = 'digest'
     c                   eval      dsAuthDigest = *on

     c                   when      wwWord = 'realm'
     c                   eval      p_Word = strtok(*NULL: '"')
     c                   if        p_word <> *NULL
     c                   eval      dsAuthRealm = %str(p_word)
     c                   endif

     c                   when      wwWord = 'qop'
     c                   eval      p_Word = strtok(*NULL: '"')
     c                   if        p_word <> *NULL
     c                   eval      dsAuthQOP = %str(p_word)
     c                   endif

     c                   when      wwWord = 'nonce'
     c                   eval      p_Word = strtok(*NULL: '"')
     c                   if        p_word <> *NULL
     c                   eval      dsAuthNonce = %str(p_word)
     c                   if        wwOrigNonce <> dsAuthNonce
     c                   eval      dsAuthNC = 0
     c                   endif
     c                   endif

     c                   when      wwWord = 'opaque'
     c                   eval      p_Word = strtok(*NULL: '"')
     c                   if        p_word <> *NULL
     c                   eval      dsAuthOpaque = %str(p_word)
     c                   endif
     c                   endsl

     c                   enddo

     c                   return
     P                 E

     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P* Interpret (parse & save) the Proxy-Authenticate: header
     P*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P interpret_proxy_auth...
     P                 B
     D interpret_proxy_auth...
     D                 PI
     D   peRespChain               2048A   const
     D   peKwdPos                    10I 0 value

     D wwCh            S              1A
     D wwAuth          S           2048A
     D wwPos1          S             10I 0
     D wwPos2          S             10I 0
     D wwLen           S             10I 0
     D TAB             C                   CONST(x'05')
     D LF              S              1A   inz(x'25') static

     c                   callp     http_dmsg('interpret_proxy_auth(): entered')
     c                   eval      p_global = getGlobalPtr()

     C*********************************************************
     C* extract the value of this keyword (and nothing else)
     C*********************************************************
     c                   eval      wwPos1 =%scan(':':peRespChain:peKwdPos+1)
     c                   eval      peKwdPos = wwPos1 + 1

     c                   dou       wwCh<>' ' and wwCh<>TAB
     c                   eval      wwPos2 = %scan(LF: peRespChain:
     c                                            wwPos1)
     c                   if        wwPos2 < wwPos1
     c                   leave
     c                   endif
     c                   eval      wwPos1 = wwPos2
     c                   eval      wwCh = %subst(peRespChain:wwPos2+1:1)
     c                   enddo

     c                   if        wwPos1 < peKwdPos
     C*             shouldn't happen
     c                   return
     c                   endif

     c                   eval      wwLen = (wwPos1 - peKwdPos) + 1
     c                   eval      wwAuth = %subst( peRespChain:
     c                                              peKwdPos: wwLen)

     C*********************************************************
     C* Check if we deal with basic authentication
     C*********************************************************
     c     upper:lower   xlate     peRespChain   wwAuth

     c                   eval      wwPos1 = %scan('basic':wwAuth)
     c                   if        wwPos1 > 0
     c                   eval      dsProxyAuthBasic = *on

     c* Extract the realm, if provided
     c                   eval      wwPos1 = %scan('realm="': wwAuth:
     c                                  wwPos1)
     c                   if        wwPos1 > 0
     c                   eval      wwPos1 = wwPos1 + 7
     c                   eval      wwPos2 = %scan('"': wwAuth: wwPos1)
     c                   if        wwPos2 > wwPos1
     c                   eval      wwLen = wwPos2 - wwPos1
     c                   eval      dsProxyAuthRealm = %subst(peRespChain:
     c                                  wwPos1: wwLen)
     c                   endif
     c                   endif
     c                   endif

     c                   return
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_xproc():  Register a procedure to be called back at
      *                 a given exit point
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_xproc      B                   export
     D http_xproc      PI            10I 0
     D  peExitPoint                  10I 0 value
     D  peProc                         *   procptr value
     D  peUserData                     *   value options(*nopass)

     D wwUserData      s               *   inz(*NULL)

     c                   eval      p_global = getGlobalPtr()

     c                   if        %parms >= 3
     c                   eval      wwUserData = peUserData
     c                   endif

     c                   select
     c                   when      peExitPoint = HTTP_POINT_DEBUG
     c                   callp     debug_setproc(peProc: wwUserData)
     c                   when      peExitPoint = HTTP_POINT_UPLOAD_STATUS
     c                   eval      wkUplProc = peProc
     c                   eval      wkUplUData = wwUserData
     c                   when      peExitPoint = HTTP_POINT_DOWNLOAD_STATUS
     c                   eval      wkDwnlProc = peProc
     c                   eval      wkDwnlUData = wwUserData
     c                   when      peExitPoint = HTTP_POINT_ADDL_HEADER
     c                   eval      wkAddHdrProc = peProc
     c                   eval      wkAddHdrData = wwUserData
     c                   when      peExitPoint = HTTP_POINT_PARSE_HEADER
     c                   eval      wkParseHdrProc = peProc
     c                   eval      wkParseHdrData = wwUserData
     c                   when      peExitPoint = HTTP_POINT_PARSE_HDR_LONG
     c                   eval      wkParseHdrLong = peProc
     c                   eval      wkParseHdrLongData = wwUserData
     c                   when      peExitPoint = HTTP_POINT_PARSE_HDR_LONG
     c                   eval      wkParseHdrLong = peProc
     c                   eval      wkParseHdrLongData = wwUserData
      /if defined(HAVE_SSLAPI)
     c                   when      peExitPoint = HTTP_POINT_CERT_VAL
     c                   callp     commssl_setxproc( peExitPoint
     c                                             : peProc
     c                                             : wwUserData )
     c                   when      peExitPoint = HTTP_POINT_GSKIT_CERT_VAL
     c                   callp     commssl_setxproc( peExitPoint
     c                                             : peProc
     c                                             : wwUserData )
      /endif
     c                   other
     c                   callp     SetError(HTTP_BADPNT: 'Invalid exit ' +
     c                               'point!')
     c                   return    -1
     c                   endsl

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_redir_loc(): Retrieve location provided by a redirect
      *   request.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_redir_loc  B                   export
     D http_redir_loc  PI          1024A   varying
     c                   return    wkRedirLoc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_redir_loc_long(): Retrieve location provided by a redirect
      *   request -- returning a longer string.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_redir_loc_long...
     P                 B                   export
     D                 PI         32767A   varying
     c                   return    wkRedirLoc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_long_ParseURL(): Parse URL into it's component parts
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_long_ParseURL...
     P                 B                   export
     d http_long_ParseURL...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peService                    32A
     D  peUserName                   32A
     D  pePassword                   32A
     D  peHost                      256A
     D  pePort                       10I 0
     D  pePath                    32767A   varying

     D wwLen           S             10I 0
     D wwURL           S          32767A   varying
     D wwTemp          S             65A
     D wwPos           S             10I 0
     D wwRChk          S              4A
     D wwFound         S             10I 0

     D wwRelOk         s              1N   inz(*OFF)    static
     D wwLastRel       s                   like(wwURL)  static
     D wwLastPath      s                   like(pePath) static
     D NUMBERS         C                   const('0123456789')

     c                   callp     http_dmsg('http_long_ParseURL(): ' +
     c                                       'entered')

     c                   eval      peService = *Blanks
     c                   eval      peUserName = *blanks
     c                   eval      pePassword = *blanks
     c                   eval      peHost = *blanks
     c                   eval      pePort = 0
     c                   eval      pePath = *blanks
     c                   eval      wwURL = peURL

     c                   if        %len(peURL)<1 or peURL=*blanks
     c                   callp     SetError( HTTP_BADURL
     c                                     : 'URL is blank.')
     c                   return    -1
     c                   endif

      ****************************************************************
      * If this is a relative URL and we have a host & path saved
      * from a previous URL, convert it from a relative to an
      * absolute URL.
      ****************************************************************
     c                   if        wwRelOk = *ON
     c                               and %scan('://': peURL) = 0

     c                   callp     http_dmsg('Converting relative URL.')

     c                   if        %len(peURL)>=1
     c                               and %subst(peURL:1:1) = '/'
     c                   eval      wwURL = wwLastRel + peURL
     c                   else
     c                   eval      wwURL = wwLastRel + wwLastPath
     c                                   + peURL
     c                   endif

     c                   callp     http_dmsg('New URL is ' + wwURL)

     c                   endif

     C****************************************************************
     C*  A valid HTTP url should look like:
     C*      http://www.server.com/somedir/somefile.ext
     C*     https://www.server.com/somedir/somefile.ext
     C*
     C*  and may optionally contain a user name, password & port number:
     C*
     C*     http://user:passwd@www.server.com:80/somedir/somefile.ext
     C****************************************************************

     C* First, extract the URL's "scheme" (which in the case of http
     C*  is the service's name as well):
     c                   eval      wwPos = %scan(':': wwURL)
     c                   if        wwPos < 2 or wwPos > (%len(wwURL)-1)
     c                   callp     SetError(HTTP_BADURL:'Relative URLs '+
     c                              'are not supported!')
     c                   return    -1
     c                   endif

     c                   eval      peService = %subst(wwURL:1:wwPos-1)
     c                   eval      wwURL = %subst(wwURL:wwPos+1)
     c     upper:lower   xlate     peService     peService

      /if defined(HAVE_SSLAPI)
     c                   if        peService<>'http' and peService<>'https'
     c                   callp     SetError(HTTP_BADURL:'Only the http and'+
     c                              ' https protocols are available!')
     c                   return    -1
     c                   endif
      /else
     c                   if        peService<>'http'
     c                   callp     SetError(HTTP_BADURL:'Only the http ' +
     c                              'protocol is available!')
     c                   return    -1
     c                   endif
      /endif

     C* now the URL should be //www.server.com/mydir/somefile.ext!
     C*   make sure it does start with the //, and strip that off.

     c                   if        %len(wwURL) >= 2
     c                               and %subst(wwURL:1:2) <> '//'
     c                   callp     SetError(HTTP_BADURL:'Relative URLs '+
     c                              'are not supported!')
     c                   return    -1
     c                   endif

     c                   eval      wwURL = %subst(wwURL:3)

     C* now, either everything up to the first '/' is part of the
     C*  host name, or the entire string is a hostname.

     c                   eval      wwPos = %scan('/': wwURL)
     c                   if        wwPos = 0
     c                   eval      wwPos = %len(wwURL) + 1
     c                   endif

     c                   eval      peHost = %subst(wwURL:1:wwPos-1)
     c                   if        wwPos > %len(wwURL)
     c                   eval      wwURL = ''
     c                   else
     c                   eval      wwURL = %subst(wwURL:wwPos)
     c                   endif

     C* the host name may optionally contain a user name,
     C*  and possibly also a password.

     C* find the last @ symbol in the host name.  It's important
     C* to use the last one, in case the userid is an e-mail address.
     C* for example:
     c*  http://bob@nospam.com:bigboy@www.scottklement.com
     c                   eval      wwPos = 0
     c                   eval      wwFound = %scan('@': peHost)
     c                   dow       wwFound > 1 and wwFound < %size(peHost)
     c                   eval      wwPos = wwFound
     c                   eval      wwFound = %scan('@': peHost: wwFound+1)
     c                   enddo

     C* if @ was found, look for userid/password:
     c                   if        wwPos > 1 and wwPos < %size(peHost)
     c                   eval      wwTemp = %subst(peHost:1:wwPos-1)
     c                   eval      peHost = %subst(peHost:wwPos+1)
     c                   eval      wwPos = %scan(':': wwTemp)
     c                   if        wwPos > 1 and wwPos < %size(wwTemp)
     c                   eval      peUserName = %subst(wwTemp:1:wwPos-1)
     c                   eval      pePassword = %subst(wwTemp:wwPos+1)
     c                   else
     c                   eval      peUserName = wwTemp
     c                   endif
     c                   endif

     C* the host name may also specify a port number:
     c                   eval      wwPos = %scan(':': peHost)
     c                   if        wwPos > 1 and wwPos < %size(peHost)
     c                   eval      wwTemp = %subst(peHost:wwPos+1)
     c                   eval      peHost = %subst(peHost:1:wwPos-1)
     c                   if        %check(NUMBERS: %trimr(wwTemp))=0
     c                   eval      pePort = atoi(%trimr(wwTemp))
     c                   else
     c                   callp     SetError(HTTP_BADURL: 'URL contains'+
     c                              ' a bad port number!')
     c                   return    -1
     c                   endif
     c                   endif

     c* After all that, do we still have a hostname?
     c                   if        peHost=*blanks
     c                   callp     SetError(HTTP_BADURL:'URL does not'+
     c                              ' contain a hostname!')
     c                   return    -1
     c                   endif

     C* Whatever is left should now be the pathname to the file itself.
     C* (or is a parameter or query string for a CGI script)
     c                   eval      pePath = wwURL
     c                   if        %len(pePath)<1 or pePath=*blanks
     c                   eval      pePath = '/'
     c                   endif

     C*
     C*  Replace any blanks in the URL with %20 (like a browser does)
     C*
     c                   eval      pePath = %trimr(pePath)
     c                   eval      wwPos = %scan(' ': pePath)
     c                   dow       wwPos > 0
     c                   eval      pePath = %replace( '%20'
     c                                              : pePath
     c                                              : wwPos
     c                                              : 1 )
     c                   eval      wwPos = %scan(' ': pePath: wwPos)
     c                   enddo

      *
      * Save information about this URL so that we can use it to
      * figure out subsequent "relative" URLs.
      *
     c                   eval      wwLastRel = %trimr(peService) + '://'
     c                   if        peUserName <> *blanks
     c                   eval      wwLastRel = wwLastRel
     c                                       + %trim(peUserName)
     c                   if        pePassword <> *blanks
     c                   eval      wwLastRel = wwLastRel + ':'
     c                                       + %trim(pePassword)
     c                   endif
     c                   eval      wwLastRel = wwLastRel + '@'
     c                   endif
     c                   eval      wwLastRel = wwLastRel + %trim(peHost)
     c                   if        pePort <> 0
     c                   eval      wwLastRel = wwLastRel + ':'
     c                                       + %trim(%editc(pePort:'Z'))
     c                   endif

     c                   eval      wwPos = %len(pePath)
     c                   dou       wwPos <= 1
     c                   if        %subst(pePath:wwPos:1) = '/'
     c                   eval      wwLastPath = %subst(pePath:1:wwPos)
     c                   leave
     c                   endif
     c                   eval      wwPos = wwPos -1
     c                   enddo

     c                   eval      wwRelOk = *ON

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_get(): Retrieve an HTTP document (to a file)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_get    B                   export
     D http_url_get    PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peFilename                32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peReserved                   64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwFD            S             10I 0
     D rc              S             10I 0

     c                   callp     SetRespCode(0)
     c                   callp     http_dmsg('http_url_get(): entered')
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * open file for writing (O_WRONLY = write only)
      *    if it exists, truncate it (O_TRUNC = truncate)
      *    if it doesnt, create it (O_CREAT = create)
      *    and assign the remote codepage to it.
      *********************************************************
     c                   eval      wwFD = open( %trimr(peFilename)
     c                                        : O_WRONLY
     c                                          + O_TRUNC
     c                                          + O_CREAT
     c                                          + CCSID_OR_CP
     c                                          + O_LARGEFILE
     c                                        : global.file_mode
     c                                        : FILE_CCSID())
     c                   if        wwFD < 0
     c                   callp     SetError(HTTP_FDOPEN:'open(): ' +
     c                               %str(strerror(errno)) )
     c                   return    -1
     c                   endif

      *********************************************************
      *  Call the 'raw' get procedure, telling it to use
      *  the IFS API called 'write' to write data.
      *********************************************************
     c                   select
     c                   when      %parms < 3
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'))
     c                   when      %parms < 4
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'): peTimeout)
     c                   when      %parms < 5
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'): peTimeout:
     c                               peUserAgent)
     c                   when      %parms < 6
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'): peTimeout:
     c                               peUserAgent: peModTime)
     c                   when      %parms < 7
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'): peTimeout:
     c                               peUserAgent: peModTime: peReserved)
     c                   other
     c                   eval      rc = http_url_get_raw(peURL: wwFD:
     c                               %paddr('write'): peTimeout:
     c                               peUserAgent: peModTime: peReserved:
     c                               peSOAPAction)
     c                   endsl

     c                   callp     close(wwFD)

     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_post(): Post data to CGI script and get document
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post   B                   export
     D http_url_post   PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFilename                32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwFD            S             10I 0
     D rc              S             10I 0

     c                   callp     SetRespCode(0)
     c                   callp     http_dmsg('http_url_post(): entered')
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * open file for writing (O_WRONLY = write only)
      *    if it exists, truncate it (O_TRUNC = truncate)
      *    if it doesnt, create it (O_CREAT = create)
      *    and assign the remote codepage to it.
      *********************************************************
     c                   eval      wwFD = open( %trimr(peFilename)
     c                                        : O_WRONLY
     c                                          + O_TRUNC
     c                                          + O_CREAT
     c                                          + CCSID_OR_CP
     c                                          + O_LARGEFILE
     c                                        : global.file_mode
     c                                        : FILE_CCSID())
     c                   if        wwFD < 0
     c                   callp     SetError(HTTP_FDOPEN:'open(): ' +
     c                               %str(strerror(errno)) )
     c                   return    -1
     c                   endif

      *********************************************************
      *  Call the 'raw' post procedure, telling it to use
      *  the IFS API called 'write' to write data.
      *********************************************************
     c                   select
     c                   when      %parms < 5
     c                   eval      rc = http_url_post_raw(peURL:
     c                               pePostData: pePostDataLen:
     c                               wwFD: %paddr('write'))
     c                   when      %parms < 6
     c                   eval      rc = http_url_post_raw(peURL:
     c                               pePostData: pePostDataLen:
     c                               wwFD: %paddr('write'): peTimeout)
     c                   when      %parms < 7
     c                   eval      rc = http_url_post_raw(peURL:
     c                               pePostData: pePostDataLen:
     c                               wwFD: %paddr('write'): peTimeout:
     c                               peUserAgent)
     c                   when      %parms < 8
     c                   eval      rc = http_url_post_raw(peURL:
     c                               pePostData: pePostDataLen:
     c                               wwFD: %paddr('write'): peTimeout:
     c                               peUserAgent: peContentType)
     c                   other
     c                   eval      rc = http_url_post_raw(peURL:
     c                               pePostData: pePostDataLen:
     c                               wwFD: %paddr('write'): peTimeout:
     c                               peUserAgent: peContentType:
     c                               peSOAPAction)
     c                   endsl

     c                   callp     close(wwFD)

     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_get_raw(): Retrieve an HTTP document (in raw mode)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_get_raw...
     P                 B                   export
     D http_url_get_raw...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peReserved                   64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwComm          s               *
     D rc              s             10I 0

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * Connect.
      *********************************************************
     c                   if        %parms < 4
     c                   eval      wwComm = http_persist_open( peURL )
     c                   else
     c                   eval      wwComm = http_persist_open( peURL
     c                                                       : peTimeout )
     c                   endif

     c                   if        wwComm = *NULL
     c                   return    -1
     c                   endif

      *********************************************************
      * Get.
      *********************************************************
     c                   select
     c                   when      %parms < 4
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc )
     c                   when      %parms < 5
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc
     c                                                  : peTimeout )
     c                   when      %parms < 6
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc
     c                                                  : peTimeout
     c                                                  : peUserAgent )
     c                   when      %parms < 7
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc
     c                                                  : peTimeout
     c                                                  : peUserAgent
     c                                                  : peModTime )
     c                   when      %parms < 8
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc
     c                                                  : peTimeout
     c                                                  : peUserAgent
     c                                                  : peModTime
     c                                                  : peReserved )
     c                   other
     c                   eval      rc = http_persist_get( wwComm
     c                                                  : peURL
     c                                                  : peFD
     c                                                  : peProc
     c                                                  : peTimeout
     c                                                  : peUserAgent
     c                                                  : peModTime
     c                                                  : peReserved
     c                                                  : peSoapAction )
     c                   endsl

      *********************************************************
      * Disconnect.
      *********************************************************
     c                   callp     http_persist_close( wwComm )
     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_post_raw(): Post data to CGI script and get document
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post_raw...
     P                 B                   export
     D http_url_post_raw...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwComm          s               *
     D rc              s             10I 0

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * Connect.
      *********************************************************
     c                   if        %parms < 6
     c                   eval      wwComm = http_persist_open( peURL )
     c                   else
     c                   eval      wwComm = http_persist_open( peURL
     c                                                       : peTimeout )
     c                   endif

     c                   if        wwComm = *NULL
     c                   return    -1
     c                   endif

      *********************************************************
      * Post.
      *********************************************************
     c                   select
     c                   when      %parms < 6
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : 0
     c                                                   : *NULL
     c                                                   : pePostData
     c                                                   : pePostDataLen
     c                                                   : peFD
     c                                                   : peProc )

     c                   when      %parms < 7
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : 0
     c                                                   : *NULL
     c                                                   : pePostData
     c                                                   : pePostDataLen
     c                                                   : peFD
     c                                                   : peProc
     c                                                   : peTimeout )

     c                   when      %parms < 8
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : 0
     c                                                   : *NULL
     c                                                   : pePostData
     c                                                   : pePostDataLen
     c                                                   : peFD
     c                                                   : peProc
     c                                                   : peTimeout
     c                                                   : peUserAgent )
     c

     c                   when      %parms < 9
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : 0
     c                                                   : *NULL
     c                                                   : pePostData
     c                                                   : pePostDataLen
     c                                                   : peFD
     c                                                   : peProc
     c                                                   : peTimeout
     c                                                   : peUserAgent
     c                                                   : peContentType )

     c                   when      %parms < 10
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : 0
     c                                                   : *NULL
     c                                                   : pePostData
     c                                                   : pePostDataLen
     c                                                   : peFD
     c                                                   : peProc
     c                                                   : peTimeout
     c                                                   : peUserAgent
     c                                                   : peContentType
     c                                                   : peSOAPAction )
     c                   endsl

      *********************************************************
      * Disconnect.
      *********************************************************
     c                   callp     http_persist_close( wwComm )
     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_select_commdriver():  Select & initialize communications
      *    driver.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_select_commdriver...
     P                 B                   export
     D http_select_commdriver...
     D                 PI              *
     D   peCommType                  32A   const

     c                   select
     c                   when      peCommType = 'http'
     c                   eval      p_CommNew = %paddr('COMMTCP_NEW')
      /if defined(HAVE_SSLAPI)
     c                   when      peCommType = 'https'
     c                   eval      p_CommNew = %paddr('COMMSSL_NEW')
      /endif
     c                   other
     c                   callp     SetError( HTTP_NOCDRIV
     c                                     : 'No comm driver to handle '
     c                                     +  %trimr(peCommType)
     c                                     +  ' protocool' )
     c                   return    *NULL
     c                   endsl

     c                   eval      p_CommDriver = comm_new
     c                   return    p_CommDriver
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_post_raw2(): Post data to CGI script and get document
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post_raw2...
     P                 B                   export
     D http_url_post_raw2...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFD                     10I 0 value
     D  pePostProc                     *   procptr value
     D  peDataLen                    10I 0 value
     D  peSaveFD                     10I 0 value
     D  peSaveProc                     *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
     D  peDataLen64                  20i 0 value options(*nopass)

     D wwComm          s               *
     D rc              s             10I 0

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * Connect.
      *********************************************************
     c                   if        %parms < 7
     c                   eval      wwComm = http_persist_open( peURL )
     c                   else
     c                   eval      wwComm = http_persist_open( peURL
     c                                                       : peTimeout )
     c                   endif

     c                   if        wwComm = *NULL
     c                   return    -1
     c                   endif

      *********************************************************
      * Post.
      *********************************************************
     c                   select
     c                   when      %parms < 7
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc )

     c                   when      %parms < 8
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc
     c                                                   : peTimeout  )

     c                   when      %parms < 9
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc
     c                                                   : peTimeout
     c                                                   : peUserAgent )

     c                   when      %parms < 10
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc
     c                                                   : peTimeout
     c                                                   : peUserAgent
     c                                                   : peContentType )

     c                   when      %parms < 11
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc
     c                                                   : peTimeout
     c                                                   : peUserAgent
     c                                                   : peContentType
     c                                                   : peSOAPAction )

     c                   other
     c                   eval      rc = http_persist_post( wwComm
     c                                                   : peURL
     c                                                   : pePostFD
     c                                                   : pePostProc
     c                                                   : *NULL
     c                                                   : peDataLen
     c                                                   : peSaveFD
     c                                                   : peSaveProc
     c                                                   : peTimeout
     c                                                   : peUserAgent
     c                                                   : peContentType
     c                                                   : peSOAPAction
     c                                                   : peDataLen64 )
     c                   endsl

      *********************************************************
      * Disconnect.
      *********************************************************
     c                   callp     http_persist_close( wwComm )
     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_post_stmf(): Post data to CGI script from stream file
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post_stmf...
     P                 B                   export
     D http_url_post_stmf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFile                32767A   varying const options(*varsize)
     D  peRecvFile                32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwPostFD        S             10I 0
     D wwRecvFD        S             10I 0
     D wwDataSize      s             10I 0
     D wwDataSize64    s             20I 0
     D rc              S             10I 0
     D wwStat          ds                  likeds(statds64)
     D wwTimeout       s                   like(peTimeout) inz(HTTP_TIMEOUT)
     D p_UserAgent     s               *   inz(*null)
     D wwUserAgent     s          16384a   varying
     D                                     based(p_UserAgent)
     D stgUserAgent    s          16384a   varying
     D p_ContentType   s               *   inz(*null)
     D wwContentType   s          16384a   varying
     D                                     based(p_ContentType)
     D stgContentType  s          16384a   varying
     D p_SOAPAction    s               *   inz(*null)
     D wwSOAPAction    s          16384a   varying
     D                                     based(p_SOAPAction)
     D stgSOAPAction   s          16384a   varying

     c                   callp     SetRespCode(0)
     c                   callp     http_dmsg('http_url_post_stmf(): ' +
     c                                      'entered')
     c                   eval      p_global = getGlobalPtr()

      *********************************************************
      * open file to be posted
      *********************************************************
     c                   callp     http_dmsg('getting post file size...')
     c                   if        stat64(pePostFile: wwStat) < 0
     c                   callp     SetError(HTTP_FDSTAT:'stat64(): ' +
     c                                        %str(strerror(errno)) )
     c                   return    -1
     c                   endif

     c                   if        wwStat.st_size > 2147483647
     c                   eval      wwDataSize64 = wwStat.st_size
     c                   eval      wwDataSize = 0
     c                   else
     c                   eval      wwDataSize = wwStat.st_size
     c                   eval      wwDataSize64 = 0
     c                   endif

     c                   callp     http_dmsg('opening file to be sent...')
     c                   eval      wwPostFD = open( %trimr(pePostFile)
     c                                            : O_LARGEFILE + O_RDONLY )
     c                   if        wwPostFD < 0
     c                   callp     SetError(HTTP_FDOPEN:'open(): ' +
     c                                        %str(strerror(errno)) )
     c                   return    -1
     c                   endif

      *********************************************************
      * do something to handle optional parameters
      *********************************************************
     c                   if         %parms >= 4
     c                   eval       wwTimeout = peTimeout
     c                   endif

     c                   if         %parms >= 5 
     c                              and %addr(peUserAgent) <> *null
     c                   eval       p_UserAgent = %addr(stgUserAgent)
     C                   eval       stgUserAgent = getSA(peUserAgent)
     c                   endif
     
     c                   if         %parms >= 6 
     c                              and %addr(peContentType) <> *null
     c                   eval       p_ContentType = %addr(stgContentType)
     C                   eval       stgContentType = getSA(peContentType)
     c                   endif
     
     c                   if         %parms >= 7
     c                              and %addr(peSOAPAction) <> *null
     c                   eval       p_SOAPAction = %addr(stgSOAPAction)
     C                   eval       stgSOAPAction = getSA(peSOAPAction)
     c                   endif

      *********************************************************
      * open file for writing (O_WRONLY = write only)
      *    if it exists, truncate it (O_TRUNC = truncate)
      *    if it doesnt, create it (O_CREAT = create)
      *    allow >2gb files (O_LARGEFILE)
      *    and assign the remote codepage to it.
      *********************************************************
     c                   callp     http_dmsg('opening file to be received')
     c                   eval      wwRecvFD = open( %trimr(peRecvFile)
     c                                            : O_WRONLY
     c                                            + O_TRUNC
     c                                            + O_CREAT
     c                                            + CCSID_OR_CP
     c                                            + O_LARGEFILE
     c                                            : global.file_mode
     c                                            : FILE_CCSID()
     c                                            )
     c                   if        wwRecvFD < 0
     c                   callp     SetError(HTTP_FDOPEN:'open(): ' +
     c                               %str(strerror(errno)) )
     c                   callp     close(wwPostFD)
     c                   return    -1
     c                   endif

      *********************************************************
      *  Call the 'raw' post procedure, telling it to use
      *  the IFS API called 'write' to write data.
      *********************************************************
     
     c                   eval      rc = http_url_post_raw2( peURL
     c                                                    : wwPostFD
     c                                                    : %paddr('read')
     c                                                    : wwDataSize
     c                                                    : wwRecvFD
     c                                                    : %paddr('write')
     c                                                    : wwTimeout
     c                                                    : wwUserAgent
     c                                                    : wwContentType
     c                                                    : wwSOAPAction
     c                                                    : wwDataSize64 )

     c                   callp     close(wwPostFD)
     c                   callp     close(wwRecvFD)
     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist_open(): Open a persistent HTTP session
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist_open...
     P                 B                   export
     D http_persist_open...
     D                 PI              *
     D  peURL                     32767A   varying const options(*varsize)
     D  peTimeout                    10I 0 value options(*nopass)

     D wwTimeout       S             10I 0
     D wwServ          S             32A
     D wwUser          S             32A
     D wwPass          S             32A
     D wwHost          S            256A
     D wwPort          S             10I 0
     D wwOrigHost      S            256A
     D wwOrigPort      S             10I 0
     D wwPath          S          32767A   varying
     D wwComm          s               *
     D p_addr          s               *

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

     c                   callp     http_dmsg('http_persist_open():'
     c                                     + ' entered')

      *********************************************************
      * Set up optional parameters (timeout)
      *********************************************************
     c                   if        %parms>=2 and peTimeout>=0
     c                   eval      wwTimeout = peTimeout
     c                   else
     c                   eval      wwTimeout = HTTP_TIMEOUT
     c                   endif

      *********************************************************
      *  Parse URL into it's components
      *********************************************************
     c                   if        http_long_ParseURL(peURL: wwServ: wwUser:
     c                                wwPass: wwHost: wwPort: wwPath) < 0
     c                   return    *NULL
     c                   endif

      *********************************************************
      *  Proxy address provided?
      *********************************************************
     c                   eval      wwOrigHost = wwHost
     c                   eval      wwOrigPort = wwPort

     c                   if        dsProxyHost <> *blanks
     c                   eval      wwHost = dsProxyHost
     c                   endif

     c                   if        dsProxyPort <> *zeros
     c                   eval      wwPort = dsProxyPort
     c                   endif

     c                   if        dsProxyHost <> *blanks
     c                               and wwServ='https'
     c                   eval      dsProxyTun = *ON
     c                   else
     c                   eval      dsProxyTun = *OFF
     c                   endif

      *********************************************************
      *  Select comm driver & build a socket address structure
      *********************************************************
     c                   eval      wwComm = http_select_commdriver(wwServ)
     c                   if        wwComm = *NULL
     c                   return    *NULL
     c                   endif

     c                   eval      p_addr = comm_resolve( wwComm
     c                                                  : %trimr(wwHost)
     c                                                  : %trimr(wwServ)
     c                                                  : wwPort
     c                                                  : *OFF    )

     c                   if        p_addr = *NULL
     c                   callp     comm_cleanup(wwComm)
     c                   return    *NULL
     c                   endif

      *********************************************************
      * Connect to server
      *********************************************************
     c                   if        comm_Connect( wwComm
     c                                         : p_addr
     c                                         : wwTimeout
     c                                         ) = *OFF
     c                   callp     comm_cleanup(wwComm)
     c                   return    *NULL
     c                   endif

      *********************************************************
      * Establish proxy tunnelling if necessary
      *********************************************************
     c                   if        dsProxyTun = *ON
     c                   if        proxy_tunnel( wwComm
     c                                         : wwServ
     C                                         : wwOrigHost
     c                                         : wwOrigPort
     c                                         : wwTimeout ) <> 0
     c                   callp     comm_cleanup(wwComm)
     c                   callp     http_persist_close( wwComm )
     c                   return    *NULL
     c                   endif
     c                   endif

      *********************************************************
      * Upgrade connection security (if driver supports it)
      * (if wwComm is the SSL driver, this starts SSL encryption)
      *
      * Note: the endpoint hostname is passed here so that
      *       TLS server name indicator (SNI) knows the host
      *       name (even if connecting via a proxy)
      *********************************************************
     c                   if        comm_Upgrade( wwComm
     c                                         : wwTimeout
     c                                         : %trimr(wwOrigHost)
     c                                         ) = *OFF
     c                   callp     comm_cleanup(wwComm)
     c                   return    *NULL
     c                   endif

     c                   return    wwComm
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist_get(): GET an HTTP resource using a persistent session
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist_get...
     P                 B                   export
     D http_persist_get...
     D                 PI            10I 0
     D  peComm                         *   value
     D  peURL                     32767A   varying const options(*varsize)
     D  peFD                         10I 0 value
     D  peProc                         *   value procptr
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwUA            S          16384A   varying
     D wwMT            S               Z
     D wwCT            S          16384a   varying
     D wwSA            S          32767A   varying
     D wwTimeout       S             10I 0
     D p_UserAgent     S               *
     D wwUserAgent     S          16384A   varying based(p_UserAgent)
     D p_ModTime       S               *
     D wwModTime       S               Z   based(p_ModTime)
     D p_ContentType   S               *
     D wwContentType   S          16384A   varying based(p_ContentType)
     D p_SOAPAction    S               *
     D wwSOAPAction    S          32767A   varying based(p_SOAPAction)

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

     c                   callp     http_dmsg('http_persist_get():'
     c                                     + ' entered')

      *********************************************************
      * Set up optional parameters
      *********************************************************
      * If no timeout given, default to 5 minutes
     c                   if        %parms>=5 and peTimeout>=0
     c                   eval      wwTimeout = peTimeout
     c                   else
     c                   eval      wwTimeout = HTTP_TIMEOUT
     c                   endif

      * If no user-agent given, pass '*OMIT' to next proc
     c                   if        %parms >= 6
     c                             and %addr(peUserAgent)<>*null
     c                   eval      p_UserAgent = %addr(wwUA)
     c                   eval      wwUserAgent = getSA(peUserAgent)
     c                   else
     c                   eval      p_UserAgent = *NULL
     c                   endif

      * If no mod time given, pass '*OMIT' to next proc
     c                   if        %parms >= 7
     c                             and %addr(peModTime)<>*null
     c                   eval      p_ModTime = %addr(wwMT)
     c                   eval      wwModTime = peModTime
     c                   else
     c                   eval      p_ModTime = *NULL
     c                   endif

      * If no content-type given, pass '*OMIT' to next proc
     c                   if        %parms >= 8
     c                             and %addr(peContentType)<>*null
     c                   eval      p_ContentType = %addr(wwCT)
     c                   eval      wwContentType = getSA(peContentType)
     c                   else
     c                   eval      p_ContentType = *NULL
     c                   endif

      * If no SoapAction given, pass '*OMIT' to next proc
     c                   if        %parms >= 9
     c                             and %addr(peSoapAction)<>*null
     c                   eval      p_SOAPAction = %addr(wwSA)
     c                   eval      wwSOAPAction = getSA(peSOAPAction)
     c                   else
     c                   eval      p_SOAPAction = *NULL
     c                   endif

     c                   return    http_persist_req( 'GET'
     c                                             : peComm
     c                                             : peURL
     c                                             : 0
     c                                             : *null
     c                                             : *null
     c                                             : 0
     c                                             : peFD
     c                                             : peProc
     c                                             : wwTimeout
     c                                             : wwUserAgent
     c                                             : wwContentType
     c                                             : wwSoapAction
     c                                             : wwModTime )

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist_post(): POST data to an HTTP resource, and get back
      *                       response using a persistent connection
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist_post...
     P                 B                   export
     D http_persist_post...
     D                 PI            10I 0
1    D  peComm                         *   value
2    D  peURL                     32767A   varying const options(*varsize)
3    D  pePostFD                     10I 0 value
4    D  pePostProc                     *   value procptr
5    D  pePostData                     *   value
6    D  pePostDataLen                10I 0 value
7    D  peSaveFD                     10I 0 value
8    D  peSaveProc                     *   value procptr
9    D  peTimeout                    10I 0 value options(*nopass)
10   D  peUserAgent                  64A   const options(*nopass:*omit)
11   D  peContentType                64A   const options(*nopass:*omit)
12   D  peSOAPAction                 64A   const options(*nopass:*omit)
13   D  pePostDataLen64...
     D                               20i 0 value options(*nopass)

     D wwUA            S          16384A   varying
     D wwCT            S          16384A   varying
     D wwSA            S          32767A   varying
     D wwTimeout       S             10I 0
     D p_UserAgent     S               *
     D wwUserAgent     S          16384A   varying based(p_UserAgent)
     D p_ContentType   S               *
     D wwContentType   S          16384A   varying based(p_ContentType)
     D p_SOAPAction    S               *
     D wwSOAPAction    S          32767A   varying based(p_SOAPAction)
     D dataLen         s             10i 0
     D dataLen64       s             20i 0

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()
     c                   callp     http_dmsg('http_persist_post(): entered')

      *********************************************************
      *  Handle the optional parameters
      *********************************************************
      * If no timeout, default to 5 mins
     c                   if        %parms>=9 and peTimeout>=0
     c                   eval      wwTimeout = peTimeout
     c                   else
     c                   eval      wwTimeout = HTTP_TIMEOUT
     c                   endif

      * If no user-agent, pass '*OMIT' to next proc
     c                   if        %parms>=10
     c                             and %addr(peUserAgent)<>*null
     c                   eval      p_UserAgent = %addr(wwUA)
     c                   eval      wwUserAgent = getSA(peUserAgent)
     c                   else
     c                   eval      p_UserAgent = *NULL
     c                   endif

      * If no content-type, pass '*OMIT' to next proc
     c                   if        %parms>=11
     c                             and %addr(peContentType)<>*null
     c                   eval      p_ContentType = %addr(wwCT)
     c                   eval      wwContentType = getSA(peContentType)
     c                   else
     c                   eval      p_ContentType = *NULL
     c                   endif

      * If no SOAPaction, pass '*OMIT' to next proc
     c                   if        %parms>=12
     c                             and %addr(peSoapAction)<>*null
     c                   eval      p_SOAPAction = %addr(wwSA)
     c                   eval      wwSOAPAction = getSA(peSOAPAction)
     c                   else
     c                   eval      p_SOAPAction = *NULL
     c                   endif

      * If no 64-bit data length, use the 32-bit one
     c                   if        %parms>=13
     c                             and pePostDataLen64 > 0
     c                   eval      dataLen64 = pePostDataLen64
     c                   eval      dataLen = 0
     c                   else
     c                   eval      dataLen = pePostDataLen
     c                   eval      dataLen64 = 0
     c                   endif

     c                   return    http_persist_req( 'POST'
     c                                             : peComm
     c                                             : peURL
     c                                             : pePostFD
     c                                             : pePostProc
     c                                             : pePostData
     c                                             : dataLen
     c                                             : peSaveFD
     c                                             : peSaveProc
     c                                             : wwTimeout
     c                                             : wwUserAgent
     c                                             : wwContentType
     c                                             : wwSoapAction
     c                                             : *omit
     c                                             : dataLen64 )

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist_req(): Perform (any) Persistent HTTP Request
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist_req...
     P                 B                   export
     D http_persist_req...
     D                 PI            10I 0
1    D  peMethod                     10a   varying const
2    D  peComm                         *   value
3    D  peURL                     32767A   varying const options(*varsize)
4    D  peUplFD                      10I 0 value
5    D  peUplProc                      *   value procptr
6    D  peUplData                      *   value
7    D  peUplDataLen                 10I 0 value
8    D  peSaveFD                     10I 0 value
9    D  peSaveProc                     *   value procptr
10   D  peTimeout                    10I 0 value options(*nopass)
11   D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
12   D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
13   D  peSoapAction              32767A   varying const
     D                                     options(*nopass:*omit)
14   D  peModTime                      Z   const options(*nopass:*omit)
15   D  peUplDataLen64...
     D                               20i 0 value options(*nopass)

     D wwMethod        s                   like(peMethod)
     D wwUA            S          16384A   varying
     D wwCT            S          16384A   varying
     D wwSA            S          32767A   varying
     D wwTimeout       S             10I 0
     D p_UserAgent     S               *
     D wwUserAgent     S          16384A   varying based(p_UserAgent)
     D p_ContentType   S               *
     D wwContentType   S          16384A   varying based(p_ContentType)
     D p_SOAPAction    S               *
     D wwSOAPAction    S          32767A   varying based(p_SOAPAction)
     D wwServ          S             32A
     D wwUser          S             32A
     D wwPass          S             32A
     D wwHost          S            256A
     D wwPort          S             10I 0
     D wwPath          S          32767A   varying
     D rc              S             10I 0
     D wwUplProc       s               *   procptr
     D wwSecure        s              1N   inz(*OFF)
     D wwUplData       s                   like(peUplData) inz(*null)
     D p_ModTime       S               *
     D wwModTime       S               Z   based(p_ModTime)
     D wwMT            S               Z
     D wwFreeData      S              1N   INZ(*OFF)
     D dataLen         s             20i 0

     c                   eval      RDWR_Reader_p = *null
     c                   eval      RDWR_Writer_p = *null

     c                   callp     SetRespCode(0)
     c                   eval      p_global = getGlobalPtr()

     c                   eval      wwMethod = %trim(peMethod)
     c     lower:upper   xlate     wwMethod      wwMethod

     c                   callp     http_dmsg('http_persist_req('
     c                                      + wwMethod + ') entered.')

      *********************************************************
      *  Handle the optional parameters
      *********************************************************
      * If no timeout, default to 5 mins
     c                   if        %parms>=10 and peTimeout>=0
     c                   eval      wwTimeout = peTimeout
     c                   else
     c                   eval      wwTimeout = HTTP_TIMEOUT
     c                   endif

      * If no user-agent, pass '*OMIT' to next proc
     c                   if        %parms>=11
     c                             and %addr(peUserAgent)<>*null
     c                   eval      p_UserAgent = %addr(wwUA)
     c                   eval      wwUserAgent = peUserAgent
     c                   else
     c                   eval      p_UserAgent = *NULL
     c                   endif

      * If no content-type, pass '*OMIT' to next proc
     c                   if        %parms>=12
     c                             and %addr(peContentType)<>*null
     c                   eval      p_ContentType = %addr(wwCT)
     c                   eval      wwContentType = peContentType
     c                   else
     c                   eval      p_ContentType = *NULL
     c                   endif

      * If no SOAPaction, pass '*OMIT' to next proc
     c                   if        %parms>=13
     c                             and %addr(peSoapAction)<>*null
     c                   eval      p_SOAPAction = %addr(wwSA)
     c                   eval      wwSOAPAction = peSOAPAction
     c                   else
     c                   eval      p_SOAPAction = *NULL
     c                   endif

      * If no mod time given, pass '*OMIT' to next proc
     c                   if        %parms >= 14
     c                             and %addr(peModTime)<>*null
     c                             and peModTime <> *loval
     c                   eval      p_ModTime = %addr(wwMT)
     c                   eval      wwModTime = peModTime
     c                   else
     c                   eval      p_ModTime = *NULL
     c                   endif

      * if no 64-bit data length, use the 32-bit one
     c                   if        %parms >= 15 
     c                             and peUplDataLen64 > 0
     c                   eval      dataLen = peUplDataLen64
     c                   else
     c                   eval      dataLen = peUplDataLen
     c                   endif

      *********************************************************
      *  Parse URL into it's components, and then look up
      *  host & build a socket address structure:
      *********************************************************
     c                   if        http_long_ParseURL( peURL
     c                                               : wwServ
     c                                               : wwUser
     c                                               : wwPass
     c                                               : wwHost
     c                                               : wwPort
     c                                               : wwPath ) < 0
     c                   return    -1
     c                   endif

     c                   if        wwServ = 'https'
     c                   eval      wwSecure = *ON
     c                   endif

     c                   callp     setUrlAuth(wwUser: wwPass)

      *********************************************************
      * Negotiate NTLM
      *********************************************************
      *
      /if defined(NTLM_SUPPORT)
     c                   if        AuthPlugin_negotiateAuthentication(
     c                                peComm: peURL: wwTimeout) < 0
     c                   return    -1
     c                   endif
      /endif

      *********************************************************
      * Translate Upload data to remote character encoding
      *  (if necessary)
      *
      * NOTE: Sizes larger than 2gb are currently only allowed
      *       when using an upload proc.
      *********************************************************
     c                   eval      wwUplData = peUplData
     c                   if        dataLen>0 and peUplProc=*NULL
     c                   if        dataLen > 2147483647
     c                   eval      dataLen = 2147483647
     c                   endif
     c                   eval      dataLen = http_xlatedyn( dataLen
     c                                                    : peUplData
     c                                                    : TO_ASCII
     c                                                    : wwUplData )
     c                   if        dataLen = -1
     c                   return    -1
     c                   endif
     c                   eval      wwFreeData = *on
     c                   endif

      *********************************************************
      * Perform the requested method
      *********************************************************
     c                   if        peUplProc = *NULL
     c                   eval      wwUplProc = %paddr('SENDDOC')
     c                   else
     c                   eval      wwUplProc = %paddr('SENDRAW')
     c                   eval      wwUplData = *NULL
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs before do_oper')
      /endif

     c                   eval      rc = do_oper( wwMethod
     c                                         : peSaveProc
     c                                         : wwUplProc
     c                                         : wwUplData
     c                                         : dataLen 
     c                                         : peComm
     c                                         : peSaveFD
     c                                         : wwTimeout
     c                                         : wwPath
     c                                         : wwHost
     c                                         : wwModTime
     c                                         : wwUserAgent
     c                                         : wwContentType
     c                                         : wwSOAPAction
     c                                         : peUplProc
     c                                         : peUplFD
     c                                         : wwPort
     c                                         : wwSecure
     c                                         : wwServ
     c                                         : *OFF
     c                                         )

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after do_oper')
      /endif

     c                   if        wkSaveAuth <> *blanks
     c                   eval      dsAuth = wkSaveAuth
     c                   eval      wkSaveAuth = *blanks
     c                   endif

     c                   if        wwFreeData = *ON and wwUplData <> *Null
     c                   callp     xdealloc(wwUplData)
     c                   endif

     c                   return    rc
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist_close(): End a persistent HTTP session
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist_close...
     P                 B                   export
     D http_persist_close...
     D                 PI            10I 0
     D  peComm                         *   value
     c                   eval      p_global = getGlobalPtr()
     c                   return    http_close( 0 : peComm)
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * parse important fields from the response chain
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P parse_resp_chain...
     P                 B
     D parse_resp_chain...
     D                 PI            10I 0
     D  peRespChain               32767A   varying const
     D  peRC                         10I 0
     D  peTE                         32A
     D  peCLen                       10u 0
     D  peUseCL                       1N
     D  peAuthErr                     1N
     D  peProxyAuthErr...
     D                                1N
     D  peHost                      256A   varying const
     D  pePath                      256A   varying const

     D wwChain         S          32767A   varying
     D wwPos           S             10I 0
     D wwPos2          S             10I 0
     D wwCL            S             32A
     D LF              S              1A   inz(x'25') static
     D CRLF            S              2A   inz(x'0d25') static
     D wwResetAuth     S              1N   inz(*Off)
     D wwContent       s              1N   inz(*on)

     c                   select
     c                   when      peRC = 401
     c                   eval      peAuthErr = *on

     c                   when      peRC = 407
     c                   eval      peProxyAuthErr = *on

     c                   when      peRC<=100 or peRC=204 or peRC=304
     c****               return    peRC
     c                   eval      wwContent = *off
     c                   callp     http_dmsg('No content expected with '
     c                                + %trim(%editc(peRC:'P')))
     c                   endsl

      *********************************************************
      * Make an uppercase copy of the response chain so
      * we can do case-insensitive searching on it.
      *********************************************************
     c                   eval      wwChain = peRespChain
     c     upper:lower   xlate     wwChain       wwChain

      *********************************************************
      * parse out transfer-encoding:
      *********************************************************
     c                   if        wwContent = *on

     c                   eval      peTE = 'identity'
     c                   eval      wwPos = %scan(LF+'transfer-encoding:':
     c                                  wwChain)
     c                   if        wwPos > 0
     c                   eval      wwPos = wwPos + 19
     c                   eval      wwPos2 = %scan(CRLF:wwChain:wwPos)
     c                   eval      wwPos2 = wwPos2 - wwPos
     c                   if        wwPos2 > 0
     c                   eval      peTE= %trim(%subst(wwChain:wwPos:wwPos2))
     c                   endif
     c                   endif

     c                   if        %scan('chunked': peTE)=0  and
     c                               %scan('identity': peTE)=0
     c                   callp     SetError(HTTP_XFRENC: 'The "' +
     c                              %trim(peTE) + '" transfer encoding is'+
     c                              ' not supported.')
     c                   return    -1
     c                   endif

     c                   endif
      *********************************************************
      *  parse out content-length if using "identity,"
      *   (this is irrelevant for "chunked")
      *********************************************************
     c                   if        wwContent = *on

     c                   eval      wwCL = '0'
     c                   eval      peUseCL = *OFF
     c                   if        %scan('identity': peTE) > 0
     c                   eval      wwPos = %scan(LF+'content-length:':
     c                                           wwChain)
     c                   if        wwPos > 0
     c                   eval      wwPos = wwPos + 16
     c                   eval      wwPos2 = %scan(CRLF:wwChain:wwPos)
     c                   eval      wwPos2 = wwPos2 - wwPos
     c                   if        wwPos2 > 0
     c                   eval      wwCL= %trim(%subst(wwChain:wwPos:wwPos2))
     c                   eval      peUseCL = *ON
     c                   endif
     c                   endif
     c                   endif
     c                   eval      peCLen = atoll(wwCL)

     c                   callp     http_dmsg('recvdoc parms: '+%trim(peTE)+
     c                                ' ' + %trim(%editc(peCLen:'P')))

     c                   endif
      *********************************************************
      * parse out www-authenticate: header:
      * (used when userid/password for actual site is required)
      *********************************************************
     c                   eval      wwPos=%scan('www-authenticate:':wwChain)
     c                   if        wwPos > 0
     c                   eval      wwResetAuth = *On

     c                   dow       wwPos > 0
     c                   callp     interpret_auth(peRespChain:wwPos:wwResetAuth)
     c                   eval      wwPos=%scan('www-authenticate:':wwChain:
     c                               wwPos+1)
     c                   eval      wwResetAuth = *Off
     c                   enddo
     c                   endif

     c                   if        peAuthErr = *On
     c                   callp     SetError(HTTP_NDAUTH:'This page requires' +
     c                               ' a user-id & password')
     c**                 return    -1
     c                   endif

      *********************************************************
      * parse proxy-authenticate: header
      * (used when userid/password for proxy is required)
      * this header may occur more than once (especially on
      * MS ISA servers, where Kerberos, NTLM, Basic, etc.
      * may be provided)
      *********************************************************
     c                   eval      dsProxyAuthBasic = *off
     c                   eval      dsProxyAuthRealm = *blanks
     c                   eval      wwPos=%scan(LF+'proxy-authenticate:':wwChain)
     c                   dow       wwPos > 0
     c                   callp     interpret_proxy_auth(peRespChain: wwPos)
     c                   eval      wwPos=%scan(LF+'proxy-authenticate:':wwChain:
     c                               wwPos+1)
     c                   enddo

     c                   if        peProxyAuthErr = *On
     c                   callp     SetError(HTTP_PXNDAUTH:'This proxy ' +
     c                               ' requires a user-id & password')
     c**                 return    -1
     c                   endif

      *********************************************************
      * parse out 'location:' header:
      *  (used for redirects)
      *********************************************************
     c                   eval      %len(wkRedirLoc) = 0
     c                   eval      wwPos = %scan(LF+'location:':
     c                                           wwChain)
     c                   if        wwPos > 0
     c                   eval      wwPos = wwPos + 11
     c                   eval      wwPos2 = %scan(CRLF:wwChain:wwPos)
     c                   eval      wwPos2 = wwPos2 - wwPos
     c                   if        wwPos2 > 0
     c                   eval      wkRedirLoc =
     c                             %trim(%subst(peRespChain:wwPos:wwPos2))
     c                   endif
     c                   endif

      *********************************************************
      * Call HTTP header parsing module
      *********************************************************
      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs before header_parse')
      /endif
     c                   callp     header_parse(peRespChain: *NULL)

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs before load_cookies')
      /endif
     c                   if        global.use_cookies = *on
     c                   callp     header_load_cookies(peHost: pePath)
     c                   endif

      /if defined(MEMCOUNT)
     c                   callp     memStatus('allocs after load_cookies')
      /endif

      *********************************************************
      * Call user supplied parsing proc if available
      *********************************************************
     c                   if        wkParseHdrProc <> *NULL
     c                   callp     parse_hdrs(peRespChain: wkParseHdrdata)
     c                   endif
     c                   if        wkParseHdrLong <> *NULL
     c                   callp     parse_hdr_long( peRespChain
     c                                           : wkParseHdrLongData )
     c                   endif

     c                   return    peRC
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_set_100_timeout(): Set value for 100-continue timeouts.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_set_100_timeout...
     P                 B                   export
     D http_set_100_timeout...
     D                 PI
     D peTimeout                     10P 3 value
     c                   eval      p_global = getGlobalPtr()
     c                   eval      global.timeout100 = peTimeout
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_use_cookies(): Turns on/off HTTPAPI's cookie parsing and
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_use_cookies...
     P                 B                   export
     D http_use_cookies...
     D                 PI
     D   peSetting                    1N   const
     c                   eval      p_global = getGlobalPtr()
     c                   eval      global.use_cookies = peSetting
     P                 E

      ****************************************************************
      * Proxy support                                                *
      ****************************************************************

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_proxy_setauth():   Set HTTP Proxy Authentication Information
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_proxy_setauth...
     P                 B                   export
     D http_proxy_setauth...
     D                 PI            10I 0
     D   peAuthType                   1A   const
     D   peUsername                  80A   const
     D   pePasswd                  1024A   const

     D wwString        S           1105A
     D wwEncoded       S           1476A
     D wwEncLen        S             10I 0

     c                   callp     http_dmsg('http_proxy_setauth(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   if        peAuthType<>HTTP_AUTH_BASIC
     c                               and peAuthType<>HTTP_AUTH_NONE
     c                   callp     SetError(HTTP_ATHTYP: 'Invalid authenti'+
     c                                   'cation type!')
     c                   return    -1
     c                   endif

     C*************************************************
     c* Calculate strings for NO authentication
     C*************************************************
     c                   if        peAuthType = HTTP_AUTH_NONE
     c                   eval      dsProxyAuthType = HTTP_AUTH_NONE
     c                   eval      dsProxyAuthStr = ''
     c                   return    0
     c                   endif

     c                   if        %scan(':':peUserName) > 0
     c                   callp     SetError(HTTP_ATHVAL: 'HTTP Proxy Auth '+
     c                               'values cannot contain a colon!')
     c                   return    -1
     c                   endif

     c                   eval      dsProxyAuthUser = peUserName
     c                   eval      dsProxyAuthPasswd = pePasswd

     c                   eval      wwString = %trimr(peUserName) + ':' +
     c                                        %trimr(pePasswd)
     c                   callp     http_xlate( %len(%trimr(wwString))
     c                                       : wwString
     c                                       : TO_ASCII )

     c                   eval      wwEncLen = base64_encode(%addr(wwString):
     c                                             %len(%trimr(wwString)):
     c                                             %addr(wwEncoded):
     c                                             %size(wwEncoded))

     c                   eval      dsProxyAuthStr = %subst(wwEncoded:1:wwEncLen)
     c                   eval      dsProxyAuthType = peAuthType

     c                   return    0
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_setproxy():   Set HTTP Proxy Address
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_setproxy   B                   export
     D http_setproxy   PI            10I 0
     D   peHost                     256A   const
     D   pePort                      10I 0 const

     c                   eval      p_global = getGlobalPtr()
     c                   eval      dsProxyHost = peHost
     c                   eval      dsProxyPort = pePort
     c                   eval      dsProxyTun  = *off

     c                   return    0

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_proxy_getauth():   Get HTTP Proxy Authentication Information
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_proxy_getauth...
     P                 B                   export
     D http_proxy_getauth...
     D                 PI            10I 0
     D   peBasic                      1N
     D   peRealm                    124A

     c                   callp     http_dmsg('http_proxy_getauth(): entered')
     c                   eval      p_global = getGlobalPtr()
     c                   if        dsProxyAuthRealm = *blanks
     c                   callp     SetError(HTTP_NOAUTH: 'Proxy did ' +
     c                              'not ask for authentication!')
     c                   return    -1
     c                   endif

     c                   eval      peBasic = dsProxyAuthBasic
     c                   eval      peRealm = dsProxyAuthRealm

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * proxy_tunnel(): This establishes a tunnel through a proxy,
      *                 this lets us communicate directly with the
      *                 destination HTTP server (required for SSL)
      *
      *    peComm = Communication driver
      *    peServ = Service (http or https)
      *    peHost = destination (not proxy) host
      *    pePort = destination port number
      * peTimeout = timeout
      *
      * returns 0 if successful, otherwise an HTTP response number
      *         or -1 upon internal error
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P proxy_tunnel    B
     D proxy_tunnel    PI            10I 0
     D   peComm                        *   value
     D   peServ                      32a   const
     D   peHost                     256a   const
     D   pePort                      10i 0 value
     D   peTimeout                   10i 0 value

     D wwReq           S          32767A   varying
     D wwResp          s          32767A   varying

     D rc              S             10I 0
     D wwPort          S             10I 0
     D wwTE            S             32A
     D wwClen          s             10U 0
     D wwUseCL         s              1N
     D wwAuthErr       S              1N   inz(*OFF)
     D wwProxyAuthErr...
     D                 S              1N   inz(*OFF)

      *************************************************
      * Create proxy tunnelling request string
      *************************************************
     c                   eval      wwPort = pePort

     c                   if        pePort=0
     c                   if        peServ='https'
     c                   eval      wwPort=443
     c                   else
     c                   eval      wwPort=80
     c                   endif
     c                   endif

     c                   eval      wwReq = 'CONNECT ' + %trim(peHost)
     c                                   + ':' + %trim(%editc(wwPort:'L'))
     c                                   + ' HTTP/1.1'
     C                                   + CRLF

     c                   if        pePort = 0
     c                   eval      wwReq = wwReq
     C                                   + 'Host: ' + %trim(peHost)
     C                                   + CRLF
     c                   else
     c                   eval      wwReq = wwReq
     C                                   + 'Host: ' + %trim(peHost)
     c                                   + ':' + %trim(%editc(pePort:'L'))
     C                                   + CRLF
     c                   endif

     c                   eval      wwReq = wwReq
     C                                   + 'User-Agent: ' + HTTP_USERAGENT
     C                                   + CRLF
     c                                   + 'Proxy-Connection: keep-alive'
     c                                   + CRLF

     c                   if        dsProxyAuthType = HTTP_AUTH_BASIC
     c                   eval      wwReq = wwReq
     c                                   + 'Proxy-Authorization: Basic '
     c                                   + dsProxyAuthStr + CRLF
     c                   endif

     C                   eval      wwReq = wwReq + CRLF

      *************************************************
      * Send request to proxy server
      *************************************************
     c                   eval      rc = SendReq( peComm
     c                                         : %addr(wwReq)+VARPREF
     c                                         : %len(wwReq)
     c                                         : peTimeout )
     c                   if        rc < 1
     c                   return    rc
     c                   endif

      *************************************************
      * Receive & parse proxy server's response.
      *************************************************
     c                   eval      rc = RecvResp( peComm
     c                                          : wwResp
     c                                          : %size(wwResp)
     c                                          : peTimeout
     c                                          : *OFF )
     c                   if        rc < 1
     c                   return    rc
     c                   endif

     c                   eval      rc = parse_resp_chain( wwResp
     c                                                  : rc
     c                                                  : wwTE
     c                                                  : wwCLen
     c                                                  : wwUseCL
     c                                                  : wwAuthErr
     c                                                  : wwProxyAuthErr
     c                                                  : %trim(dsProxyHost)
     c                                                  : '/' )
     c                   if        rc < 200 or rc > 299
     c                   return    rc
     c                   endif

     c                   return    0
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * getRealSA(): Okay, this one's hard to explain :)
      *
      * The original peSoapAction parameter to HTTPAPI was defined as
      * fixed length "64A CONST".  This was problematic because people
      * needed to be able to specify longer strings.  So they'd use
      * XPROC -- but that's really cumbersome.
      *
      * I wanted to allow longer SoapAction, but I don't want to break
      * backward compatibility!  This is where it gets tricky...  how
      * can old programs pass a 64A, and new programs pass a 16384A
      * and have the routine work in either case??
      *
      * If the parameter is "16384A VARYING" the first two bytes must
      * be the length of the data.  Since the original peSoapAction
      * wasn't VARYING, the first two bytes would be actual data.
      * and due to the nature of a Soap-Action, they'd have to be
      * human readable.  That means the first character in the
      * SoapAction would have to be > x'40' (Blank in EBCDIC)
      *
      * So a VARYING string that's 16384 long would be hex x'4000'
      * in the first two bytes, but the lowest valid soap-action would
      * be x'4040'
      *
      * This routine uses that fact to distinguish between the two
      * types of SoapAction parameters and return the correct result
      * (is this clever? or ugly?)
      *
      * NOTE: This is now used for content-type and useragent as well
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P getRealSA       B                   export
     D getRealSA       PI         16384A   varying
     D   peSoapAction                 2a

     D wwOldStyle      s             64a   based(p_SA)
     D wwNewStyle      s          16384a   varying based(p_SA)

     C                   eval      p_SA = %addr(peSoapAction)
     C                   if        peSoapAction > x'4000'
     c                   return    %trim(wwOldStyle)
     c                   else
     c                   return    %trim(wwNewStyle)
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  HTTP_req(): Perform any HTTP request and get input/output from
      *              either a string or an IFS stream file.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_req        B                   export
     D                 PI            10i 0 opdesc
     D   Type                        10a   varying const
     D   URL                      32767a   varying const
     D   ResultStmf                5000a   varying const
     D                                     options(*varsize:*omit)
     D   ResultStr                     a   len(16000000) varying
     D                                     options(*varsize:*omit:*nopass)
     D   SendStmf                  5000a   varying const
     D                                     options(*varsize:*omit:*nopass)
     D   SendStr                       a   len(16000000) varying const
     D                                     options(*varsize:*omit:*nopass)
     D   ContentType              16384A   varying const
     D                                     options(*varsize:*omit:*nopass)

     D comm            s               *
     D sndFd           s             10i 0 inz(-1)
     D rcvFd           s             10i 0 inz(-1)
     D rcvProc         s               *   procptr
     D sndProc         s               *   procptr

     D ResultPtr       s               *   inz(*null)
     D ResultSize      s             10i 0 inz(0)
     D ResultLen       s             20i 0 inz(0)

     D SendPtr         s               *   inz(*null)
     D SendLen         s             10i 0 inz(0)
     D SendLen64       s             20i 0 inz(0)
     D dtype           s             10i 0
     D vtype           s             10i 0
     D inf1            s             10i 0
     D inf2            s             10i 0
     D rc              s             10i 0
     D Len             s             10i 0
     D p_Result        s               *
     D ct              s                   like(ContentType)
     D stmfInfo        ds                  likeds(statds64)

     D SoapAction      s          32767a   varying
     D                                     based(p_SoapAction)

      /free
        SetRespCode(0);
        p_global = getGlobalPtr();

        if %parms >= 5 and %addr(SendStmf) <> *null;
           sndFd = open( %trimr(SendStmf) : O_RDONLY + O_LARGEFILE );
           if sndFd = -1;
              SetError( HTTP_FDOPEN
                      :'open(): ' + %str(strerror(errno)) );
              return -1;
           endif;
           sndProc = %paddr(read);
           if stat64( %trimr(SendStmf): stmfInfo ) = -1;
              SetError( HTTP_FDSTAT
                      : 'stat64(): '+ %str(strerror(errno)) );
              callp close(sndFd);
              return -1;
           endif;
           sendLen64 = stmfInfo.st_size;
        endif;

        if sndFd=-1 and %parms >= 6 and %addr(SendStr) <> *null;
           getBufferInfo(SendStr: SendPtr: SendLen64 );
           sndProc = *null;
        endif;

        if %parms >= 3 and %addr(ResultStmf) <> *null;
           rcvFd = open( %trimr(ResultStmf)
                       : O_CREAT + O_TRUNC + O_WRONLY 
                        + CCSID_OR_CP + O_LARGEFILE
                       : global.file_mode
                       : global.file_ccsid );
           if rcvFd = -1;
              SetError( HTTP_FDOPEN
                      : 'open(): ' + %str(strerror(errno)) );
              return -1;
           endif;
           RcvProc = %paddr(write);
        endif;

        RcvStrBuf.Size = 0;
        RcvStrBuf.Len  = 0;
        RcvStrBuf.Ptr  = *null;

        if rcvFd=-1 and %parms >= 4 and %addr(ResultStr) <> *null;
           CEEDOD(4: dtype: vtype: inf1: inf2: ResultSize: *omit );
           getBufferInfo(ResultStr: ResultPtr: ResultLen );
           RcvStrBuf.Size = ResultSize;
           RcvStrBuf.Len  = 0;
           RcvStrBuf.Ptr  = ResultPtr;
           RcvProc = %paddr(RcvToBuf);
        endif;

        if %parms >= 7 and %addr(ContentType) <> *null;
           ct = ContentType;
        else;
           ct = global.contentType;
        endif;

        comm = http_persist_open( URL: global.timeout );
        if comm = *null;
           exsr closeFiles;
           http_persist_close(comm);
           return -1;
        endif;

        if global.soapActSet = *on;
           p_SoapAction = %addr(global.soapAction);
        else;
           p_SoapAction = *null;
        endif;

        if sendLen64 <= 2147483647;
          sendLen = sendLen64;
          sendLen64 = 0;
        else;
          sendLen = 0;
        endif;

        rc = http_persist_req( Type
                             : comm
                             : URL
                             : sndFd
                             : sndProc
                             : SendPtr
                             : SendLen
                             : rcvFd
                             : rcvProc
                             : global.timeout
                             : global.userAgent
                             : ct
                             : soapAction
                             : global.modTime
                             : sendLen64 );

        exsr closeFiles;
        http_persist_close(comm);
        global.soapActSet = *off;

        if RcvStrBuf.Ptr <> *null;
           if RcvStrBuf.Len <= 0;
              %len(resultStr) = 0;
           else;
              Len = HTTP_xlatedyn( RcvStrBuf.Len
                                 : RcvStrBuf.Ptr
                                 : TO_SYSTEM
                                 : p_Result );
              if Len < 1;
                %len(resultStr) = 0;
              else;
                if Len > ResultSize;
                  Len = ResultSize;
                endif;
                %len(resultstr) = Len;
                memcpy(resultPtr: p_Result: Len);
                xdealloc(p_Result);
              endif;
           endif;
        endif;

        return rc;

        begsr closeFiles;

           if sndFd <> -1;
              callp close(sndFd);
              sndFd = -1;
           endif;

           if rcvFd <> -1;
              callp close(rcvFd);
              rcvFd = -1;
           endif;

       endsr;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  getBufferInfo_REAL(): Dereferences location of CONST VARYING
      *                        buffer, and extracts length
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P getBufferInfo_REAL...
     P                 B                   export
     D                 PI
     D   Buf                               likeds(Buffer_t)
     D   DataPtr                       *
     D   DataLen                     20i 0
      /free
       if %addr(buf) = *null;
          DataPtr = *null;
          DataLen = 0;
       else;
          DataPtr = %addr(Buf.Data);
          DataLen = Buf.Len;
       endif;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * rcvToBuf(): This is a callback that will be used to receive
      *             data into a buffer in memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P rcvToBuf        B
     D                 PI            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10i 0 value

     D buf             s          65535a   based(p_buf)
     D newlen          s             10i 0

      /free

       newlen = len;
       if RcvStrBuf.len + newlen > RcvStrBuf.Size;
          newlen = RcvStrBuf.Size - RcvStrBuf.Len;
       endif;

       if newlen > 0;
          p_buf = RcvStrBuf.Ptr + RcvStrBuf.Len;
          %subst(buf:1:newlen) = %subst(data:1:newlen);
          RcvStrBuf.len += newlen;
       endif;

       return len;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  HTTP_string(): Perform any HTTP request using short strings
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_string     B                   export
     D                 PI        100000a   varying
     D   Type                        10a   varying const
     D   URL                      32767a   varying const
     D   SendStr                 100000a   varying const
     D                                     options(*varsize:*omit:*nopass)
     D   ContentType              16384A   varying const
     D                                     options(*varsize:*omit:*nopass)

     D rc              s             10i 0
     D Output          s         100000a   varying
     D msgText         s             80a   varying
     D msgKey          s              4a

     D ct              s                         like(ContentType)

      /free

       SetRespCode(0);
       p_global = getGlobalPtr();

       if %parms >= 4 and %addr(ContentType) <> *null;
          ct = ContentType;
       else;
          ct = global.contentType;
       endif;

       if %parms >= 3 and %addr(SendStr) <> *null;
          rc = http_req(Type: URL: *omit: Output: *omit: SendStr: ct );
       else;
          rc = http_req(Type: URL: *omit: Output);
       endif;

       if rc<>1 and (rc<200 or rc>299);
          msgText = %trimr(http_error());
          QMHSNDPM( 'CPF9897'
                  : 'QCPFMSG   *LIBL'
                  : msgText
                  : %len(msgText)
                  : '*ESCAPE'
                  : '*'
                  : 1
                  : msgKey
                  : ApiEscape );
       endif;

       return Output;
      /end-free
     P                 e


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  HTTP_stmf(): Perform any HTTP request using stream files
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_stmf       B                   export
     D                 PI
     D   Type                        10a   varying const
     D   URL                      32767a   varying const
     D   RespStmf                  5000a   varying const options(*varsize)
     D   SendStmf                  5000a   varying const
     D                                     options(*varsize:*omit:*nopass)
     D   ContentType              16384A   varying const
     D                                     options(*varsize:*omit:*nopass)

     D rc              s             10i 0
     D msgText         s             80a   varying
     D msgKey          s              4a
     D ct              s                         like(ContentType)

      /free

       SetRespCode(0);
       p_global = getGlobalPtr();

       if %parms >= 5 and %addr(ContentType) <> *null;
          ct = ContentType;
       else;
          ct = global.contentType;
       endif;

       if %parms >= 4 and %addr(SendStmf) <> *null;
          rc = http_req(Type: URL: RespStmf: *omit: SendStmf: *omit: ct );
       else;
          rc = http_req(Type: URL: RespStmf);
       endif;

       if rc <> 1 and (rc<200 or rc>299);
          msgText = %trimr(http_error());
          QMHSNDPM( 'CPF9897'
                  : 'QCPFMSG   *LIBL'
                  : msgText
                  : %len(msgText)
                  : '*ESCAPE'
                  : '*'
                  : 1
                  : msgKey
                  : ApiEscape );
       endif;

      /end-free
     P                 e


      /if defined(WORK_IN_PROGRESS)

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_persist(): Perform (any) Persistent HTTP Request
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_persist    B                   export
     D                 PI            10I 0
     D   Method                      10a   varying const
     D   comm                          *   value
     D   URL                      32767A   varying const options(*varsize)
     D   hWriter                       *   const
     D   hReader                       *   const options(*nopass:*omit)
     D

     D UseReader       s              1n   inz(*off)
     D SoapAction      s          32767a   varying
     D                                     based(p_SoapAction)
     D ContentType     s          16384a   varying
     D ContentLength   s             10u 0
     D myMethod        s                   like(Method)
     D Service         S             32A
     D UserId          S             32A
     D Password        S             32A
     D HostName        S            256A
     D Port            S             10I 0
     D Path            S          32767A   varying
     D Secure          S              1N
     D RC              s             10i 0
     D p_ModTime       S               *   inz(*null)
     D ModTime         S               Z   based(p_ModTime)

      /free
       SetRespCode(0);
       p_global = getGlobalPtr();
       RDWR_Reader_p = *null;
       RDWR_Writer_p = *null;

       http_dmsg('http_persist(' + myMethod + ') entered.');

       myMethod = %xlate(lower:upper:%trim(Method));

       if %parms >= 5 and %addr(Reader) <> *null;
          UseReader = *on;
       endif;

       if global.soapActSet = *on;
          p_SoapAction = %addr(global.soapAction);
       else;
          p_SoapAction = *null;
       endif;

       if ValidateRDWR(hWriter: RDWR_READER) = -1;
          return -1;
       endif;

       RDWR_Writer_p = hWriter;
       Writer.setError = %paddr(SetError);
       Writer.maxBufSize = 8192;
       Writer.LocCCSID = global.local_ccsid;
       Writer.NetCCSID = global.net_ccsid;

       if UseReader;
          if ValidateRDWR(hReader: RDWR_READER) = -1;
             return -1;
          endif;
          RDWR_Reader_p = hReader;
          Reader.setError = %paddr(SetError);
          Reader.maxBufSize = 8192;
          Reader.LocCCSID = global.local_ccsid;
          Reader.NetCCSID = global.net_ccsid;
       endif;

       if http_long_parseURL( URL
                            : Service
                            : UserId
                            : Password
                            : HostName
                            : Port
                            : Path ) < 0;
          return -1;
       endif;

       if Service = 'https';
          Secure = *ON;
       endif;

       setUrlAuth(UserId: Password);

       if Writer_Open( hWriter : RDWR_WRITER ) = -1;
          return -1;
       endif;

       ContentType = global.contentType;

       if UseReader
          and Reader_Open( hReader
                         : RDWR_Reader
                         : ContentType
                         : ContentLength ) = -1;
          Writer_Close(hWriter);
          return -1;
       endif;

       /if defined(NTLM_SUPPORT)
       if AuthPlugin_negotiateAuthentication( comm
                                     : url
                                     : global.timeout ) < 0;
          return -1;
       endif;
       /endif

       rc = do_oper( myMethod
                   : *null
                   : *null
                   : *null
                   : ContentLength
                   : comm
                   : 0
                   : global.timeout
                   : Path
                   : HostName
                   : ModTime
                   : global.userAgent
                   : ContentType
                   : soapAction
                   : *null
                   : 0
                   : Port
                   : Secure
                   : Service
                   : *ON
                   );

       if wkSaveAuth <> *blanks;
          dsAuth = wkSaveAuth;
          wkSaveAuth = *blanks;
       endif;

       if UseReader;
          Reader_Close(hReader);
          Reader_Cleanup(hReader);
       endif;

       Writer_Close(hWriter);
       Writer_Cleanup(hWriter);

       return rc;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  HTTP(): Perform any HTTP request using a flexible "reader/writer"
      *          approach.
      *
      *       Method = (input) HTTP method to use in the request
      *          URL = (input) URL to make request to
      *       Writer = (input) writer utility that will save the result
      *       Reader = (input) reader utility that will read the data to send
      *
      *  Sends an exception method upon error. (call http_error for details)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http            B                   export
     D                 PI
     D   Method                      10a   varying const
     D   URL                      32767a   varying const
     D   hWriter                       *   const
     D   hReader                       *   const
     D                                     options(*nopass:*omit)

     D msgText         s             80a   varying
     D msgKey          s              4a
     D comm            s               *
     D rc              s             10i 0
     D UseReader       s              1n

      /free
       SetRespCode(0);
       p_global = getGlobalPtr();

       if %parms >= 4 and %addr(hReader) <> *null;
          UseReader = *on;
       endif;

       comm = http_persist_open( URL: global.timeout );
       if comm = *null;
          rc = -1;
       endif;

       if rc = 0;

          if UseReader;
             rc = http_persist( Method
                              : comm
                              : URL
                              : hWriter
                              : hReader );
          else;
             rc = http_persist( Method
                              : comm
                              : URL
                              : hWriter
                              : *OMIT );
          endif;

          http_persist_close(comm);

       endif;

       if rc <> 1;
          msgText = %trimr(http_error());
          QMHSNDPM( 'CPF9897'
                  : 'QCPFMSG   *LIBL'
                  : msgText
                  : %len(msgText)
                  : '*ESCAPE'
                  : '*'
                  : 1
                  : msgKey
                  : ApiEscape );
       endif;

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * ValidateRDWR(): Validates that a reader or writer provided to
      *                 HTTPAPI is following the Reader/Writer interface
      *                 specifications.
      *
      *   handle = (input) RDWR handle data structure
      *    Usage = (input) Direction to validate for
      *
      * Returns 0 if RDWR is valid, -1 upon error
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P ValidateRDWR    B
     D                 PI            10i 0
     D   handle                            like(RDWR_HANDLE) value
     D   Usage                        3u 0 value

     D h               ds                  likeds(RDWR_t) based(handle)
     D type            s             10a   varying

      /free
       if Usage = RDWR_READER;
          Type = 'Reader';
       else;
          Type = 'Writer';
       endif;

       if h.length < %size(RDWR_t);
          SetError( HTTP_BAD_RDWR
                  : Type + ' provided an invalid +
                     handle length');
          return -1;
       endif;

       if h.version <> x'0101';
          SetError( HTTP_BAD_RDWR
                  : Type + ' version is unsupported +
                     by this version of HTTPAPI');
          return -1;
       endif;

       if %bitand( h.Direction : Usage) <> Usage;
          SetError( HTTP_BAD_RDWR : 'The routine provided +
                    in the ' + Type + ' parameter is not +
                    a ' + Type + ' routine');
          return -1;
       endif;

       if h.open = *null
          or h.close = *null
          or h.cleanup = *null
          or (Usage=RDWR_READER and h.read = *null)
          or (Usage=RDWR_WRITER and h.write = *null);
          SetError( HTTP_BAD_RDWR
                  : Type + ' does not provide the required +
                    functions');
          return -1;
       endif;

       return 0;
      /end-free
     P                 e

      /endif

      /define ERRNO_LOAD_PROCEDURE
      /copy ERRNO_H
     /*-                                                                            +
      * Copyright (c) 2008-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * HTTPCMDR4 -- Command-line & CL interface to HTTPAPI
      *   (also serves as a back-end to the QSH interface)
      *
      *  This program is intended to be called via the HTTPAPI
      *  command, or the httpapi QShell command. Please don't
      *  call it directly.
      */

      /copy VERSION

      /copy ifsio_h
      /copy httpapi_h
      /copy errno_h
      /copy httpcmd_h
      /copy private_h

     D HTTPCMDR4       PI
     D   peUrl                    32767a   varying const
     D   peDownload                 256a   varying const
     D   peReqType                    5a           const
     D   peUpload                   256a   varying const
     D   peType                      64a   varying const
     D   peUser                      80a   varying const
     D   pePass                    1024a   varying const
     D   peRedir                      4a           const
     D   peProxy                    256a   varying const
     D   peProxyUser                 80a   varying const
     D   peProxyPass               1024a   varying const
     D   peDebug                    256a   varying const
     D   peSSLID                    100a   varying const
     D   peCookies                  256a   varying const
     D   peSessCook                   4a           const
     D   peErrMsg                    80a   varying options(*nopass)
     D   peExitSts                   10i 0         options(*nopass)

     D printError      PR
     D   inMsg                       80a   const options(*nopass)
     D memwriter       PR            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10u 0 value
     D memreader       PR            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10u 0 value
     D readupload      PR            10i 0
     D   fd                          10i 0 value
     D cleanup         PR
     D   exitstatus                  10i 0 value
     D basename        PR         32767a   varying
     D   pathname                 32767a   varying const

     D FD_STDIN        c                   0
     D FD_STDOUT       c                   1

     D memdata         s               *   inz(*null)
     D memlen          s             10i 0 inz(0)
     D memalloc        s             10i 0 inz(0)
     D upldata         s               *   inz(*null)
     D upllen          s             10i 0 inz(0)
     D uplleft         s             10i 0 inz(0)
     D upl             s          65535a   based(uplpos)

     D reqtype         s              5a
     D uploadfd        s             10i 0 inz(-1)
     D downloadfd      s             10i 0 inz(-1)
     D x               s             10i 0
     D rc              s             10i 0
     D URL             s          32767a   varying
     D type            s             64a   varying
     D                                     inz(HTTP_CONTTYPE)
     D user            s             80a   varying
     D pass            s           1024a   varying
     D proxy           s            256a   varying
     D proxyport       s             10i 0 inz(8080)
     D proxyuser       s             80a   varying
     D proxypass       s           1024a   varying
     D debug           s            256a   varying
     D sslid           s            100a   varying
     D redir           s              4a   varying inz('*YES')
     D upload          s          32767A   varying inz('-')
     D download        s          32767A   varying inz('-')
     D cookies         s            256a   varying
     D sesscook        s              1n   inz(*OFF)
     D inputlen        s             10i 0
     D pos             s             10i 0
     D RTN_ERROR       s              1n   inz(*OFF)
     D LastMsg         s             80a   varying

      /free

       //-----------------------------------------------------------
       //  Interpret Parameters
       //-----------------------------------------------------------

       if %parms < 15;
          printError('Parameter mismatch');
          cleanup(1);
          return;
       endif;
       if %parms >= 17;
          RTN_ERROR = *ON;
       endif;

       url      = %trim(peURL);
       reqtype  = %xlate('getpos':'GETPOS':peReqType);
       redir    = %xlate('yesno':'YESNO':peRedir);
       type     = peType;

       if (peDownload = '*BASENAME');
          download = basename(url);
       else;
          download = %trim(peDownload);
       endif;

       if (peUpload = '*NONE');
          upload = '';
       else;
          upload = %trim(peUpload);
       endif;

       if (peUser = '*NONE');
          user='';
       else;
          user = %trim(peUser);
       endif;

       if (pePass = '*NONE');
          pass='';
       else;
          pass = %trim(pePass);
       endif;

       if (peProxy = '*NONE');
          proxy='';
       else;
          proxy = %trim(peProxy);
       endif;

       if (peProxyUser = '*NONE');
          proxyuser='';
       else;
          proxyuser = %trim(peProxyUser);
       endif;

       if (peProxyPass = '*NONE');
          proxypass='';
       else;
          proxypass = %trim(peProxyPass);
       endif;

       if (peDebug = '*NONE');
          debug = '';
       else;
          debug = %trim(peDebug);
       endif;

       if (peSSLID = '*DFT');
          sslid = '';
       else;
          sslid = %trim(peSSLID);
       endif;

       if (peCookies = '*NONE');
          cookies = '';
       else;
          cookies = %trim(peCookies);
       endif;

       if (peSessCook = '*YES');
          sesscook = *ON;
       endif;


       //-----------------------------------------------------------
       //  Verify that all needed parameters were passed
       //-----------------------------------------------------------

       if ( peReqType <> '*GET'
            and peReqType <> '*POST' );
          printError('Unknown request type: ' + peReqType);
          cleanup(1);
          return;
       endif;

       if %len(%trim(peURL)) < 5;
          printError('Invalid URL: ' + URL);
          cleanup(1);
          return;
       endif;

       if peRedir<>'*YES' and peRedir<>'*NO';
          printError('Invalid redirect value.');
          cleanup(1);
          return;
       endif;

       if peSessCook<>'*YES' and peSessCook<>'*NO';
          printError('Invalid SESSCOOK value.');
          cleanup(1);
          return;
       endif;


       //-----------------------------------------------------------
       //  Set options specified by the parameters.
       //-----------------------------------------------------------

       if %len(debug)>0;
          http_debug(*ON:debug);
       endif;

       if %len(cookies)>0;
          http_cookie_file(cookies:sesscook);
       endif;

      /if defined(HAVE_SSLAPI)
       if %len(sslid)>0;
          https_init(sslid);
       endif;
      /endif

       if %len(user)>0 or %len(pass)>0;
          http_setauth( HTTP_AUTH_BASIC : user: pass);
       endif;

       if %len(proxy)>0;
          pos = %scan(':': proxy);
          if (pos>1 and pos<%len(proxy) );
             proxyport = atoi(%subst(proxy:pos+1));
             proxy     = %subst(proxy:1:pos-1);
          endif;
          if http_setproxy(proxy:proxyport) = -1;
             printError();
             cleanup(2);
             return;
          endif;
       endif;

       if %len(proxyuser)>0 or %len(proxypass)>0;
          if http_proxy_setauth( HTTP_AUTH_BASIC
                               : proxyuser
                               : proxypass ) = -1;
             printError();
             cleanup(2);
             return;
          endif;
       endif;

       if peReqType = '*POST';
          if upload='-';
             uploadfd = -1;
          else;
             uploadfd = open( %trimr(upload) : O_RDONLY );
             if uploadfd = -1;
                printError( %trimr(upload) + ': '
                          + %str(strerror(errno)) );
                cleanup(3);
                return;
             endif;
          endif;
       endif;

       if download='-';
          downloadfd = FD_STDOUT;
       else;
          downloadfd = open( %trimr(download)
                           : O_WRONLY + O_CREAT + O_TRUNC + O_CCSID
                           : HTTP_IFSMODE
                           : HTTP_CCSID );
          if downloadfd = -1;
             printError( %trimr(download) + ': '
                       + %str(strerror(errno)) );
             cleanup(3);
             return;
          endif;
       endif;


       //-----------------------------------------------------------
       //  Do the POST/GET request
       //-----------------------------------------------------------

       if peReqType='*GET';
           rc = http_url_get_raw( URL
                                : downloadfd
                                : %paddr(memwriter) );
       else;
           readupload(uploadfd);
           rc = http_url_post_raw2( URL
                                  : uploadfd
                                  : %paddr(memreader)
                                  : upllen
                                  : downloadfd
                                  : %paddr(memwriter)
                                  : HTTP_TIMEOUT
                                  : HTTP_USERAGENT
                                  : type );
       endif;


       //-----------------------------------------------------------
       //  Handle any redirects.
       //-----------------------------------------------------------

       if redir='*YES' and (rc=302 or rc=303);

          x=0;
          dou (rc<>302 and rc<>303) or x=5;
             memlen = 0;
             rc = http_url_get_raw( http_redir_loc()
                                  : downloadfd
                                  : %paddr(memwriter) );
             x = x + 1;
          enddo;

          if (rc=302 or rc=303);
             printError('More than five redirects.');
             cleanup(4);
             return;
          endif;

       endif;


       //-----------------------------------------------------------
       //  Check for errors
       //-----------------------------------------------------------

       if rc = 1 or rc>=200 and rc<300;
          // success!
       else;
          printError();
          cleanup(5);
          return;
       endif;

       if (memlen > 0);
          if downloadfd = -1;
             callp write( FD_STDOUT: memdata: memlen);
          else;
             callp write( downloadfd: memdata: memlen);
          endif;
       endif;

       cleanup(0);
       return;

      /end-free


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  printError():  Set an error message
      *
      *    inMsg = (input/optional) error message to print
      *              if not given, the msg will be retrieved
      *              by calling http_error()
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P printError      B
     D printError      PI
     D   inMsg                       80a   const options(*nopass)
     D  msg            s             80a
     D msgno           s             10i 0

      /free
        if %parms>= 1;
           msg = %trimr(inMsg) + x'25';
        else;
           msg = http_error(msgno);
           msg = %char(msgno) + ' ' + msg + x'25';
        endif;

        LastMsg = msg;

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  memwriter(): Write HTTP response into memory
      *
      *  the memory addressed by the "memdata" pointer is intended
      *  to automatically "grow" in size as needed to store the
      *  received data.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P memwriter       B
     D memwriter       PI            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10u 0 value

     D CHUNK_SIZE      c                   131072

     D newlen          s             10i 0 static
     D newdata         s          65535a   based(p_newdata)
      /free
         newlen = memlen + len;

         dow (newlen > memalloc);
            memalloc = memalloc + CHUNK_SIZE;
            if (memdata = *null);
               memdata = TS_malloc(memalloc);
            else;
               memdata = TS_realloc(memdata: memalloc);
            endif;
         enddo;

         p_newdata = memdata + memlen;
         %subst(newdata:1:len) = %subst(data:1:len);
         memlen = newlen;

         return len;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  memreader(): Read POST data from memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P memreader       B
     D memreader       PI            10i 0
     D   fd                          10i 0 value
     D   data                     65535a   options(*varsize)
     D   len                         10u 0 value
      /free

         if (len >= uplleft);
            len = uplleft;
            %subst(data:1:len) = %subst(upl:1:len);
            uplleft = 0;
         else;
            %subst(data:1:len) = %subst(upl:1:len);
            uplleft = uplleft - len;
            uplpos  = uplpos  + len;
         endif;

         return len;
      /end-free
     P                 E



      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  readupload(): Read all of upload file into memory
      *
      *  the memory addressed by the "memdata" pointer is intended
      *  to automatically "grow" in size as needed to store the
      *  received data.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P readupload      B
     D readupload      PI            10i 0
     D   fd                          10i 0 value

     D savememdata     s                   like(memdata)
     D savememlen      s                   like(memlen)
     D savememalloc    s                   like(memalloc)

     D buf             s          65535a
     D newlen          s             10i 0 static
      /free
         if (fd = -1);
            fd = FD_STDIN;
         endif;

         savememdata  = memdata;
         savememlen   = memlen;
         savememalloc = memalloc;

         memdata      = *null;
         memlen       = 0;
         memalloc     = 0;

         newlen = read(fd: %addr(buf): %size(buf));
         dow newlen > 0;
           memwriter(fd: buf: newlen);
           newlen = read(fd: %addr(buf): %size(buf));
         enddo;

         upldata  = memdata;
         uplpos   = memdata;
         upllen   = memlen;
         uplleft  = memlen;
         memdata  = savememdata;
         memlen   = savememlen;
         memalloc = savememalloc;

         return upllen;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  cleanup():  Clean up any open resources before ending
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P cleanup         B
     D cleanup         PI
     D   exitstatus                  10i 0 value

     D QMHSNDPM        PR                  ExtPgm('QMHSNDPM')
     D   MessageID                    7A   Const
     D   QualMsgF                    20A   Const
     D   MsgData                     80A   Const
     D   MsgDtaLen                   10I 0 Const
     D   MsgType                     10A   Const
     D   CallStkEnt                  10A   Const
     D   CallStkCnt                  10I 0 Const
     D   MessageKey                   4A   const
     D   ErrorCode                    8a   const
      /free

         if uploadfd <> -1;
            callp close(uploadfd);
         endif;

         if downloadfd <> -1;
            callp close(downloadfd);
         endif;

         if memdata <> *null;
            TS_free(memdata);
         endif;

         if upldata <> *null;
            TS_free(upldata);
         endif;

         select;
         when RTN_ERROR = *ON;
            peErrMsg  = lastMsg;
            peExitSts = exitStatus;
         when exitStatus <> 0
           and %len(lastMsg) > 0;
            QMHSNDPM( 'CPF9897'
                    : 'QCPFMSG   *LIBL'
                    : lastMsg
                    : %len(lastMsg)
                    : '*ESCAPE'
                    : '*PGMBDY'
                    : 1
                    : *blanks
                    : x'0000000000000000');
         endsl;

         *INLR = *ON;
         return;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  basename(): Remove directory/prefix from filename
      *
      *     pathname = (input) IFS pathname to get basename of
      *
      * returns '' if no path, or only directories, provided.
      *         else returns the basename
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P basename        B
     D                 PI         32767a   varying
     D   pathname                 32767a   varying const

     D pos             s             10i 0 inz(0)
     D str             s             10i 0 inz(-1)
     D result          s          32767a   varying
      /free
       if %len(pathname) > 0;
          dou pos=0 or pos>=%len(pathname);
             pos = %scan('/': pathname: pos+1);
             if (pos>0 and pos<%len(pathname));
                str = pos + 1;
             endif;
          enddo;
       endif;
       if str = -1;
          return '';
       endif;
       result = %subst(pathname:str);
       dow %len(result)>0 and %subst(result:%len(result):1)='/';
         %len(result) = %len(result) - 1;
       enddo;
       if %len(result)=0 or result=*blanks;
          return '';
       endif;
       return result;
      /end-free
     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy errno_h
     /*-                                                                            +
      * Copyright (c) 2008-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * HTTPQSHR4 -- QShell interface to HTTPAPI
      *
      *  This program is intended to be called from a QShell command
      *  line or script.  In order for it to be functional, there
      *  should be a symbolic link between /usr/bin/httpapi and
      *  this RPG program.
      *
      *  If the symlink is missing, call this program with INSTALL
      *  as the first parameter, and the object library as the second.
      *
      *  For example:
      *   QSH CMD('/QSYS.LIB/LIBHTTP.LIB/HTTPQSHR4.PGM INSTALL LIBHTTP')
      */

      /copy VERSION

      /copy HTTPCMD_H
      /copy IFSIO_H
      /copy CONFIG_H

     D                 ds
     D  usagearr                           dim(27) ctdata
     D                                5a   overlay(usagearr:1)
     D  usagemsg                     65a   overlay(usagearr:6)

     D HTTPQSHR4       PR                  ExtPgm('HTTPQSHR4')
     D   p1                       65535a   options(*varsize)
     D   p2                       65535a   options(*varsize)
     D   p3                       65535a   options(*varsize)
     D   p4                       65535a   options(*varsize)
     D   p5                       65535a   options(*varsize)
     D   p6                       65535a   options(*varsize)
     D   p7                       65535a   options(*varsize)
     D   p8                       65535a   options(*varsize)
     D   p9                       65535a   options(*varsize)
     D   p10                      65535a   options(*varsize)
     D   p11                      65535a   options(*varsize)
     D   p12                      65535a   options(*varsize)
     D   p13                      65535a   options(*varsize)
     D   p14                      65535a   options(*varsize)
     D   p15                      65535a   options(*varsize)
     D HTTPQSHR4       PI
     D   p1                       65535a   options(*varsize)
     D   p2                       65535a   options(*varsize)
     D   p3                       65535a   options(*varsize)
     D   p4                       65535a   options(*varsize)
     D   p5                       65535a   options(*varsize)
     D   p6                       65535a   options(*varsize)
     D   p7                       65535a   options(*varsize)
     D   p8                       65535a   options(*varsize)
     D   p9                       65535a   options(*varsize)
     D   p10                      65535a   options(*varsize)
     D   p11                      65535a   options(*varsize)
     D   p12                      65535a   options(*varsize)
     D   p13                      65535a   options(*varsize)
     D   p14                      65535a   options(*varsize)
     D   p15                      65535a   options(*varsize)

     D option          PR             1n
     D   peArg                    65535a   varying const
     D   peOpt                       20a   varying const
     D   peVal                    32767a   varying options(*varsize)
     D   peSize                      10i 0 value
     D printError      PR
     D   inMsg                       80a   const
     D usage           PR
     D CEETREC         PR
     D   cel_rc_mod                  10i 0 const options(*omit)
     D   user_rc                     10i 0 const options(*omit)

     D FD_STDERR       c                   2

     D parmcount       s             10i 0
     D arg             s          65535a   varying
     D x               s             10i 0
     D rc              s             10i 0
     D URL             s          32767a   varying
     D cmd             s              7a   varying
     D type            s             64a   varying
     D                                     inz(HTTP_CONTTYPE)
     D user            s             80a   varying inz('*NONE')
     D pass            s           1024a   varying inz('*NONE')
     D proxy           s            256a   varying inz('*NONE')
     D proxyuser       s             80a   varying inz('*NONE')
     D proxypass       s           1024a   varying inz('*NONE')
     D debug           s            256a   varying inz('*NONE')
     D sslid           s            100a   varying inz('*DFT')
     D redir           s              4a   varying inz('Y')
     D upload          s          32767A   varying inz('-')
     D download        s          32767A   varying inz('*BASENAME')
     D cookies         s            256a   varying inz('*NONE')
     D sesscook        s              4a   varying inz('N')
     D errmsg          s             80a   varying inz('')
     D exitstatus      s             10i 0 inz(0)

      /free

       //-----------------------------------------------------------
       //  Interpret Parameters -- note that options can appear
       //   in any order, thus the funky looping..
       //-----------------------------------------------------------

       parmcount = %parms();
       if parmcount < 1;
          printError('Required parameter missing!');
          usage();
          CEETREC(*omit: 1);
          return;
       endif;

       for x = 1 to parmcount;

          select;
          when x = 1;
            arg = %str(%addr(p1));
          when x = 2;
            arg = %str(%addr(p2));
          when x = 3;
            arg = %str(%addr(p3));
          when x = 4;
            arg = %str(%addr(p4));
          when x = 5;
            arg = %str(%addr(p5));
          when x = 6;
            arg = %str(%addr(p6));
          when x = 7;
            arg = %str(%addr(p7));
          when x = 8;
            arg = %str(%addr(p8));
          when x = 9;
            arg = %str(%addr(p9));
          when x = 10;
            arg = %str(%addr(p10));
          when x = 11;
            arg = %str(%addr(p11));
          when x = 12;
            arg = %str(%addr(p12));
          when x = 13;
            arg = %str(%addr(p13));
          when x = 14;
            arg = %str(%addr(p14));
          when x = 15;
            arg = %str(%addr(p15));
          endsl;

          select;
          when x=1;
            cmd = %xlate('getposinal': 'GETPOSINAL': arg);

          when x = parmcount;
            URL = arg;

          when option(arg: 'redirect'   : redir     : %size(redir)    );
            redir = %xlate('yn':'YN':redir);

          when option(arg: 'user'       : user      : %size(user)     );
          when option(arg: 'type'       : type      : %size(type)     );
          when option(arg: 'pass'       : pass      : %size(pass)     );
          when option(arg: 'proxy'      : proxy     : %size(proxy)    );
          when option(arg: 'proxy-user' : proxyuser : %size(proxyuser));
          when option(arg: 'proxy-pass' : proxypass : %size(proxypass));
          when option(arg: 'debug'      : debug     : %size(debug)    );
          when option(arg: 'ssl-id'     : sslid     : %size(sslid)    );
          when option(arg: 'upload'     : upload    : %size(upload)   );
          when option(arg: 'download'   : download  : %size(download) );
          when option(arg: 'cookies'    : cookies   : %size(cookies)  );
          when option(arg: 'session-cookies': sesscook: %size(sesscook));
            sesscook = %xlate('yn':'YN':sesscook);

          other;
            printError('Unknown parameter: ' + arg);
            usage();
            CEETREC(*omit: 1);
            return;
          endsl;

       endfor;


       //-----------------------------------------------------------
       //  Verify that all needed parameters were passed
       //-----------------------------------------------------------

       select;
       when cmd = 'INSTALL';
       when cmd = 'GET';
          cmd = '*GET';
       when cmd = 'POST';
          cmd = '*POST';
       other;
          printError('Unknown cmd: ' + cmd);
          usage();
          CEETREC(*OMIT: 1);
          return;
       endsl;

       if %len(URL) < 5;
          printError('Invalid URL: ' + URL);
          usage();
          CEETREC(*omit: 1);
          return;
       endif;

       select;
       when redir='Y';
          redir='*YES';
       when redir='N';
          redir='*NO';
       other;
          printError('Invalid --redirect value.');
          usage();
          CEETREC(*omit: 1);
          return;
       endsl;

       select;
       when sesscook='Y';
          sesscook='*YES';
       when sesscook='N';
          sesscook='*NO';
       other;
          printError('Invalid --session-cookies value');
          usage();
          CEETREC(*omit: 1);
          return;
       endsl;


       //-----------------------------------------------------------
       //  Do an INSTALL Request (install the HTTPAPI symlink)
       //-----------------------------------------------------------

       if cmd = 'INSTALL';

           if access('/usr/bin': F_OK) = 0;
               if access('/usr/bin/httpapi': F_OK) = -1;
                    symlink( '/qsys.lib/'+URL+'.lib/httpqshr4.pgm'
                           : '/usr/bin/httpapi' );
               endif;
           endif;

           CEETREC(*omit: 0);
           return;

       endif;


       //-----------------------------------------------------------
       //  Do the POST/GET request
       //-----------------------------------------------------------

       monitor;
           HTTPCMDR4( URL
                    : download
                    : cmd
                    : upload
                    : type
                    : user
                    : pass
                    : redir
                    : proxy
                    : proxyuser
                    : proxypass
                    : debug
                    : sslid
                    : cookies
                    : sesscook
                    : errmsg
                    : exitstatus );
       on-error;
           errMsg = 'Error calling HTTPCMDR4. See job log.';
           exitStatus = 255 ;
       endmon;

       if (%len(errmsg)>0 and errmsg<>*blanks);
           printError(errmsg);
       endif;

       CEETREC(*OMIT: exitstatus);
       return;

      /end-free


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  option():  Parse a command-line option
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P option          B
     D option          PI             1n
     D   peArg                    65535a   varying const
     D   peOpt                       20a   varying const
     D   peVal                    32767a   varying options(*varsize)
     D   peSize                      10i 0 value
     D len             s             10i 0 static
     D size            s             10i 0 static
      /free
         len = %len(peOpt);
         if %len(peArg) >= (len+4)
            and %subst(peArg:1:2) = '--'
            and %subst(peArg:3:len) = peOpt
            and %subst(peArg:len+3:1) = '=';
                size = %len(%subst(peArg:len+4));
                if (size > (peSize-2));
                   size = peSize - 2;
                endif;
                peVal = %subst(peArg: len+4: size);
                return *on;
         else;
                return *off;
         endif;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  printError():  Print an error message to stderr
      *
      *    inMsg = (input) error message to print
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P printError      B
     D printError      PI
     D   inMsg                       80a   const
     D  msg            s             80a
     D msgno           s             10i 0

      /free
        msg = %trimr(inMsg) + x'25';
        callp write( FD_STDERR: %addr(msg): %len(%trimr(msg)));
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  usage(): Print command-line usage/syntax
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P usage           B
     D usage           PI
     D  msg            s             80a
     D x               s             10i 0
      /free
         for x = 1 to %elem(usagearr);
            msg = %trimr(usagemsg(x)) + x'25';
            callp write( FD_STDERR: %addr(msg): %len(%trimr(msg)));
         endfor;
      /end-free
     P                 E

**
     Usage:  httpapi get [OPTIONS] URL
2            httpapi post [OPTIONS] URL
3
4    options are:
5         --user=USERID             Specify UserID
6         --pass=PASSWORD           Specify Password
7         --type=CONTENTTYPE        MIME content type of POST
8                                     (ignored when GET)
9         --redirect=Y/N            Do/don't follow redirects
10                                    (default=Y)
11        --proxy=HOST[:PORT]       specify a proxy to use
12        --proxy-user=USERID       specify a userid
13                                    to use with the proxy.
14        --proxy-pass=PASSWORD     specify a password
15                                    to use with the proxy.
16        --debug=FILE              write debug info to FILE
17        --ssl-id=APP_ID           application ID profile
18                                    to associate with DCM
          --upload=FILE             file to upload in a POST
                                      request. (dft=stdin)
          --download=FILE           filename in which to save
                                      response. (-=stdout,
                                      dft=name in URL)
          --cookies=FILE            filename in which to save
                                      cookies (dft=reject all cookies)
          --session-cookies=Y/N     should session cookies be
                                      saved to cookies file?
     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*SRCSTMT: *NOSHOWCPY)
      /endif
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy private_h
      /copy ifsio_h
      /copy errno_h
      /copy socket_h

      /if defined(HTTP_USE_CCSID)
     D CCSID_OR_CP     S             10I 0 inz(O_CCSID)
      /else
     D CCSID_OR_CP     S             10I 0 inz(O_CODEPAGE)
      /endif

     D wkDbg           s             10I 0 inz(-1)
     D wkDbgProc       s               *   procptr inz(*NULL)
     D wkDbgUData      s               *   inz(*NULL)
     D wkDbgCln        s              1N   inz(*on)
     D wkDbgFail       s              1N   inz(*off)
     D wkErrorNo       S             10I 0
     D wkRespCode      S             10I 0
     D wkErrorMsg      S             80A
     D HTTP_DEBUG_LEVEL...
     D                 s             10i 0 inz(1)
     D totAlloc        s             20u 0 inz(0)
     D upper           C                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           C                   'abcdefghijklmnopqrstuvwxyz'

     D memset          PR              *   ExtProc('memset')
     D   ptr                           *   value
     D   value                       10I 0 value
     D   length                      10U 0 value
     D strrchr         PR              *   ExtProc('strrchr')
     D   dst                           *   value
     D   char                        10U 0 value

     D debug_proc      PR                  extproc(wkDbgProc)
     D   peData                        *   value
     D   peLen                       10I 0 value
     D   peUserData                    *   value

     D globalOpts      ds                  qualified
     D   timeout                     10i 0 inz(HTTP_TIMEOUT)
     D   modTime                       Z   inz(*loval)
     D   use_cookies                  1n   inz(*on)
     D   local_ccsid                 10i 0 inz(HTTP_EBCDIC)
     D   net_ccsid                   10i 0 inz(HTTP_ASCII)
     D   file_ccsid                  10i 0 inz(HTTP_CCSID)
     D   file_mode                   10i 0 inz(HTTP_IFSMODE)
     D   timeout100                  10i 0 inz(0)
     D   debugLevel                  10i 0 inz(1)
     D   contentType              16384a   varying inz(HTTP_CONTTYPE)
     D   soapActSet                   1n   inz(*off)
     D   soapAction               32768a   varying inz('')
     D   userAgent                16384a   varying inz(HTTP_USERAGENT)
     D   acceptHdr                 4096a   varying inz('')

      /if defined(DEBUG)
     D wkDebug         s              1N   inz(*ON)
      /else
     D wkDebug         s              1N   inz(*OFF)
      /endif

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * util_Diag():
      *   This sends a debugging/diagnostic message (a *DIAG message)
      *   with MSGID CPF9897 to the program's job log.
      *
      *   peMsgTxt   = (input) Text of message to send
      *
      * Returns *OFF if it failed, *ON upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P util_Diag       B                   export
     D util_Diag       PI             1N
     D   peMsgTxt                   256A   const

     D wwMsgLen        S             10I 0
     D wwTheKey        S              4A

     c                   callp     http_dmsg(peMsgTxt)

     c     ' '           checkr    peMsgTxt      wwMsgLen
     c                   if        wwMsgLen<1
     c                   return    *OFF
     c                   endif

     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : peMsgTxt
     c                                     : wwMsgLen
     c                                     : '*DIAG'
     c                                     : '*'
     c                                     : 1
     c                                     : wwTheKey
     c                                     : ApiEscape )
     c                   return    *on
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * debug_setproc:  set a new debugging procedure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P debug_setproc   B                   export
     D debug_setproc   PI
     D   peProc                        *   procptr value
     D   peUserData                    *   value
     c                   eval      wkDbgProc = peProc
     c                   eval      wkDbgUData = peUserData
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_dclose: close current debugging log file
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_dclose     B                   export
     D http_dclose     PI
     c                   if        wkDbg >= 0
     c                   callp     close(wkDbg)
     c                   eval      wkDbg = -1
     c                   endif
     c                   eval      wkDbgFail = *off
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_dwrite()
      *   Write debugging data to the debug log file (off by default)
      *
      *   peData = (input) data to write to debugging log.
      *            should be in ASCII and you need to supply your
      *            own CR/LF stuff.
      *    peLen = (input) length of data to write
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_dwrite     B                   export
     D http_dwrite     PI
     D   peData                        *   value
     D   peLen                       10I 0 value

     D ErrDbg          c                   const('Unable to open -
     D                                     debug file ')
     D CharErr         ds
     D   NumErr                       4s 0
     D MsgKey          s              4a

     D CRLF            C                   x'0d25'
     D wwBuf           s            100A
     D wwLen           s             10I 0
      /if defined(NTLM_SUPPORT)
      /define COPYRIGHT_DSPEC
      /copy NTLM_C
      /endif

     c                   if        wkDebug = *OFF
     c                   return
     c                   endif

     c                   if        wkDbgProc <> *NULL
     c                   callp     debug_proc(peData: peLen: wkDbgUData)
     c                   return
     c                   endif

     c                   if        wkDbg < 0
     c                   eval      wkDbg = open( HTTP_DEBUG_FILE
     c                                         : O_CREAT+O_APPEND+O_WRONLY
     c                                           + CCSID_OR_CP
     c                                         : 511
     c                                         : FILE_CCSID )
     c                   if        wkDbg = -1 and wkDbgFail = *Off
     c                   eval      wkDbgFail = *on
     c                   eval      NumErr = errno
     c                   callp     QMHSNDPM( 'CPE' + CharErr
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : ' '
     c                                     : 0
     c                                     : '*DIAG'
     c                                     : '*'
     c                                     : 0
     c                                     : MsgKey
     c                                     : ApiEscape )
     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : ErrDbg + HTTP_DEBUG_FILE
     c                                     : %len(ErrDbg+HTTP_DEBUG_FILE)
     c                                     : '*DIAG'
     c                                     : '*'
     c                                     : 0
     c                                     : MsgKey
     c                                     : ApiEscape )
     c                   endif
     c                   eval      wwBuf = 'HTTPAPI Ver ' + HTTPAPI_VERSION
     c                                     + ' released ' + HTTPAPI_RELDATE
     c                                     + CRLF
     c                   eval      wwLen = %len(%trimr(wwBuf))
     c                   callp     http_xlate(wwLen: wwBuf: TO_ASCII)
     c                   callp     write(wkDbg: %addr(wwBuf): wwLen)
      /if defined(NTLM_SUPPORT)
     c                   eval      wwBuf = 'NTLM Ver ' + cNTLM_VERSION
     c                                     + ' released ' + cNTLM_DATE
     c                                     + CRLF
     c                   eval      wwLen = %len(%trimr(wwBuf))
     c                   callp     http_xlate(wwLen: wwBuf: TO_ASCII)
     c                   callp     write(wkDbg: %addr(wwBuf): wwLen)
      /endif
     c                   eval      wwBuf = 'OS/400 Ver ' + OS_Release
     c                                     + CRLF + CRLF
     c                   eval      wwLen = %len(%trimr(wwBuf))
     c                   callp     http_xlate(wwLen: wwBuf: TO_ASCII)
     c                   callp     write(wkDbg: %addr(wwBuf): wwLen)
     c                   endif
     c                   if        wkDbg >= 0
     c                   callp     write(wkDbg: peData: peLen)
     c                   eval      wkDbgCln = *off
     c                   endif

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_dmsg()
      *    Add a diagnostic message to the debugging log
      *
      *    peMsgTxt = message to add to log.  Should be EBCDIC
      *         with no CR/LF needed.
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_dmsg       B                   export
     D http_dmsg       PI
     D   peMsgTxt                   256A   const

     D wwMsg           s            288A
     D wwMsgLen        s             10I 0

     c                   if        wkDebug = *OFF
     c                   return
     c                   endif

     c                   if        wkDbgCln = *Off
     c                   eval      %subst(wwMsg:1:2) = x'0d0a'
     c                   callp     http_dwrite(%addr(wwMsg): 2)
     c                   endif

     c                   if        HTTP_DEBUG_LEVEL > 1
     c                   eval      wwMsg = %char(%timestamp()) + ': '
     c                                   + %trimr(peMsgTxt) + x'0d25'
     c                   else
     c                   eval      wwMsg = %trimr(peMsgTxt) + x'0d25'
     c                   endif

     c                   eval      wwMsgLen = %len(%trimr(wwMsg))
     c                   callp     http_xlate(wwMsgLen: wwMsg: TO_ASCII)

     c                   callp     http_dwrite(%addr(wwMsg): wwMsgLen)
     c                   eval      wkDbgCln = *on

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * md5():
      *   Calculate an MD5 digest for a string
      *
      *      peData = pointer to data to create a digest for
      *   peDataLen = length of data that you're pointing to
      *    peDigest = (output) digest value in hex
      *
      * Returns *OFF if it failed, *ON upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P md5             B                   export
     D md5             PI             1N
     D   peData                        *   value
     D   peDataLen                   10I 0 value
     D   peDigest                    32A

     D FUNCT_HASH      C                   const(5)
     D HASHALG_MD5     C                   const(x'00')
     D HASHALG_SHA1    C                   const(x'01')

     D dsCtrl          DS
     D  dsCtrl_Funct                  5I 0
     D  dsCtrl_HashAlg...
     D                                1A
     D  dsCtrl_Seq                    1A
     D  dsCtrl_Len                   10I 0
     D  dsCtrl_Resrvd                 8A   inz(*loval)
     D  dsCtrl_CtxPtr                  *

     D cipher          PR                  extproc('_CIPHER')
     D  receiver                       *   value
     D  control                        *   value
     D  source                         *   value

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                       32A
     D  input                        16A
     D  output_len                   10I 0 value

     D wwDigest        S             16A
     D wwWorkArea      S             96A   inz(*loval)
     D p_Receiver      S               *
     D p_Data          S               *
     D wwData          S              1A   based(p_data)

     c                   eval      dsCtrl_Funct = FUNCT_HASH
     c                   eval      dsCtrl_HashAlg = HASHALG_MD5
     c                   eval      dsCtrl_Seq = x'00'
     c                   eval      dsCtrl_Len = peDataLen
     c                   eval      dsCtrl_CtxPtr = %addr(wwWorkArea)
     c                   eval      p_receiver = %addr(wwDigest)
     c                   eval      p_data = peData

     c                   callp     http_xlate(peDataLen: wwData: TO_ASCII)

     c                   callp(e)  cipher(%addr(p_Receiver):
     c                                    %addr(dsCtrl):
     c                                    %addr(peData))
     c                   if        %error
     c                   callp     util_diag('Call to MI built-in ' +
     c                                   '_CIPHER failed!')
     c                   return    *OFF
     c                   endif

     c                   callp(e)  cvthc(peDigest:wwDigest:%size(peDigest))
     c                   if        %error
     c                   callp     util_diag('Error converting char ' +
     c                                'to hex (shouldnt happen!)')
     c                   return    *OFF
     c                   endif

     c     upper:lower   xlate     peDigest      peDigest

     c                   return    *ON
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This takes an RPG timestamp and converts it to an 'HTTP-date'
      *  as defined by RFC 2616 (the RFC for HTTP/1.1)
      *
      *          input: z'2001-10-18-12:46:05.824000'
      *         output: Thu, 18 Oct 2001 12:46:05 GMT
      *
      * This does not have a provision for returning an error, since a
      * timestamp _must_ be a valid time already.  (cross your fingers)
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P httpdate        B                   export
     d httpdate        PI            29A
     d  peTS                           Z   const

     D                 ds
     D   dsStr                 1     19A
     D   dsTS                  1     26Z
     D   YYYY                  1      4
     D   MM                    6      7
     D   DD                    9     10
     D   HHMMSS               12     19

     D SUNDAY          C                   d'1899-12-31'

     D wwDate          s               D
     D wwDays          s             10i 0
     D wwJunk          s             10i 0
     D wwDOW           s             10i 0
     D wwStr           S             29A
     D wwSecs          S              8F

     D Month           s              3a
     D Day             s              3a

     c                   callp     http_dmsg('httpdate(): entered')

     c                   eval      dsTS = peTS

     c                   move      peTS          wwDate
     C     wwDate        subdur    SUNDAY        wwDays:*DAYS
     c     wwDays        div       7             wwJunk
     c                   mvr                     wwDOW

     C                   select
     c                   when      MM = '01'
     c                   eval      Month = 'Jan'
     c                   when      MM = '02'
     c                   eval      Month = 'Feb'
     c                   when      MM = '03'
     c                   eval      Month = 'Mar'
     c                   when      MM = '04'
     c                   eval      Month = 'Apr'
     c                   when      MM = '05'
     c                   eval      Month = 'May'
     c                   when      MM = '06'
     c                   eval      Month = 'Jun'
     c                   when      MM = '07'
     c                   eval      Month = 'Jul'
     c                   when      MM = '08'
     c                   eval      Month = 'Aug'
     c                   when      MM = '09'
     c                   eval      Month = 'Sep'
     c                   when      MM = '10'
     c                   eval      Month = 'Oct'
     c                   when      MM = '11'
     c                   eval      Month = 'Nov'
     c                   when      MM = '12'
     c                   eval      Month = 'Dec'
     c                   endsl

     C                   select
     c                   when      wwDOW = 0
     c                   eval      Day = 'Sun'
     c                   when      wwDOW = 1
     c                   eval      Day = 'Mon'
     c                   when      wwDOW = 2
     c                   eval      Day = 'Tue'
     c                   when      wwDOW = 3
     c                   eval      Day = 'Wed'
     c                   when      wwDOW = 4
     c                   eval      Day = 'Thu'
     c                   when      wwDOW = 5
     c                   eval      Day = 'Fri'
     c                   when      wwDOW = 6
     c                   eval      Day = 'Sat'
     c                   endsl

     C     '.':':'       xlate     HHMMSS        HHMMSS

     C                   eval      wwStr = Day + ', '
     C                                   + DD + ' ' + Month + ' ' + YYYY
     C                                   + ' ' + HHMMSS + ' GMT'
     c                   return    wwStr
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This is called by other procedures to set an error message
      *   that calling applications can retrieve with HTTP_ERROR
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SetError        B                   export
     d SetError        PI
     d   peErrorNo                   10I 0 value
     d   peErrorMsg                  80A   const
     c                   callp     http_dmsg('SetError() #' +
     c                                  %trim(%editc(peErrorNo:'L')) +
     c                                  ': '+ peErrorMsg)
     c                   eval      wkErrorNo = peErrorNo
     c                   eval      wkErrorMsg = peErrorMsg
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  This is called internally to set the last HTTP response code
      *  it can be retrieved via HTTP_error()
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P SetRespCode     B                   export
     d                 PI
     d   peRespCode                  10I 0 value
     c                   select
     c                   when      peRespCode = 1
     c                   eval      wkRespCode = 200
     c                   when      peRespCode <= 0
     c                   eval      wkRespCode = 0
     c                   other
     c                   eval      wkRespCode = peRespCode
     c                   endsl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_error():   Return the last error that occurred.
      *
      *     peErrorNo = (optional) error number that occurred.
      *    peRespCode = (optional) HTTP response code (if applicable)
      *
      *  Returns the human-readable error message.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_error      B                   export
     D http_error      PI            80A
     D   peErrorNo                   10I 0 options(*nopass:*omit)
     D   peRespCode                  10I 0 options(*nopass:*omit)
     c                   if        %parms>=1 and %addr(peErrorNo)<>*Null
     c                   eval      peErrorNo = wkErrorNo
     c                   endif
     c                   if        %parms>=2 and %addr(peRespCode)<>*null
     c                   eval      peRespCode = wkRespCode
     c                   endif
     c                   return    wkErrorMsg
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_debug():  Turn debugging info *ON or *OFF
      *
      *      peStatus = (input) status (either *ON or *OFF)
      *
      *    peFilename = (input/optional) filename that debug info will be
      *                    written to.  If not defined, the value from
      *                    CONFIG_H is used.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_debug      B                   export
     D http_debug      PI
     D   peStatus                     1N   const
     D   peFilename                 500A   varying const options(*nopass)

     D NumErr          s             10i 0

     c                   eval      wkDebug = peStatus

     c                   if        %parms >= 2
     c                   eval      HTTP_DEBUG_FILE = %trimr(peFilename)
     c                   endif

     c                   callp     http_dclose

     c                   if        peStatus = *ON
     c                   if        unlink(HTTP_DEBUG_FILE) < 0
     c                   eval      NumErr = errno
     c                   if        errno <> ENOENT
     c                   callp     util_diag('Unlink debug file failed +
     c                             with errno=' + %char(NumErr))
     c                   endif
     c                   endif
     c                   endif
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_comp(): Send a completion message
      *
      *      peMessage = message to send.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_comp       B                   export
     D http_comp       PI
     D   peMessage                  256A   const

     D wwTheKey        S              4A

     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : peMessage
     c                                     : %len(%trimr(peMessage))
     c                                     : '*COMP'
     c                                     : '*CTLBDY'
     c                                     : 1
     c                                     : wwTheKey
     c                                     : ApiEscape )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_diag(): Send a diagnostic message
      *
      *      peMessage = message to send.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_diag       B                   export
     D http_diag       PI
     D   peMessage                  256A   const

     D wwTheKey        S              4A

     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : peMessage
     c                                     : %len(%trimr(peMessage))
     c                                     : '*DIAG'
     c                                     : '*PGMBDY'
     c                                     : 1
     c                                     : wwTheKey
     c                                     : ApiEscape )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_crash(): Send back an *ESCAPE message containing last
      *               error found in HTTPAPI.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_crash      B                   export
     D http_crash      PI

     D wwMsg           s             80A
     D wwTheKey        S              4A
     c                   eval      wwMsg = http_error

     c                   callp     QMHSNDPM( 'CPF9897'
     c                                     : 'QCPFMSG   *LIBL'
     c                                     : wwMsg
     c                                     : %len(%trimr(wwMsg))
     c                                     : '*ESCAPE'
     c                                     : '*CTLBDY'
     c                                     : 1
     c                                     : wwTheKey
     c                                     : ApiEscape )
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_tempfile():  Generate a unique temporary IFS file name
      *
      * returns the file name
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_tempfile   B                   export
     D http_tempfile   PI            40A   varying

     D tmpnam          PR              *   extproc('_C_IFS_tmpnam')
     D   string                      39A   options(*omit)
     d filename        s             40A   varying

     C                   eval      filename = %str(tmpnam(*omit))
     c                   return    filename
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * xalloc(): Allocate memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P xalloc          B                   export
     D xalloc          PI              *
     D   size                        20p 0 value
     D ptr             s               *
      /if defined(TERASPACE)
     C                   eval      ptr = TS_malloc(size)
      /else
     C                   alloc     size          ptr
      /endif
      /if defined(MEMCOUNT)
     C                   eval      totalloc += 1
      /endif
     C                   return    ptr
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * xdealloc(): de-allocate memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P xdealloc        B                   export
     D xdealloc        PI
     D   ptr                           *
      /if defined(TERASPACE)
     C                   callp     ts_free(ptr)
      /else
     C                   dealloc                 ptr
      /endif
      /if defined(MEMCOUNT)
     C                   eval      totalloc -= 1
      /endif
     C                   eval      ptr = *null
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * xrealloc(): re-allocate memory
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P xrealloc        B                   export
     D xrealloc        PI              *
     D   ptr                           *   value
     D   size                        20p 0 value
      /if defined(MEMCOUNT)
     c                   if        ptr = *null
     c                   eval      totalloc += 1
     c                   endif
      /endif
      /if defined(TERASPACE)
     c                   if        ptr = *null
     c                   eval      ptr = ts_malloc(size)
     c                   else
     C                   eval      ptr = ts_realloc(ptr: size)
     c                   endif
      /else
     c                   if        ptr = *null
     c                   alloc     size          ptr
     c                   else
     C                   realloc   size          ptr
     c                   endif
      /endif
     C                   return    ptr
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * OS_Release():  Get the version of i5/OS or OS/400 that's running
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P OS_Release      B                   export
     D OS_Release      PI             6a

     D QSZRTVPR        PR                  extpgm('QSZRTVPR')
     D   RcvVar                            like(PRDR0100)
     D   RcvVarLen                   10i 0 const
     D   Format                       8a   const
     D   ProdInfo                          like(PRDINFO)
     D   errCode                      8a   const

     D PRDINFO         DS
     D   f1                           7a   inz('*OPSYS')
     D   f2                           6a   inz('*CUR'  )
     D   f3                           4a   inz('0000'  )
     D   f4                          10a   inz('*CODE' )

     D PRDR0100        DS            32
     D   Release              20     26a

     C                   callp     QSZRTVPR( PRDR0100
     C                                     : %size(PRDR0100)
     C                                     : 'PRDR0100'
     C                                     : PRDINFO
     C                                     : x'00000000' )
     C                   return    Release
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * log the current status of a socket to the debug log
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P socket_status   B                   export
     D                 PI
     D   routine                     50a   varying const
     D   point                       50a   varying const
     D   fd                          10i 0 value

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                        8A
     D  input                        10i 0
     D  output_len                   10I 0 value

     D flags           s             10i 0
     D blocking        s              1n
     D hexflags        s              8a
     D msg             s            256a

     c                   eval      flags = fcntl(fd: F_GETFL)
     c                   callp     cvthc( hexflags: flags: %size(hexflags))
     c                   eval      blocking = (%bitand(flags:O_NONBLOCK) = 0)

     c                   eval      msg = %trim(routine) + '(): '
     c                                 + %trim(point) + ' '
     c                                 + 'socket fd=' + %char(fd)
     c                                 + ', flags=' + %trim(hexflags)
     c                                 + ', blocking=' + blocking
     c                   callp     http_dmsg(msg)

     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * log the current status of select() API details to debug log
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P select_status   B                   export
     D                 PI
     D   routine                     50a   varying const
     D   point                       50a   varying const
     D   fd                          10i 0 value
     D   rset                          *   value
     D   wset                          *   value
     D   eset                          *   value
     D   timeout                       *   value
     D   rc                          10i 0 value options(*nopass)

     D cvthc           PR                  EXTPROC('cvthc')
     D  output                       56a   options(*varsize)
     D  input                          *   value
     D  output_len                   10I 0 value

     D rdeschex        s             56a
     D wdeschex        s                   like(rdeschex)
     D edeschex        s                   like(rdeschex)
     D timehex         s             16a
     D msg             s            256a

     c                   callp     socket_status( routine: point: fd )

     c                   if        rset = *null
     c                   eval      rdeschex = '*NULL'
     c                   else
     c                   callp     cvthc( rdeschex: rset: %size(rdeschex) )
     c                   endif

     c                   if        wset = *null
     c                   eval      wdeschex = '*NULL'
     c                   else
     c                   callp     cvthc( wdeschex: wset: %size(wdeschex) )
     c                   endif

     c                   if        eset = *null
     c                   eval      edeschex = '*NULL'
     c                   else
     c                   callp     cvthc( edeschex: eset: %size(edeschex) )
     c                   endif

     c                   if        timeout = *null
     c                   eval      timehex = '*NULL'
     c                   else
     c                   callp     cvthc( timehex: timeout: %size(timehex) )
     c                   endif

     c                   eval      msg = %trim(routine) + '(): '
     c                                 + %trim(point)   + ': '
     c                                 + 'select fd='   + %char(fd)
     c                                 + ', readset='   + %trimr(rdeschex)
     c                                 + ', writeset='  + %trimr(wdeschex)
     c                                 + ', excpset='   + %trimr(edeschex)
     c                                 + ', timeval='   + %trimr(timehex)

     c                   if        %parms >= 8
     c                   eval      msg = %trimr(msg) +', rc=' + %char(rc)
     c                   endif

     c                   callp     http_dmsg(msg)
     p                 e


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_setDebugLevel(): Set the debug log level
      *
      *    peDbgLvl = (input) new level to use
      *                1 = Normal
      *                2 = More detailed comm timeout/performance info
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_setDebugLevel...
     P                 B                   export
     D                 PI
     D    peDbgLvl                   10i 0 value
     C                   eval      HTTP_DEBUG_LEVEL = peDbgLvl
     C                   eval      globalOpts.debugLevel = peDbgLvl
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  returns the current HTTP_DEBUG_LEVEL value
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P getDebugLevel...
     P                 B                   export
     D                 PI            10i 0
     C                   return    HTTP_DEBUG_LEVEL
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_setOption():  Sets an HTTP option used on subsequent requests
      *
      *   option = (input) option string to set
      *    value = (input) value of option string
      *
      * possible options are:
      *
      * 'timeout' = numeric value.  If this many seconds pass without
      *             any network activity, the request is aborted.
      *
      * 'SoapAction' = Value to be placed in the HTTP "soap-action" header
      *             used when calling web services with the SOAP protocol
      *
      * 'content-type' = When uploading a stream in a POST or PUT request,
      *             this specifies the data type you're sending
      *
      * 'user-agent' = overrides the user-agent string sent to the HTTP
      *             server. This allows you to test servers that require a
      *             particular browser (such as IE or Chrome)
      *
      * '100-timeout' = time to wait for a '100 Continue' response when
      *             sending a request body (such as a POST/PUT request).
      *             Value should be a number of seconds.
      *
      * 'use-cookies' = indicates whether cookie support in HTTPAPI is
      *             enabled or not.  Value should be '1' for enabled or
      *             '0' for disabled.
      *
      * 'local-ccsid' = CCSID to use for your local machine when text data
      *             needs to be translated.  Value should be a number from
      *             1-65533 or the special value '0' for "current job ccsid".
      *             Usually this is some form of EBCDIC.
      *
      * 'network-ccsid' = CCSID to to use for the data sent over the network
      *             to remote sites.  Value should be a number from 1-65533.
      *             Typically this should be 1208 (UTF-8) or for older sites,
      *             some form of ASCII.
      *
      * 'file-ccsid' = When a new file is created in the IFS, HTTPAPI will
      *             assign this CCSID. Value should be a number from 1-65533.
      *             HTTPAPI does not use this to translate the data, it only
      *             puts this in the file description.
      *
      * 'file-mode' = When a new file is created in the IFS, HTTPAPI will
      *             use this parameter as the file's "mode" (authorities).
      *             Value should be a number, same as the 3rd parameter to
      *             the IFS open() API.
      *
      * 'debug-level' = Number indicating the amount of detail written to
      *             the debug/trace file that httpapi creates when you use
      *             the http_debug(*on) feature.  1=Normal, 2=Mode Detailed
      *
      * 'if-modified-since' = value should be a timestamp in *ISO char
      *                  format.  On a GET request, the file will only
      *                  be retrieved if it has changed since this date/time.
      *
      * 'accept' = Media types that you are willing to accept in response
      *                  to an HTTP request
      *
      *returns 0 if successful, -1 upon failure
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_setOption  B                   export
     D                 PI            10i 0
     D    option                     32a   varying const
     D    value                   65535a   varying const
     D                                     options(*varsize)
     D opt             s                   like(option)
     D rc              s             10i 0 inz(0)

      /free
       p_global = %addr(globalopts);

       opt = %xlate( 'abcdefghijklmnopqrstuvwxyz'
                   : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                   : option );

       monitor;

          select;
          when opt = 'TIMEOUT';
             global.timeout = %int(value);
          when opt = 'SOAP-ACTION' or opt = 'SOAPACTION';
             global.soapAction = value;
             global.soapActSet = *ON;
          when opt = 'CONTENT-TYPE';
             global.contentType = value;
          when opt = 'IF-MODIFIED-SINCE';
             global.modTime = %timestamp(value:*iso);
          when opt = 'USER-AGENT';
             global.userAgent = value;
          when opt = '100-TIMEOUT';
             global.timeout100 = %dec( value: 10: 3);
          when opt = 'USE-COOKIES';
             if value='0';
                global.use_cookies = *off;
             else;
                global.use_cookies = *on;
             endif;
          when opt = 'LOCAL-CCSID';
             global.local_ccsid = %int(value);
             rc = HTTP_setCCSIDs( global.net_ccsid
                                : global.local_ccsid );
          when opt = 'NETWORK-CCSID';
             global.net_ccsid = %int(value);
             rc = HTTP_setCCSIDs( global.net_ccsid
                                : global.local_ccsid );
          when opt = 'FILE-CCSID';
             global.file_ccsid = %int(value);
             HTTP_setFileCCSID(global.file_ccsid);
          when opt = 'FILE-MODE';
             global.file_mode = %int(value);
             // FIXME: Used elsewhere, too
          when opt = 'DEBUG-LEVEL';
             HTTP_setDebugLevel(%int(value));
          when opt = 'ACCEPT';
             global.acceptHdr = %trim(value);
          other;
             rc = -1;
          endsl;

       on-error;
          rc = -1;
       endmon;

       return rc;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * getGlobalPtr(): Internal routine to return the global options
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P getGlobalPtr    B                   export
     D                 PI              *
      /free
       p_global = %addr(globalopts);
       return p_global;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * memStatus(): Log memory alloc/dealloc status
      *
      * NOTE: Since HTTP headers are deliberately saved to the activation
      *       group and will be cleaned up later, they are not counted
      *       in the number of allocations.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P memStatus       B                   export
     D                 PI
     D   msg                         50a   varying const
      /if defined(MEMCOUNT)
     D count           s             20u 0
     C                   eval      count = totalloc
     C                                   - http_header_count()
     C                   callp     http_dmsg( msg
     C                                      + ': '
     C                                      + %char(count))
      /endif
     P                 E

      /define ERRNO_LOAD_PROCEDURE
      /copy ERRNO_H
     /*-                                                                            +
      * Copyright (c) 2004-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     /*
      * HTTPXMLR4 -- Parse XML responses from a host
      *
      *  This uses the Expat service program to parse the XML
      *  response and return it to a call-back procedure.
      *
      *>      CRTRPGMOD HTTPXMLR4 SRCFILE(LIBHTTP/QRPGLESRC) DBGVIEW(*LIST)
      *>      UPDSRVPGM SRVPGM(LIBHTTP/HTTPAPIR4) MODULE(HTTPXMLR4) -
      *>                EXPORT(*CURRENT)
      *
      */

      /copy VERSION

     H OPTION(*NOSHOWCPY: *SRCSTMT: *NODEBUGIO)
     H NOMAIN

      /define HTTP_ORIG_SHORTFIELD
      /copy httpapi_h
      /copy private_h
      /copy expat_h
      /copy ifsio_h
      /copy errno_h

     D InitParser      PR                  like(XML_Parser)
     D   peElemStack                       likeds(elemroot)
     D   peEncoding                 100C   const

     D startElement    Pr
     D   root                              likeds(elemroot)
     D   name                     16373C   options(*varsize)
     D   atts                          *   dim(32767) options(*varsize)
     D charData        Pr
     D   root                              likeds(elemroot)
     D   string                   16373C   options(*varsize)
     D   len                         10I 0 value
     D endElement      Pr
     D   root                              likeds(elemroot)
     D   name                          *   value

     D ParseXML        PR            10I 0
     D   peFD                        10I 0 value
     D   peData                    8192A   options(*varsize)
     D   peLength                    10I 0 value

     D copyAttrs       PR              *
     D   root                              likeds(elemroot)
     D   peAttr                        *   dim(32767) options(*varsize)
     D freeAttrs       PR
     D   peAttrs                       *   value

     D rootDepth       PR                         like(elemroot.depth)
     D   root                              value  likeds(elemroot)

     D elemPath        PR                         like(element.path)
     D   root                              value  likeds(elemroot)
     D   elem                              value  likeds(element)
     D Xreplace        pr
     D    string                   4096a   varying
     D    fromstr                    10a   varying const
     D    tostr                      10a   varying const

     D MAXDEPTH        C                   512

     D elemroot        ds                  qualified
     D   depth                       10I 0
     D   startcb                       *   procptr
     D   endcb                         *   procptr
     D   userdata                      *
     D   entry                         *   dim(MAXDEPTH)
     D   cbStack                       *   dim(MAXDEPTH)
     D   cbStackCnt                  10I 0
     D   cbHasChanged                 1n
     D   pathOfs                     10I 0
     D   depthOfs                    10I 0
     D   buf                       8192A   varying
     D   errcode                     10I 0
     D   line                        10I 0
     D   column                      10I 0
     D   namespace                    1N
     D   nschar                       1A
     D   xlate                       52a
     D   StripCRLF                    1N

     D p_cbStackE      s               *
     D cbStackE        ds                  qualified based(p_cbStackE)
     D   depth                             like(elemroot.depth)
     D   pathOfs                           like(elemroot.pathOfs)
     D   depthOfs                          like(elemroot.depthOfs)
     D   startcb                           like(elemroot.startcb)
     D   endcb                             like(elemroot.endcb)
     D   userdata                          like(elemroot.userdata)

     D p_element       s               *
     D element         ds                  qualified based(p_element)
     D   path                      8192A   varying
     D   ns                        1024A   varying
     D   name                      1024A   varying
     D   value                         *
     D   size                        10i 0
     D   allocsize                   10i 0
     D   attrs                         *

     D CHUNKSIZE       C                   const(65536)

     D wkParser        s                   like(XML_Parser)
     D wkElemRoot      ds                  likeds(elemroot)
     D wkNamespace     s              1N   inz(*OFF)
     D wkXmlReturnPtr  s              1N   inz(*OFF)
     D wkXmlReturnUCS  s              1N   inz(*OFF)
     D wkStripCRLF     S              1N   inz(*ON)
     D wkCBSwitched    S              1N   inz(*OFF)
     D wkInsideStartCB...
     D                 S              1N   inz(*OFF)

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_get_xml():
      * http_url_get_xml():  Send a GET request to an HTTP server and
      *     receive/parse an XML response.
      *
      *       peURL = (input) URL to perform GET request to
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed to the
      *                    call-back routine
      *
      * (other parms are identical to those in HTTP_url_get())
      *
      *  Returns 1 if successful, -1 upon error, 0 if timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_get_xml...
     P                 B                   export
     D http_url_get_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwRC            s             10I 0
     D wwEmptyBuf      s              1A

      /free

         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot: *blanks);

         select;
         when (%parms < 5);
             wwRC = http_url_get_raw( peURL
                                    : 3
                                    : %paddr(ParseXML));
         when (%parms < 6);
             wwRC = http_url_get_raw( peURL
                                    : 4
                                    : %paddr(ParseXML)
                                    : peTimeout );
         when (%parms < 7);
             wwRC = http_url_get_raw( peURL
                                    : 5
                                    : %paddr(ParseXML)
                                    : peTimeout
                                    : peUserAgent );
         when (%parms < 8);
             wwRC = http_url_get_raw( peURL
                                    : 6
                                    : %paddr(ParseXML)
                                    : peTimeout
                                    : peUserAgent
                                    : peModTime );
         when (%parms < 9);
             wwRC = http_url_get_raw( peURL
                                    : 7
                                    : %paddr(ParseXML)
                                    : peTimeout
                                    : peUserAgent
                                    : peModTime
                                    : peContentType );
         other;
             wwRC = http_url_get_raw( peURL
                                    : 8
                                    : %paddr(ParseXML)
                                    : peTimeout
                                    : peUserAgent
                                    : peModTime
                                    : peContentType
                                    : peSOAPAction );
         endsl;

         if (wkElemRoot.errcode = 0);
            ParseXML(0: wwEmptyBuf: 0);
         endif;

         if (wwRC=1 and wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                    + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            wwRC = -1;
         endif;

         close_iconv(wkElemRoot.xlate);
         XML_ParserFree(wkParser);

         return wwRC;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_post_xml():
      * http_url_post_xml(): Post data to HTTP server, and receive
      *        XML response.  Response is parsed as it's received
      *        off the wire (no temporary file is used.)
      *
      *          peURL = (input) URL to perform GET request to
      *     pePostData = (input) data to POST to the web server
      *  pePostDataLen = (input) length of pePostData
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *       peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *
      * (other parms are identical to those in HTTP_url_post())
      *
      *  Returns 1 if successful, -1 upon error, 0 if timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post_xml...
     P                 B                   export
     D http_url_post_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwRC            s             10I 0
     D wwEmptyBuf      s              1A

      /free

         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot :*blanks);

         select;
         when (%parms < 7);
             wwRC = http_url_post_raw( peURL
                                     : pePostData
                                     : pePostDataLen
                                     : 5
                                     : %paddr(ParseXML) );
         when (%parms < 8);
             wwRC = http_url_post_raw( peURL
                                     : pePostData
                                     : pePostDataLen
                                     : 6
                                     : %paddr(ParseXML)
                                     : peTimeout );
         when (%parms < 9);
             wwRC = http_url_post_raw( peURL
                                     : pePostData
                                     : pePostDataLen
                                     : 7
                                     : %paddr(ParseXML)
                                     : peTimeout
                                     : peUserAgent );
         when (%parms < 10);
             wwRC = http_url_post_raw( peURL
                                     : pePostData
                                     : pePostDataLen
                                     : 8
                                     : %paddr(ParseXML)
                                     : peTimeout
                                     : peUserAgent
                                     : peContentType );
         other;
             wwRC = http_url_post_raw( peURL
                                     : pePostData
                                     : pePostDataLen
                                     : 9
                                     : %paddr(ParseXML)
                                     : peTimeout
                                     : peUserAgent
                                     : peContentType
                                     : peSOAPAction ) ;
         endsl;

         if (wkElemRoot.errcode = 0);
            ParseXML(0: wwEmptyBuf: 0);
         endif;

         if (wwRC=1 and wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                    + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            %len(wkElemRoot.buf) = 0;
            wwRC = -1;
         endif;

         close_iconv(wkElemRoot.xlate);
         XML_ParserFree(wkParser);

         return wwRC;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_url_post_stmf_xml():
      *  http_post_stmf_xml(): Post data to HTTP server, and receive
      *        XML response.  Response is parsed as it's received
      *        off the wire (no temporary file is used.)
      *
      *       peURL = (input) URL to post to
      *  pePostFile = (input) File of stream file (in IFS) to post
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *  peTimeout  = (optional) give up if no data is received for
      *                       this many seconds.
      * peContentType = (optional) content type to supply (mainly
      *                       useful when talking to CGI scripts)
      *
      *  Returns  -1 upon failure, 0 upon timeout,
      *            1 for success, or an HTTP response code
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_url_post_stmf_xml...
     P                 B                   export
     D http_url_post_stmf_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFile                32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwStat          ds                  likeds(statds)
     D wwPostFD        S             10I 0
     D wwRC            S             10I 0
     D wwEmptyBuf      s              1A

      /free

       // *********************************************************
       // * open file to be posted
       // *********************************************************

         if ( stat(%trimr(pePostFile) : %addr(wwStat)) < 0 );
             SetError(HTTP_FDSTAT
                     : 'stat(): ' + %str(strerror(errno)));
             return -1;
         endif;

         wwPostFD = open(%trimr(pePostFile) : O_RDONLY);
         if ( wwPostFD < 0 );
            SetError(HTTP_FDOPEN
                    : 'open(): ' + %str(strerror(errno)));
            return -1;
         endif;

       // *********************************************************
       //  Initialize the XML parser & our own data
       // *********************************************************

         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot: *blanks);


       // *********************************************************
       // * Call the 'raw' post procedure telling it to use the
       // * IFS API called 'read' to load data from the stream
       // * file -- and use our ParseXML routine for the data
       // * that's received.
       // *********************************************************

          select;
          when %parms < 6;
             wwRC = http_url_post_raw2( peURL
                                      : wwPostFD
                                      : %paddr(read)
                                      : wwStat.st_size
                                      : 5
                                      : %paddr(ParseXML) );
          when %parms < 7;
             wwRC = http_url_post_raw2( peURL
                                      : wwPostFD
                                      : %paddr(read)
                                      : wwStat.st_size
                                      : 6
                                      : %paddr(ParseXML)
                                      : peTimeout );
          when %parms < 8;
             wwRC = http_url_post_raw2( peURL
                                      : wwPostFD
                                      : %paddr(read)
                                      : wwStat.st_size
                                      : 7
                                      : %paddr(ParseXML)
                                      : peTimeout
                                      : peUserAgent );
          when %parms < 9;
             wwRC = http_url_post_raw2( peURL
                                      : wwPostFD
                                      : %paddr(read)
                                      : wwStat.st_size
                                      : 8
                                      : %paddr(ParseXML)
                                      : peTimeout
                                      : peUserAgent
                                      : peContentType );
          other;
             wwRC = http_url_post_raw2( peURL
                                      : wwPostFD
                                      : %paddr(read)
                                      : wwStat.st_size
                                      : 9
                                      : %paddr(ParseXML)
                                      : peTimeout
                                      : peUserAgent
                                      : peContentType
                                      : peSOAPAction );
          endsl;

          callp close(wwPostFD);

          if (wkElemRoot.errcode = 0);
             ParseXML(0: wwEmptyBuf: 0);
          endif;

          if (wwRC=1 and wkElemRoot.errcode > 0);
             SetError(HTTP_XMLERR: 'XML parse failed at line '
                    + %char(wkElemRoot.line) + ', col '
                     + %char(wkElemRoot.column) + ': '
                     + %str(XML_ErrorString(wkElemRoot.errcode)));
             %len(wkElemRoot.buf) = 0;
             wwRC = -1;
          endif;

          close_iconv(wkElemRoot.xlate);
          XML_ParserFree(wkParser);

          return wwRC;

      /end-free
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_get_xmltf(): Request URL from server. Receive response
      *        to temporary file, then parse it.
      *
      *       peURL = (input) URL to perform GET request to
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed to the
      *                    call-back routine
      *
      * (other parms are identical to those in HTTP_url_get())
      *
      *  Returns 1 if successful, -1 upon error, 0 if timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_get_xmltf...
     P                 B                   export
     D http_get_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwRC            s             10I 0
     D wwFile          s             40a   varying

      /free

         // ********************************************
         // * Download HTTP file to temporary location
         // ********************************************

         wwFile = http_tempfile();

         select;
         when (%parms < 5);
             wwRC = http_url_get( peURL
                                : wwFile );
         when (%parms < 6);
             wwRC = http_url_get( peURL
                                : wwFile
                                : peTimeout );
         when (%parms < 7);
             wwRC = http_url_get( peURL
                                : wwFile
                                : peTimeout
                                : peUserAgent );
         when (%parms < 8);
             wwRC = http_url_get( peURL
                                : wwFile
                                : peTimeout
                                : peUserAgent
                                : peModTime );
         when (%parms < 9);
             wwRC = http_url_get( peURL
                                : wwFile
                                : peTimeout
                                : peUserAgent
                                : peModTime
                                : peContentType );
         other;
             wwRC = http_url_get( peURL
                                : wwFile
                                : peTimeout
                                : peUserAgent
                                : peModTime
                                : peContentType
                                : peSOAPAction );
         endsl;

         if (wwRC <> 1);
            unlink(wwFile);
            return wwRC;
         endif;

         // ********************************************
         // * Run temp file through XML parser.
         // ********************************************

         wwRC = http_parse_xml_stmf( wwFile
                                   : HTTP_XML_CALC
                                   : peStartProc
                                   : peEndProc
                                   : peUsrDta );
         unlink(wwFile);

         if (wwRC = 0);
            return 1;
         else;
            return -1;
         endif;

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_post_xmltf(): Post data from memory. Receive
      *        response to temporary file, then parse it.
      *
      *          peURL = (input) URL to perform GET request to
      *     pePostData = (input) data to POST to the web server
      *  pePostDataLen = (input) length of pePostData
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *       peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *
      * (other parms are identical to those in HTTP_url_post())
      *
      *  Returns 1 if successful, -1 upon error, 0 if timeout
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_post_xmltf...
     P                 B                   export
     D http_post_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwRC            s             10I 0
     D wwFile          s             40a   varying

      /free

         // ********************************************
         // * POST data and download results to temporary
         // * stream file.
         // ********************************************

         wwFile = http_tempfile();

         select;
         when (%parms < 7);
            wwRC = http_url_post( peURL
                                : pePostData
                                : pePostDataLen
                                : wwFile        );
         when (%parms < 8);
            wwRC = http_url_post( peURL
                                : pePostData
                                : pePostDataLen
                                : wwFile
                                : peTimeout     );
         when (%parms < 9);
            wwRC = http_url_post( peURL
                                : pePostData
                                : pePostDataLen
                                : wwFile
                                : peTimeout
                                : peUserAgent   );
         when (%parms < 10);
            wwRC = http_url_post( peURL
                                : pePostData
                                : pePostDataLen
                                : wwFile
                                : peTimeout
                                : peUserAgent
                                : peContentType );
         other;
            wwRC = http_url_post( peURL
                                : pePostData
                                : pePostDataLen
                                : wwFile
                                : peTimeout
                                : peUserAgent
                                : peContentType
                                : peSOAPAction  );
         endsl;

         if (wwRC <> 1);
            unlink(wwFile);
            return wwRC;
         endif;

         // ********************************************
         // * Run temporary file through XML parser.
         // ********************************************

         wwRC = http_parse_xml_stmf( wwFile
                                   : HTTP_XML_CALC
                                   : peStartProc
                                   : peEndProc
                                   : peUsrDta );
         unlink(wwFile);

         if (wwRC = 0);
            return 1;
         else;
            return -1;
         endif;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_post_stmf_xmltf(): Post data from stream file.  Receive
      *        response to temporary file, then parse it.
      *
      *       peURL = (input) URL to post to
      *  pePostFile = (input) File of stream file (in IFS) to post
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *  peTimeout  = (optional) give up if no data is received for
      *                       this many seconds.
      * peContentType = (optional) content type to supply (mainly
      *                       useful when talking to CGI scripts)
      *
      *  Returns  -1 upon failure, 0 upon timeout,
      *            1 for success, or an HTTP response code
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_post_stmf_xmltf...
     P                 B                   export
     D http_post_stmf_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFile                32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)

     D wwRC            S             10I 0
     D wwFile          s             50a   varying

      /free


       // *********************************************************
       //   Send stream file to server, and download results
       //   to a temporary location.
       // *********************************************************

          wwFile = http_tempfile();

          select;
          when %parms < 6;
             wwRC = http_url_post_stmf( peURL
                                      : pePostFile
                                      : wwFile       );
          when %parms < 7;
             wwRC = http_url_post_stmf( peURL
                                      : pePostFile
                                      : wwFile
                                      : peTimeout    );
          when %parms < 8;
             wwRC = http_url_post_stmf( peURL
                                      : pePostFile
                                      : wwFile
                                      : peTimeout
                                      : peUserAgent  );
          when %parms < 9;
             wwRC = http_url_post_stmf( peURL
                                      : pePostFile
                                      : wwFile
                                      : peTimeout
                                      : peUserAgent
                                      : peContentType);
          other;
             wwRC = http_url_post_stmf( peURL
                                      : pePostFile
                                      : wwFile
                                      : peTimeout
                                      : peUserAgent
                                      : peContentType
                                      : peSOAPAction );
          endsl;

          if (wwRC <> 1);
             unlink(wwFile);
             return wwRC;
          endif;

       // *********************************************************
       //   Parse temporary XML results
       // *********************************************************

          wwRC = http_parse_xml_stmf( wwFile
                                    : HTTP_XML_CALC
                                    : peStartProc
                                    : peEndProc
                                    : peUsrDta );
          unlink(wwFile);

          if (wwRC = 0);
             return 1;
          else;
             return -1;
          endif;
      /end-free
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * ParseXML(): (internal) routine called by HTTPAPI when any
      *             data is received.  We buffer it and pass it along
      *             to XML_Parse (part of Expat) as required.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P ParseXML        B                   export
     D ParseXML        PI            10I 0
     D   peFD                        10I 0 value
     D   peData                    8192A   options(*varsize)
     D   peLength                    10I 0 value

     D done            s             10I 0 inz(0)

      /free
         if (peLength = 0);
            done = 1;
         endif;

         if (wkElemRoot.errcode > 0);
            return peLength;
         endif;

         if ( XML_Parse( wkParser: %addr(peData): peLength: done )
                 = XML_STATUS_ERROR );
             wkElemRoot.errcode = XML_GetErrorCode(wkParser);
             wkElemRoot.line    = XML_GetCurrentLineNumber(wkParser);
             wkElemRoot.column  = XML_GetCurrentColumnNumber(wkParser);
         endif;

        return peLength;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * InitParser():  Initialize the XML parser that will parse the
      *                data that we receive, and associate it with
      *                our element stack...
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P InitParser      B
     D InitParser      PI                  like(XML_Parser)
     D   peElemStack                       likeds(elemroot)
     D   peEncoding                 100C   const
     D wwParser        s                   like(XML_Parser)
      /free

          peElemStack.namespace = wkNamespace;
          peElemStack.nschar    = x'0c';
          peElemStack.StripCRLF = wkStripCRLF;

          peElemStack.xlate     = new_iconv(13488: 0);

          select;
          when wkNamespace=*off and peEncoding=*blanks;
             wwParser = XML_ParserCreate(*omit);
          when wkNamespace=*off;
             wwParser = XML_ParserCreate(peEncoding);
          when peEncoding=*blanks;
             wwParser = XML_ParserCreateNS(*omit: peElemStack.nschar);
          other;
             wwParser = XML_ParserCreateNS(peEncoding: peElemStack.nschar);
          endsl;

          XML_SetUserData(wwParser: %addr(peElemStack));

          XML_SetElementHandler( wwParser
                               : %paddr(startElement)
                               : %paddr(endElement) );

          XML_SetCharacterDataHandler( wwParser
                                     : %paddr(charData) );

          return wwParser;

      /end-free
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_parser_switch_cb(): delegates element processing to another
      *     set of start and end element callback procedures for the
      *     current element and its children.
      *
      *    peUsrDta = (input) user-defined data that will be passed to
      *                       the call-back routine. usuallay only that
      *                       portion of the curent user data is forwarded
      *                       to the new callback procedures that they are
      *                       responsible for.
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *
      *  Returns  -1 upon failure, 0 upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_switch_cb...
     P                 B                   export
     D http_parser_switch_cb...
     D                 PI            10I 0
     D  peUsrDta                       *   value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr options(*nopass)

     D p_newCBStackE   s               *
     D newCBStackE     ds                  likeds(cbStackE)
     D                                     based(p_newCBStackE)

     D p_root          s               *   inz(%addr(wkElemRoot))
     D root            ds                  likeds(elemroot)
     D                                     based(p_root)

     D endProc         s                   like(peEndProc) inz(*NULL)

      /free

          p_element = root.entry(root.depth);

          // get optional parameters

          if (%parms() >= 3);
             endProc = peEndProc;
          endif;

          // return to caller on illegal calls

          if (not wkInsideStartCB);
             SetError(HTTP_ILLSWC: 'Switching callback not allowed +
                                   from outside start element procedure.');
             HTTP_Crash();
             return -1;
          endif;

          if (wkCBSwitched);
             SetError(HTTP_ILLSWC: 'XML Callback already switched at +
                                    current level!');
             HTTP_Crash();
             return -1;
          endif;

          if (peStartProc = *NULL and endProc = *NULL);
             SetError(HTTP_ILLSWC: 'You must either specify a start or end +
                                    callback procedure to switch to!');
             return -1;
          endif;

          // make room for a new callback stack entry

          root.cbStackCnt = root.cbStackCnt + 1;
          root.cbStack(root.cbStackCnt) =xalloc(%size(newCBStackE));
          p_newCBStackE = root.cbStack(root.cbStackCnt);
          newCBStackE = *ALLX'00';

          // push existing root values on stack

          newCBStackE.depth    = root.depth;
          newCBStackE.pathOfs  = root.pathOfs;
          newCBStackE.depthOfs = root.depthOfs;
          newCBStackE.startcb  = root.startcb;
          newCBStackE.endcb    = root.endcb;
          newCBStackE.userData = root.userData;

          // activate new callback procedures

          root.startcb  = peStartProc;
          root.endcb    = endProc;
          root.userData = peUsrDta;
          root.pathOfs  = %len(element.path);
          root.depthOfs = root.depth - 1;

          root.cbHasChanged = *ON;

          http_dmsg('INFO: element processing has been delegated +
                           for element: <' + element.name + '>');

        return 0;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_parser_get_start_cb(): returns the procedure pointer of
      *     the currently active start callback procedure.
      *
      *  Returns procedure pointer of start callback procedure.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_get_start_cb...
     P                 B                   export
     D http_parser_get_start_cb...
     D                 PI              *   procptr

     D p_root          s               *   inz(%addr(wkElemRoot))
     D root            ds                  likeds(elemroot)
     D                                     based(p_root)
      /free
        return root.startcb;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_parser_get_end_cb(): returns the procedure pointer of
      *     the currently active end callback procedure.
      *
      *  Returns procedure pointer of end callback procedure.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_get_end_cb...
     P                 B                   export
     D http_parser_get_end_cb...
     D                 PI              *   procptr

     D p_root          s               *   inz(%addr(wkElemRoot))
     D root            ds                  likeds(elemroot)
     D                                     based(p_root)
      /free
        return root.endcb;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_parser_get_userdata(): returns the procedure pointer of
      *     the currently active user data.
      *
      *  Returns procedure pointer of user data.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_get_userdata...
     P                 B                   export
     D http_parser_get_userdata...
     D                 PI              *

     D p_root          s               *   inz(%addr(wkElemRoot))
     D root            ds                  likeds(elemroot)
     D                                     based(p_root)
      /free
        return root.userdata;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Expat calls this when the start tag for an element appears
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P startElement    B                   export
     D startElement    PI
     D   root                              likeds(elemroot)
     D   localName                16373C   options(*varsize)
     D   atts                          *   dim(32767) options(*varsize)

     D p_oldElem       s               *
     D oldElem         ds                  likeds(element)
     D                                     based(p_oldElem)

     D p_newElem       s               *
     D newElem         ds                  likeds(element)
     D                                     based(p_newElem)

     D p_callback      s               *   procptr
     D Callback        PR                  extproc(p_callback)
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D CallbackNS      PR                  extproc(p_callback)
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D p_AttrAry       s               *
     D wwAttrAry       s               *   dim(32767) based(p_AttrAry)

     D len             s             10I 0
     D pos             s             10I 0
     D xlname          s           1024a   based(p_xlname)

      /free

          // set 'inside start element callback procedure' flag

          wkInsideStartCB = *ON;

          // reset 'callback switched' flag

          wkCBSwitched   = *OFF;

          // make room for a new element.

          root.depth = root.depth + 1;
          root.entry(root.depth) = xalloc(%size(newElem));
          p_newElem = root.entry(root.depth);
          newElem = *ALLX'00';

          // make room for data in the new element.

          newElem.size      = 0;
          newElem.AllocSize = CHUNKSIZE;
          newElem.value     = xalloc(CHUNKSIZE);

          // copy path from previous element.

          if (root.depth > 1);
             p_oldElem = root.entry(root.depth - 1);
             newElem.path = oldElem.path + '/' + oldElem.name;
          endif;

          // set new name & translate to EBCDIC.

          len = %scan(u'0000': localName) - 1;
          len = iconvdyn( len * 2
                        : %addr(localName)
                        : root.xlate
                        : p_xlname );
          newElem.name = %subst(xlname:1:len);

          // if namespaces are enabled, separate namespace...

          if (root.namespace);
              newElem.ns = '';
              pos = %scan(root.nschar: newElem.name);
              if (pos>1 and pos<len);
                  newElem.ns   = %subst(newElem.name:1:pos-1);
                  newElem.name = %subst(newElem.name:pos+1);
              endif;
          endif;

          newElem.attrs = copyAttrs(root:atts);

          // Stay in loop until callback procedure has not been changed
          // anymore. 'root.cbHasChanged' may be set on by the
          // http_parser_switch_cb() routine.

          dou (not root.cbHasChanged);

             root.cbHasChanged = *OFF;

             if (root.startcb <> *NULL);
                p_AttrAry = newElem.Attrs;
                p_callback = root.startcb;
                if (root.namespace);
                    CallbackNS( root.userdata
                              : rootDepth(root)
                              : newElem.ns
                              : newElem.name
                              : elemPath(root: newElem)
                              : wwAttrAry );
                else;
                    Callback( root.userdata
                            : rootDepth(root)
                            : newElem.name
                            : elemPath(root: newElem)
                            : wwAttrAry );
                endif;
             endif;

          enddo;

          // reset 'inside start element callback procedure' flag

          wkInsideStartCB = *OFF;

          return;
      /end-free
     P                 E

      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * charData(): Expat calls this when character data is found in
      *             between one element and another.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P charData        B                   export
     D charData        PI
     D   root                              likeds(elemroot)
     D   string                   16373C   options(*varsize)
     D   len                         10I 0 value
     D x               s             10I 0
     D y               s             10I 0
     D newsize         s             10u 0
     D newval          s                   like(string) based(p_newval)
      /free

          p_element = root.entry(root.depth);

          newsize = element.size + (len * 2);
          dow (newsize > element.allocsize);
               element.allocsize = element.allocsize + CHUNKSIZE;
               element.value = xrealloc( element.value
                                       : element.allocsize );
          enddo;

          p_newval = element.value + element.size;

          if (root.StripCRLF=*ON);
              y = 0;
              for x = 1 to len;
                  if (%subst(string: x: 1) <> u'000d'
                      and %subst(string: x: 1) <> u'000a');
                         y = y + 1;
                         %subst(newval:y:1) = %subst(string:x:1);
                  endif;
              endfor;
          else;
              y = len;
              %subst(newval:1:y) = %subst(string:1:y);
          endif;

          element.size = element.size + (y*2);
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  Expat calls this when the close tag for an element appears
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P endElement      B                   export
     D endElement      PI
     D   root                              likeds(elemroot)
     D   name                          *   value

     D p_callback      s               *   procptr
     D Callback        PR                  extproc(p_callback)
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   retval                        *   value
     D   Attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D CallbackNS      PR                  extproc(p_callback)
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   ns                        1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   retval                        *   value
     D   Attrs                         *   dim(32767)
     D                                     const options(*varsize)

     D p_AttrAry       s               *
     D wwAttrAry       s               *   dim(32767) based(p_AttrAry)

     D valDS           ds
     D   p_newval                      *   inz(*null)
     D   len                         10i 0 inz(0)

     D newval          s          65535a   based(p_newval)
     D newvalucs       s          16383c   based(p_newval)
     D value           s          65535a   varying
     D ucs2val         s          16383c   varying
     D p_retval        s               *

      /free

          p_element = root.entry(root.depth);

          if (root.endcb <> *NULL);

             p_AttrAry  = element.attrs;
             p_callback = root.endcb;
             p_newval   = *null;
             value      = '';
             len        = 0;

             // Translate to EBCDIC and copy into valDS

             if (element.size >= 1);
                if (wkXmlReturnUCS);
                   p_newval = element.value;
                   len      = element.size;
                else;
                   len = iconvdyn( element.size
                                 : element.value
                                 : root.xlate
                                 : p_newval );
                endif;
             endif;


             // Convert valDS into a string to pass to callback
             //  (unless user requested XmlReturnPtr)

             select;
             when wkXmlReturnPtr = *on;
                 p_retval = %addr(valDs);
             when (wkXmlReturnUCS);
                if (len > %div(%size(ucs2val):2) - VARPREF);
                  len = %div(%size(ucs2val):2) - VARPREF;
                endif;
                ucs2val = %subst(newvalucs:1:len);
                p_retval = %addr(ucs2val);
             other;
                if (len > %size(value)-VARPREF);
                   len = %size(value) - VARPREF;
                endif;
                value = %subst(newval:1:len);
                p_retval = %addr(value);
             endsl;

             if (root.namespace);
                 CallbackNS( root.userdata
                           : rootDepth(root)
                           : element.ns
                           : element.name
                           : elemPath(root: element)
                           : p_retval
                           : wwAttrAry
                         );
             else;
                 Callback( root.userdata
                         : rootDepth(root)
                         : element.name
                         : elemPath(root: element)
                         : p_retval
                         : wwAttrAry
                         );
             endif;
             if (p_newval <> *null and wkXmlReturnUcs=*off);
                xdealloc(p_newval);
             endif;
          endif;

          // restore previous callback procedures from stack

          if (root.cbStackCnt > 0);
             p_cbStackE = root.cbStack(root.cbStackCnt);
             if (cbStackE.depth = root.depth);
                root.startcb  = cbStackE.startcb;
                root.endcb    = cbStackE.endcb;
                root.userData = cbStackE.userData;
                root.pathOfs  = cbStackE.pathOfs;
                root.depthOfs = cbStackE.depthOfs;
                xdealloc(root.cbStack(root.cbStackCnt));
                p_cbStackE = *NULL;
                root.cbStackCnt = root.cbStackCnt - 1;
                http_dmsg('INFO: delegation of element processing has been +
                                 stopped for element: <' + element.name + '>');
             endif;
          endif;

          // free element data

          freeAttrs(element.attrs);
          xdealloc(element.value);
          xdealloc(root.entry(root.depth));
          p_element = *NULL;
          root.depth = root.depth - 1;

          return;
      /end-free
     P                 E


      ******************************************************************
      * copyAttrs():  Allocate space for tag attributes, copy them
      *               to the space, and translate them to EBCDIC
      ******************************************************************
     P copyAttrs       B
     D copyAttrs       PI              *
     D   root                              likeds(elemroot)
     D   peAttr                        *   dim(32767) options(*varsize)

     D x               s             10I 0
     D wwCount         s             10I 0
     D wwLen           s             10I 0

     D p_Array         s               *
     D wwArray         s               *   dim(32767) based(p_Array)

     D p_endnull       s               *
     D endnull         s              1A   based(p_endnull)
     D p_endnull2      s               *
     D endnull2        s              1C   based(p_endnull2)

     D attrdta         s          16383C   based(p_attrdta)
     D xlname          s           1024a   based(p_xlname)

      /free

         // figure out how many elements are in the peAttr array:

         x = 1;
         dow peAttr(x) <> *NULL;
            x = x + 1;
         enddo;
         wwCount = x;

         // allocate space for the array of pointers

         p_array = xalloc(%size(p_array) * wwCount);


         // allocate space for each attribute, copy it, and
         //  if needed, translate it to EBCDIC

         for x = 1 to (wwCount - 1);
            p_attrdta = peAttr(x);
            wwLen = %scan(u'0000': attrdta);
            if (wwLen = 0);
               wwLen = %len(attrdta);
            endif;
            if (wkXmlReturnUCS);
               if wwLen >= 1;
                  wwArray(x) = xalloc(wwLen * 2);
                  memcpy(wwArray(x): p_attrdta: wwLen * 2 );
               else;
                  wwArray(x) = xalloc(%size(endnull2));
                  p_endnull2 = wwArray(x);
                  endnull2 = u'0000';
               endif;
            else;
               wwLen = iconvdyn( wwLen * 2
                               : p_attrdta
                               : root.xlate
                               : wwArray(x) );
               if (wwLen < 1);
                  wwArray(x) = xalloc(%size(endnull));
                  p_endnull = wwArray(x);
                  endnull = x'00';
               endif;
            endif;
         endfor;

         wwArray(wwCount) = *NULL;

         return p_Array;
      /end-free
     P                 E


      ******************************************************************
      * rootDepth():  returns the depth of a given element
      ******************************************************************
     P rootDepth       B
     D rootDepth       PI                         like(elemroot.depth)
     D   root                              value  likeds(elemroot)

      /free

         return root.depth - root.depthOfs;

      /end-free
     P                 E


      ******************************************************************
      * elemPath():  returns the path of a given element
      ******************************************************************
     P elemPath        B
     D elemPath        PI                         like(element.path)
     D   root                              value  likeds(elemroot)
     D   elem                              value  likeds(element)

      /free

         if (rootDepth(root) = 1);
            return '';
         else;
            return %subst(elem.path: root.pathOfs + 1);
         endif;

      /end-free
     P                 E

      ******************************************************************
      * freeAttrs():  deallocate the memory allocaed by copyAttrs
      ******************************************************************
     P freeAttrs       B
     D freeAttrs       PI
     D   peAttrs                       *   value

     D x               s             10I 0
     D p_Array         s               *
     D wwArray         s               *   dim(32767) based(p_Array)

      /free

           p_Array = peAttrs;
           x = 1;

           dow wwArray(x) <> *NULL;
              xdealloc(wwArray(x));
              x = x + 1;
           enddo;

           xdealloc(peAttrs);

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      *  http_parse_xml_stmf(): Parse XML data directly from a stream file
      *                         (instead of downloading it from a server)
      *
      *      peFile = (input) Stream file (in IFS) to read data from
      *     peCCSID = (input) CCSID of stream file,
      *                    or HTTP_XML_CALC to attempt to calculate it
      *                       from the XML encoding
      *                    or HTTP_STMF_CALC to use the stream file's
      *                       CCSID attribute.
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *
      *  Returns  -1 upon failure, 0 upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parse_xml_stmf...
     P                 B                   export
     D http_parse_xml_stmf...
     D                 PI            10I 0
     D  peFile                    32767A   varying const options(*varsize)
     D  peCCSID                      10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value

     D wwFD            S             10I 0
     D wwRC            S             10I 0
     D wwLen           S             10I 0
     D wwBuf           S           8192a
     D wwXBuf          s           8192a   based(p_Buf)
     D wwEncoding      s            100C
     D wwManual        s              1N   inz(*OFF)

      /free

       // *********************************************************
       // * open file to be parsed
       // *********************************************************

         select;
         when peCCSID = HTTP_XML_CALC;
            wwEncoding = *blanks;
            wwFD = open(%trimr(peFile) : O_RDONLY );
         when peCCSID = HTTP_STMF_CALC;
            wwEncoding = XML_ENC_UTF8;
            wwFD = open( %trimr(peFile)
                       : O_RDONLY + O_TEXTDATA + O_CCSID
                       : 0
                       : 1208 );
         other;
            HTTP_xml_SetCCSIDs(peCCSID: 1208);
            wwFD = open(%trimr(peFile) : O_RDONLY);
            wwEncoding = XML_ENC_UTF8;
            wwManual = *ON;
         endsl;

         if ( wwFD < 0 );
            SetError(HTTP_FDOPEN
                    : 'open(): ' + %str(strerror(errno)));
            return -1;
         endif;


       // *********************************************************
       //  Initialize the XML parser & our own data
       // *********************************************************

         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot: wwEncoding);


       // *********************************************************
       //  Read the stream file data and pass it to the parser
       // *********************************************************

         wwRC = 0;
         dow '1';
             wwLen = read(wwFD: %addr(wwBuf): %size(wwBuf));
             if (wwLen < 1) ;
                 leave;
             endif;

             if (wwManual);
                 wwLen = xml_xlate( wwLen: %addr(wwBuf): p_buf );
                 wwLen = parsexml(0: wwXBuf: wwLen);
                 xdealloc(p_Buf);
             else;
                 wwLen = parsexml(0: wwBuf: wwLen);
             endif;

             if (wwLen < 0);
                 leave;
             endif;
         enddo;

         callp close(wwFD);

         if (wkElemRoot.errcode = 0);
            ParseXML(0: wwBuf: 0);
         endif;


       // *********************************************************
       //   Check for error.
       // *********************************************************

         if (wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                   + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            %len(wkElemRoot.buf) = 0;
            wwRC = -1;
         endif;

       // *********************************************************
       //  All done!
       // *********************************************************

         close_iconv(wkElemRoot.xlate);
         XML_ParserFree(wkParser);
         return wwRC;

      /end-free
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_xmlns():  Enable XML Namespace processing
      *
      *     peEnable = (input) *ON to enable parsing, *OFF to disable.
      *                        (it is disabled by default)
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
     P http_xmlns      B                   export
     D http_xmlns      PI
     D   peEnable                     1N   const
      /free
         if (peEnable=*On or peEnable=*OFF);
            wkNamespace = peEnable;
         endif;
      /end-free
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_XmlReturnPtr(): XML End Element Handler should return a
      *                      pointer to the full element value instead of
      *                      returning a VARYING character string.
      *                      (VARYING is limited to 64k)
      *
      *     peEnable = (input) *ON to return a pointer, *OFF to return
      *                        a VARYING string (*OFF = default)
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
     P http_XmlReturnPtr...
     P                 B                   export
     D http_XmlReturnPtr...
     D                 PI
     D   peEnable                     1N   const
      /free
         if (peEnable=*On or peEnable=*OFF);
            wkXmlReturnPtr = peEnable;
         endif;
      /end-free
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_XmlStripCRLF(): Enable stripping of CRLF characters
      *
      *     peEnable = (input) *ON to strip, *OFF to leave them in.
      *                        (they are stripped by default)
      *
      * Note: To simplify your XML string manipulations, HTTPAPI
      *       strips CRLF characters from the response.  If you would
      *       prefer that they are left in the response, call this
      *       routine with a parameter of *OFF.
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
     P http_XmlStripCRLF...
     P                 B                   export
     D http_XmlStripCRLF...
     D                 PI
     D   peEnable                     1N   const
      /free
         if (peEnable=*On or peEnable=*OFF);
            wkStripCRLF = peEnable;
         endif;
      /end-free
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_parse_xml_string():  Parse XML from an input string.
      *                         (instead of downloading it from a server)
      *
      *    peString = (input) Pointer to string
      *       peLen = (input) Length of string to parse
      *     peCCSID = (input) CCSID of string to be parsed
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *
      *  Returns  -1 upon failure, 0 upon success
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parse_xml_string...
     P                 B                   export
     D http_parse_xml_string...
     D                 PI            10i 0
     D  peString                       *   value
     D  peLen                        10I 0 value
     D  peCCSID                      10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value

     D wwRC            S             10I 0
     D wwLen           S             10I 0
     D wwBuf           S           8192a   based(peString)
     D wwXBuf          s           8192a   based(p_Buf)

      /free

       // *********************************************************
       //  Initialize the XML parser & our own data
       //
       //  Translate the data to UTF-8.
       //
       //  Parse the XML
       // *********************************************************

         HTTP_xml_SetCCSIDs(peCCSID: 1208);
         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot: XML_ENC_UTF8);

         wwLen = xml_xlate( peLen: peString: p_buf );
         wwLen = ParseXML(0: wwXBuf: wwLen);
         xdealloc(p_Buf);

         if (wkElemRoot.errcode = 0);
            ParseXML(0: wwBuf: 0);
         endif;


       // *********************************************************
       //   Check for error.
       // *********************************************************

         if (wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                   + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            %len(wkElemRoot.buf) = 0;
            wwRC = -1;
         endif;

       // *********************************************************
       //  All done!
       // *********************************************************

         close_iconv(wkElemRoot.xlate);
         XML_ParserFree(wkParser);
         return wwRC;

      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_nextXmlAttr():  Retrieve next XML attribute from attrs list
      *
      *      attrs = (input) attribute list to extract from
      *        num = (i/o)   position in attribute list.  On first
      *                      call, set this to 1.  HTTPAPI will
      *                      increment this as it moves through the list
      *       name = (output) XML attribute name (from list)
      *        val = (output) XML attribute value (from list)
      *
      * Returns *ON normally, *OFF if there's no more attributes to read
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_nextXmlAttr...
     P                 B                   EXPORT
     D HTTP_nextXmlAttr...
     D                 PI             1N
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D   num                         10i 0
     D   name                      1024a   varying
     D   val                      65535a   varying
     D x               s             10i 0
      /free
         x = num * 2;
         if attrs(x-1) = *null;
            return *OFF;
         else;
            name = %str(attrs(x-1));
         endif;

         if attrs(x) = *null;
            return *OFF;
         else;
            val = %str(attrs(x));
         endif;

         num = num + 1;
         return *ON;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * HTTP_nextXmlAttrUCS(): Retrieve next XML attribute from attrs list
      *                     ONLY use this when using http_xmlReturnUCS(*ON)
      *
      *      attrs = (input) attribute list to extract from
      *        num = (i/o)   position in attribute list.  On first
      *                      call, set this to 1.  HTTPAPI will
      *                      increment this as it moves through the list
      *       name = (output) XML attribute name (from list)
      *        val = (output) XML attribute value (from list)
      *
      * Returns *ON normally, *OFF if there's no more attributes to read
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P HTTP_nextXmlAttrUCS...
     P                 B                   EXPORT
     D HTTP_nextXmlAttrUCS...
     D                 PI             1N
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D   num                         10i 0
     D   name                      1024c   varying
     D   val                      65535c   varying

     D x               s             10i 0
     D p_nameData      s               *
     D nameData        s           1024c   based(p_nameData)
     D p_valData       s               *
     D valData         s          65535c   based(p_valData)
     D len             s             10i 0
      /free
         x = num * 2;
         if attrs(x-1) = *null;
            return *OFF;
         else;
            p_nameData = attrs(x-1);
            len = %scan(u'0000': nameData) - 1;
            select;
            when len = -1;
              name = nameData;
            when len = 0;
              name = '';
            other;
              name = %subst(nameData:1:len);
            endsl;
         endif;

         if attrs(x) = *null;
            return *OFF;
         else;
            val = %str(attrs(x));
            p_valData = attrs(x);
            len = %scan(u'0000': valData) - 1;
            select;
            when len = -1;
              val = valData;
            when len = 0;
              val = '';
            other;
              val = %subst(valData:1:len);
            endsl;
         endif;

         num = num + 1;
         return *ON;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * http_EscapeXml(): Escape any special characters used by XML
      *
      *     peString = (input) string to escape
      *
      * Returns escaped string.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_EscapeXml  B                   export
     D http_EscapeXml  PI          4096a   varying
     D  peString                   4096a   varying const
     D result          s                   like(peString)
      /free
         result = peString;
         Xreplace(result: '&': '&amp;');
         Xreplace(result: '<': '&lt;');
         Xreplace(result: '>': '&gt;');
         Xreplace(result: '''': '&apos;');
         Xreplace(result: '"': '&quot;');
         return result;
      /end-free
     P                 E


      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * Xreplace(): Use the %scan/%replace BIFs to replace one string
      *            with another.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P Xreplace        b
     D Xreplace        pi
     D    string                   4096a   varying
     D    fromstr                    10a   varying const
     D    tostr                      10a   varying const

     D pos             s             10i 0
      /free
         pos = %scan(fromStr: string);
         dow pos > 0;
            string = %replace(toStr: string: pos: %len(fromStr));
            pos = pos + %len(toStr);
            if pos < %len(string);
               pos = %scan(fromStr: string: pos+1);
            else;
               pos = 0;
            endif;
         enddo;
      /end-free
     P                 E


      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_XmlReturnUCS(): The XML End Handler should get it's data
      *                      in UCS-2 Unicode (RPG data type C) instead
      *                      of EBCDIC (RPG data type A)
      *
      *     peEnable = (input) *ON to return data in Unicode
      *                       *OFF to return data in EBCDIC (default)
      *
      * NOTE: This can be used in conjunction with http_XmlReturnPtr.
      *       When XmlReturnPtr is off, the data is returned as a
      *       UCS-2 VARYING parameter.  When XmlReturnPtr=on, the data
      *       is returned as a pointer to a DS containing UCS-2
      *       data (as opposed to alphanumeric)
      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
     P http_XmlReturnUCS...
     P                 B                   export
     D http_XmlReturnUCS...
     D                 PI
     D   peEnable                     1N   const
      /free
         if (peEnable=*On or peEnable=*OFF);
            wkXmlReturnUCS = peEnable;
         endif;
      /end-free
     P                 E

      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_parser_init():   Initializes the XML parser.
      *                       Afterwards http_parser_parseChunk() can
      *                       can be used to parse a given XML stream.
      *
      *     peCCSID = (input) CCSID of string to be parsed
      * peStartProc = (input) call-back procedure to call at the start
      *                       of each XML element received.
      *   peEndProc = (input) call-back procedure to call at the end
      *                       of each XML element received.
      *    peUsrDta = (input) user-defined data that will be passed
      *                          to the call-back routine
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_init...
     P                 B                   export
     D http_parser_init...
     D                 PI
     D  peCCSID                      10I 0 const options(*omit)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value

      /free

       // *********************************************************
       //  Reset error status
       // *********************************************************

         SetError(0: *blanks);

       // *********************************************************
       //  Initialize the XML parser & our own data
       // *********************************************************

         if (%parms() >= 1 and %addr(peCCSID) <> *null);
            HTTP_xml_SetCCSIDs(peCCSID: 1208);
         endif;

         wkElemRoot = *ALLx'00';
         wkElemRoot.userdata = peUsrDta;
         wkElemRoot.startcb = peStartProc;
         wkElemRoot.endcb = peEndProc;
         %len(wkElemRoot.buf) = 0;

         wkParser = InitParser(wkElemRoot: XML_ENC_UTF8);

      /end-free
     P                 E

      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_parser_parseChunk():  Parses a given chunk of XML data.
      *                            Can be invoked multiple times in
      *                            between http_parser_init() and
      *                            http_parser_free.
      *
      *        peFD = (input) Open file descriptor. Not used here but
      *                       required for compatibility reasons.
      *      peData = (input) Pointer of the XML data.
      *    peLength = (input) Length of the XML data.
      *
      *  Returns the length of the parsed buffer on success, else -1.
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_parseChunk...
     P                 B                   export
     D http_parser_parseChunk...
     D                 PI            10I 0
     D   peFD                        10I 0 value
     D   peData                        *   value  options(*string)
     D   peLength                    10I 0 value

     D wwXBuf          s           8192a   based(p_Buf)
     D wwLen           s             10I 0
     D wwRC            S             10I 0

      /free

         wwLen = xml_xlate( peLength: peData: p_buf );
         wwLen = ParseXML(0: wwXBuf: wwLen);
         xdealloc(p_Buf);

         if (wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                   + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            %len(wkElemRoot.buf) = 0;
            wwLen = -1;
         endif;

         return wwLen;

      /end-free
     P                 E

      *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +
      * http_parser_free():  Frees a previously allocated parser.
      *
      *  peUpdError = (input) Update error information. Default: *ON.
      *
      *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     P http_parser_free...
     P                 B                   export
     D http_parser_free...
     D                 PI            10I 0
     D   peUpdError                    N   const  options(*nopass: *omit)

     D wwRC            s             10I 0
     D wwEmptyBuf      s              1A
     D wwUpdError      s                   like(peUpdError)

      /free

         if (%parms() >= 1 and %addr(peUpdError) <> *NULL);
            wwUpdError = peUpdError;
         else;
            wwUpdError = *ON;
         endif;

       // *********************************************************
       //   Terminate parser.
       // *********************************************************

         if (wkElemRoot.errcode = 0);
            ParseXML(0: wwEmptyBuf: 0);
         endif;

       // *********************************************************
       //   Check for error.
       // *********************************************************

         if (wwUpdError and wkElemRoot.errcode > 0);
            SetError(HTTP_XMLERR: 'XML parse failed at line '
                   + %char(wkElemRoot.line) + ', col '
                    + %char(wkElemRoot.column) + ': '
                    + %str(XML_ErrorString(wkElemRoot.errcode)));
            %len(wkElemRoot.buf) = 0;
            wwRC = -1;
         endif;

       // *********************************************************
       //  All done!
       // *********************************************************

         close_iconv(wkElemRoot.xlate);
         XML_ParserFree(wkParser);
         return wwRC;

      /end-free
     P                 E


      /define ERRNO_LOAD_PROCEDURE
      /copy errno_h
     /*-                                                                            +
      * Copyright (c) 2001-2025 Scott C. Klement                                    +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +

     ****  This is just used by the INSTALL program to determine if
     ****  SSL is to be included in the build.

      /copy config_h

     c     *entry        plist
     c                   parm                    peConfig          1

     c                   eval      peConfig = '0'
     c/if defined(HAVE_SSLAPI)
     c                   eval      peConfig = '1'
     c/endif

     c                   eval      *inlr = *on
     /*-                                                                            +
      * Copyright (c) 2012-2025 Thomas Raddatz                                      +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +
      *=====================================================================*
      *  NTLM: MD4 message-digest algorithm                                 *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  22.05.2012                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Date        Name          Description                              *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
     H OPTION(*SRCSTMT: *NODEBUGIO)
     H NOMAIN
      *=====================================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
     D UINT2           S              5U 0                         based(pDummy)
     D UINT4           S             10U 0                         based(pDummy)
      *
     D S11             C                   3
     D S12             C                   7
     D S13             C                   11
     D S14             C                   19
     D S21             C                   3
     D S22             C                   5
     D S23             C                   9
     D S24             C                   13
     D S31             C                   3
     D S32             C                   9
     D S33             C                   11
     D S34             C                   15
      *
      * ------------------------------------
      *  Exported prototypes
      * ------------------------------------
      /COPY MD4_H
      *
      * ------------------------------------
      *  Imported prototypes
      * ------------------------------------
      *
      *  memcpy -- Copy Bytes
      *     The behavior is undefined if copying takes place
      *     between objects that overlap.
      *     The memcpy() function returns a pointer to dest.
     D memcpy          PR              *          extproc('memcpy')
     D  i_pDest                        *   value
     D  i_pSrc                         *   value
     D  i_count                      10U 0 value
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      *
      *  MD4 basic transformation. Transforms state based on block.
     D MD4Transform...
     D                 PR
     D                                     extproc('MD4Transform')
     D  io_state                                  like(UINT4) dim(4)
     D  i_input                        *   value
      *
      *  Decodes input (unsigned char) into output (UINT4).
     D Decode...
     D                 PR
     D                                     extproc('Decode')
     D  o_output                                  like(UINT4) dim(16)
     D  i_input                       1A   const  dim(64)
      *
      *  Encodes input (UINT4) into output (unsigned char). Assumes
      *  len is a multiple of 4.
     D Encode...
     D                 PR
     D                                     extproc('Encode')
     D  o_output                      1A          dim(64) options(*varsize)
     D  i_input                       1A          dim(64) options(*varsize)
     D  i_len                        10U 0 value
      *
      *  Shift left.
     D shiftL...
     D                 PR            10U 0
     D                                     extproc('shiftL')
     D  i_value                      10U 0 value
     D  i_bits                       10U 0 value
      *
      *  Shift right.
     D shiftR...
     D                 PR            10U 0
     D                                     extproc('shiftR')
     D  i_value                      10U 0 value
     D  i_bits                       10U 0 value
      *
      *  F, G and H are basic MD4 functions.
     D F...
     D                 PR            10U 0
     D                                     extproc('F')
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      *
     D G...
     D                 PR            10U 0
     D                                     extproc('G')
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      *
     D H...
     D                 PR            10U 0
     D                                     extproc('H')
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      *
      *  Rotates x left n bits.
     D ROTATE_LEFT...
     D                 PR            10U 0
     D                                     extproc('ROTATE_LEFT')
     D  x                            10U 0 const
     D  n                            10U 0 const
      *
      *  FF, GG and HH are transformations for rounds 1, 2 and 3 */
     D FF...
     D                 PR
     D                                     extproc('FF')
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      *
     D GG...
     D                 PR
     D                                     extproc('GG')
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      *
     D HH...
     D                 PR
     D                                     extproc('HH')
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      *
      *  Truncates a given value to a 4-byte unsigned integer value.
     D truncate...
     D                 PR            10U 0
     D                                     extproc('truncate')
     D  i_value                      20U 0 value
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  MD4 initialization. Begins an MD4 operation, writing a new context.
      *=====================================================================*
     P MD4Init_r...
     P                 B                   export
      *
     D MD4Init_r...
     D                 PI
     D  context                                   likeds(MD4_CTX_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         context.count(1) = 0;
         context.count(2) = 0;

         context.state(1) = x'67452301';
         context.state(2) = x'efcdab89';
         context.state(3) = x'98badcfe';
         context.state(4) = x'10325476';

         return;

      /END-FREE
      *
     P MD4Init_r...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  MD4 block update operation. Continues an MD4 message-digest
      *  operation, processing another message block, and updating the
      *  context.
      *=====================================================================*
     P MD4Update_r...
     P                 B                   export
      *
     D MD4Update_r...
     D                 PI
     D  context                                   likeds(MD4_CTX_t)
     D  input                          *   value
     D  inputLen                     10U 0 value
      *
      *  Local fields
     D i               S             10U 0 inz
     D index           S             10U 0 inz
     D partLen         S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Compute number of bytes mod 64
         index = %bitand(shiftR(context.count(1): 3): x'3F');

         // Update number of bits
         context.count(1) = context.count(1) + shiftL(inputLen: 3);
         if (context.count(1) < shiftL(inputLen: 3));
            context.count(2) = context.count(2) + 1;
         endif;
         context.count(2) = context.count(2) + shiftR(inputLen: 29);

         partLen = 64 - index;

         // Transform as many times as possible.
         if (inputLen >= partLen);
            memcpy(%addr(context.buffer) + index: input: partLen);

            MD4Transform(context.state: %addr(context.buffer));

            i = partLen;
            dow (i + 63 < inputLen);
               MD4Transform(context.state: input + i - 1);
               i = i + 64;
            enddo;

            index = 0;
         else;
            i = 0;
         endif;

         // Buffer remaining input
         memcpy(%addr(context.buffer) + index: input + i: inputLen - i);

         return;

      /END-FREE
      *
     P MD4Update_r...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  MD4 finalization. Ends an MD4 message-digest operation, writing
      *  the message digest and zeroizing the context.
      *=====================================================================*
     P MD4Final_r...
     P                 B                   export
      *
     D MD4Final_r...
     D                 PI
     D  digest                       16A
     D  context                                   likeds(MD4_CTX_t)
      *
      *  Local fields
     D bits            S              8A   inz(*ALLx'00')
     D index           S             10U 0 inz
     D padLen          S             10U 0 inz
      *
     D PADDING         S             64A   inz(
     D                                     x'80000000000000000000000000000000+
     D                                       00000000000000000000000000000000+
     D                                       00000000000000000000000000000000+
     D                                       00000000000000000000000000000000')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Save number of bits
         Encode(bits: context.countA: 8);

         // Pad out to 56 mod 64.
         index = %bitand(shiftR(context.count(1): 3): x'3f');
         if (index < 56);
            padLen = 56 - index;
         else;
            padLen = 120 - index;
         endif;

         MD4Update_r(context: %addr(PADDING): padLen);

         // Append length (before padding)
         MD4Update_r(context: %addr(bits): 8);

         // Store state in digest
         Encode(digest: context.stateA: 16);

         // Zeroize sensitive information.
         clear context;

         return;

      /END-FREE
      *
     P MD4Final_r...
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by ENCRYPTR4, RPGUNIT tests ***
      *  MD4 operation.
      *=====================================================================*
     P MD4Only_r...
     P                 B                   export
      *
     D MD4Only_r...
     D                 PI
     D  digest                                  like(MD4_digest_t)
     D  input                          *   value
     D  inputLen                     10U 0 value
      *
      *  Local fields
     D context         DS                  likeds(MD4_CTX_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         MD4Init_r(context);
         MD4Update_r(context: input: inputLen);
         MD4Final_r(digest: context);

         return;

      /END-FREE
      *
     P MD4Only_r...
     P                 E
      *
      *=====================================================================*
      *  MD4 basic transformation. Transforms state based on block.
      *=====================================================================*
     P MD4Transform...
     P                 B
      *
     D MD4Transform...
     D                 PI
     D  io_state                                  like(UINT4) dim(4)
     D  i_input                        *   value
      *
     D a               S                   like(UINT4)
     D b               S                   like(UINT4)
     D c               S                   like(UINT4)
     D d               S                   like(UINT4)
     D x               S                   like(UINT4) dim(16)
      *
     D block           S              1A   based(i_input) dim(64)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         a = io_state(1);
         b = io_state(2);
         c = io_state(3);
         d = io_state(4);

         Decode(x: block);

         // Round 1
         FF (a: b: c: d: x( 0+1): S11); //* 1 */
         FF (d: a: b: c: x( 1+1): S12); //* 2 */
         FF (c: d: a: b: x( 2+1): S13); //* 3 */
         FF (b: c: d: a: x( 3+1): S14); //* 4 */
         FF (a: b: c: d: x( 4+1): S11); //* 5 */
         FF (d: a: b: c: x( 5+1): S12); //* 6 */
         FF (c: d: a: b: x( 6+1): S13); //* 7 */
         FF (b: c: d: a: x( 7+1): S14); //* 8 */
         FF (a: b: c: d: x( 8+1): S11); //* 9 */
         FF (d: a: b: c: x( 9+1): S12); //* 10 */
         FF (c: d: a: b: x(10+1): S13); //* 11 */
         FF (b: c: d: a: x(11+1): S14); //* 12 */
         FF (a: b: c: d: x(12+1): S11); //* 13 */
         FF (d: a: b: c: x(13+1): S12); //* 14 */
         FF (c: d: a: b: x(14+1): S13); //* 15 */
         FF (b: c: d: a: x(15+1): S14); //* 16 */

         // Round 2
         GG (a: b: c: d: x( 0+1): S21);
         GG (d: a: b: c: x( 4+1): S22); //* 18 */
         GG (c: d: a: b: x( 8+1): S23); //* 19 */
         GG (b: c: d: a: x(12+1): S24); //* 20 */
         GG (a: b: c: d: x( 1+1): S21); //* 21 */
         GG (d: a: b: c: x( 5+1): S22); //* 22 */
         GG (c: d: a: b: x( 9+1): S23); //* 23 */
         GG (b: c: d: a: x(13+1): S24); //* 24 */
         GG (a: b: c: d: x( 2+1): S21); //* 25 */
         GG (d: a: b: c: x( 6+1): S22); //* 26 */
         GG (c: d: a: b: x(10+1): S23); //* 27 */
         GG (b: c: d: a: x(14+1): S24); //* 28 */
         GG (a: b: c: d: x( 3+1): S21); //* 29 */
         GG (d: a: b: c: x( 7+1): S22); //* 30 */
         GG (c: d: a: b: x(11+1): S23); //* 31 */
         GG (b: c: d: a: x(15+1): S24); //* 32 */

         // Round 3
         HH (a: b: c: d: x( 0+1): S31); //* 33 */
         HH (d: a: b: c: x( 8+1): S32); //* 34 */
         HH (c: d: a: b: x( 4+1): S33); //* 35 */
         HH (b: c: d: a: x(12+1): S34); //* 36 */
         HH (a: b: c: d: x( 2+1): S31); //* 37 */
         HH (d: a: b: c: x(10+1): S32); //* 38 */
         HH (c: d: a: b: x( 6+1): S33); //* 39 */
         HH (b: c: d: a: x(14+1): S34); //* 40 */
         HH (a: b: c: d: x( 1+1): S31); //* 41 */
         HH (d: a: b: c: x( 9+1): S32); //* 42 */
         HH (c: d: a: b: x( 5+1): S33); //* 43 */
         HH (b: c: d: a: x(13+1): S34); //* 44 */
         HH (a: b: c: d: x( 3+1): S31); //* 45 */
         HH (d: a: b: c: x(11+1): S32); //* 46 */
         HH (c: d: a: b: x( 7+1): S33); //* 47 */
         HH (b: c: d: a: x(15+1): S34); //* 48 */

         io_state(1) = truncate(io_state(1) + a);
         io_state(2) = truncate(io_state(2) + b);
         io_state(3) = truncate(io_state(3) + c);
         io_state(4) = truncate(io_state(4) + d);

         // Zeroize sensitive information.
         clear x;

         return;

      /END-FREE
      *
     P MD4Transform...
     P                 E
      *
      *=====================================================================*
      *  Decodes input (unsigned char) into output (UINT4).
      *=====================================================================*
     P Decode...
     P                 B
      *
     D Decode...
     D                 PI
     D  o_output                                  like(UINT4) dim(16)
     D  i_input                       1A   const  dim(64)
      *
     D output          S              1A   dim(64) based(pOutput)
      *
     D i               S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pOutput = %addr(o_output);

         for i = 1 to %elem(i_input) by 4;
            output(i) = i_input(i+3);
            output(i+1) = i_input(i+2);
            output(i+2) = i_input(i+1);
            output(i+3) = i_input(i);
         endfor;

         return;

      /END-FREE
      *
     P Decode...
     P                 E
      *
      *=====================================================================*
      *  Encodes input (UINT4) into output (unsigned char). Assumes
      *  len is a multiple of 4.
      *=====================================================================*
     P Encode...
     P                 B
      *
     D Encode...
     D                 PI
     D  o_output                      1A          dim(64) options(*varsize)
     D  i_input                       1A          dim(64) options(*varsize)
     D  i_len                        10U 0 value
      *
     D i               S             10U 0 inz
     D j               S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         j = 1;

         dow (j <= i_len);
            o_output(j) = i_input(j+3);
            o_output(j+1) = i_input(j+2);
            o_output(j+2) = i_input(j+1);
            o_output(j+3) = i_input(j);
            j = j + 4;
         enddo;

         return;

      /END-FREE
      *
     P Encode...
     P                 E
      *
      *=====================================================================*
      *  Shift left.
      *=====================================================================*
     P shiftL...
     P                 B
      *
     D shiftL...
     D                 PI            10U 0
     D  i_value                      10U 0 value
     D  i_bits                       10U 0 value
      *
      *  Required to avoid overflow.
     D result          DS                  qualified
     D  highUint               1      4U 0 inz
     D  lowUInt                5      8U 0 inz
     D  ULong                  1      8U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         result.lowUInt = i_value;

         dow (i_bits > 0);
            result.ULong = result.lowUInt * 2;
            i_bits = i_bits - 1;
         enddo;

         return result.lowUInt;

      /END-FREE
      *
     P shiftL...
     P                 E
      *
      *=====================================================================*
      *  Shift right.
      *=====================================================================*
     P shiftR...
     P                 B
      *
     D shiftR...
     D                 PI            10U 0
     D  i_value                      10U 0 value
     D  i_bits                       10U 0 value
      *
      *  Required to avoid overflow.
     D result          DS                  qualified
     D  highUint               1      4U 0 inz
     D  lowUInt                5      8U 0 inz
     D  ULong                  1      8U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         result.lowUInt = i_value;

         dow (i_bits > 0);
            result.ULong = result.lowUInt / 2;
            i_bits = i_bits - 1;
         enddo;

         return result.lowUInt;

      /END-FREE
      *
     P shiftR...
     P                 E
      *
      *=====================================================================*
      *  Basic MD4 function.
      *=====================================================================*
     P F...
     P                 B
      *
     D F...
     D                 PI            10U 0
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // (((x) & (y)) ] ((x) & (z)))
         return %bitor(%bitand(x: y): %bitand(%bitnot(x): z));

      /END-FREE
      *
     P F...
     P                 E
      *
      *=====================================================================*
      *  Basic MD4 function.
      *=====================================================================*
     P G...
     P                 B
      *
     D G...
     D                 PI            10U 0
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // (((x) & (y)) ] ((x) & (z)) ] ((y) & (z)))
         return %bitor(%bitand(x: y): %bitand(x: z): %bitand(y: z));

      /END-FREE
      *
     P G...
     P                 E
      *
      *=====================================================================*
      *  Basic MD4 function.
      *=====================================================================*
     P H...
     P                 B
      *
     D H...
     D                 PI            10U 0
     D  x                            10U 0 const
     D  y                            10U 0 const
     D  z                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // ((x)  (y)  (z))
         return %bitxor(%bitxor(x: y): z);

      /END-FREE
      *
     P H...
     P                 E
      *
      *=====================================================================*
      *  Rotates x left n bits.
      *=====================================================================*
     P ROTATE_LEFT...
     P                 B
      *
     D ROTATE_LEFT...
     D                 PI            10U 0
     D  x                            10U 0 const
     D  n                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return %bitor(shiftL(x: n): shiftR(x: 32-n));

      /END-FREE
      *
     P ROTATE_LEFT...
     P                 E
      *
      *=====================================================================*
      *  FF, GG and HH are transformations for rounds 1, 2 and 3 */
      *=====================================================================*
     P FF...
     P                 B
      *
     D FF...
     D                 PI
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // (a) += F ((b), (c), (d)) + (x);
         a = truncate(a + F(b: c: d) + x);

         // (a) = ROTATE_LEFT ((a), (s));
         a = ROTATE_LEFT(a: s);

         return;

      /END-FREE
      *
     P FF...
     P                 E
      *
      *=====================================================================*
      *  FF, GG and HH are transformations for rounds 1, 2 and 3 */
      *=====================================================================*
     P GG...
     P                 B
      *
     D GG...
     D                 PI
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // (a) += G ((b), (c), (d)) + (x) + (UINT4)0x5a827999;
         a = truncate(a + G(b: c: d) + x + x'5a827999');

         // (a) = ROTATE_LEFT ((a), (s));
         a = ROTATE_LEFT(a: s);

         return;

      /END-FREE
      *
     P GG...
     P                 E
      *
      *=====================================================================*
      *  FF, GG and HH are transformations for rounds 1, 2 and 3 */
      *=====================================================================*
     P HH...
     P                 B
      *
     D HH...
     D                 PI
     D  a                            10U 0
     D  b                            10U 0 const
     D  c                            10U 0 const
     D  d                            10U 0 const
     D  x                            10U 0 const
     D  s                            10U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // (a) += H ((b), (c), (d)) + (x) + (UINT4)0x6ed9eba1; 
         a = truncate(a + H(b: c: d) + x + x'6ed9eba1');

         // (a) = ROTATE_LEFT ((a), (s));
         a = ROTATE_LEFT(a: s);

         return;

      /END-FREE
      *
     P HH...
     P                 E
      *
      *=====================================================================*
      *  Truncates a given value to a 4-byte unsigned integer value.
      *=====================================================================*
     P truncate...
     P                 B
      *
     D truncate...
     D                 PI            10U 0
     D  i_value                      20U 0 value
      *
      *  Required to avoid overflow.
     D result          DS                  qualified
     D  highUint               1      4U 0 inz
     D  lowUInt                5      8U 0 inz
     D  ULong                  1      8U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         result.ULong = i_value;

         return result.lowUInt;

      /END-FREE
      *
     P truncate...
     P                 E
      *

     H NOMAIN

      /copy RDWR_H

     D Data_t          ds                  qualified
     D                                     template
     D

     D StringReader_t  ds                  qualified
     D                                     template

     D    h                                likeds(RDWR_t)
     D    data                             likeds(DATA_t)

     P http_StringReader...
     P                 B                   export
     D                 PI              *   opdesc
     D   str                           a   varying len(16000000)
     D
     D vanilla         ds                  likeds(RDWR_t) inz(*likeds)

     D stringReader    ds                  qualified
     D   h                                 likeds(RDWR_t)
     D   d
      /free
       p_hnd = %alloc(%size(hnd));
       hnd = vanilla;

       hnd.directions = RDWR_READER;

       hnd.open    = %paddr(http_StringReader_open);
       hnd.read    = %paddr(http_StringReader_close);
       hnd.write   = *null;
       hnd.close   = %paddr(http_StringReader_close);
       hnd.cleanup = %paddr(http_StringReader_cleanup);



      /end-free
     P                 E
     /*-                                                                            +
      * Copyright (c) 2012-2025 Thomas Raddatz                                      +
      * All rights reserved.                                                        +
      *                                                                             +
      * Redistribution and use in source and binary forms, with or without          +
      * modification, are permitted provided that the following conditions          +
      * are met:                                                                    +
      * 1. Redistributions of source code must retain the above copyright           +
      *    notice, this list of conditions and the following disclaimer.            +
      * 2. Redistributions in binary form must reproduce the above copyright        +
      *    notice, this list of conditions and the following disclaimer in the      +
      *    documentation and/or other materials provided with the distribution.     +
      *                                                                             +
      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ''AS IS'' AND      +
      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       +
      * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  +
      * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE     +
      * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  +
      * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     +
      * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       +
      * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  +
      * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   +
      * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      +
      * SUCH DAMAGE.                                                                +
      *                                                                             +
      */                                                                            +
      *=====================================================================*
      *  NTLM: NTLM Authentication                                          *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  28.02.2012                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Date        Name          Description                              *
      *  ----------  ------------  ---------------------------------------  *
      *  09.08.2012  Th.Raddatz    Fixed bug in performTranslation().       *
      *                            Translation fom 424 (Hebrew) to Unicode  *
      *                            failed.                                  *
      *                                                                     *
      *  09.08.2012  Th.Raddatz    Added procedure AuthPlugin_getRealm().   *
      *                                                                     *
      *  09.08.2012  Th.Raddatz    Changed the way the authentication       *
      *                            process is initialized. The dependancy   *
      *                            to the presence of a 'negotiate' header  *
      *                            has been removed.                        *
      *                                                                     *
      *  02.02.2016  Th.Raddatz    Fixed "index out of range" error in      *
      *                            procedure getToken().                    *
      *                            Removed duplicate procedure names from   *
      *                            the procedure interface and end procedure*
      *                            statements.                              *
      *                                                                     *
      *=====================================================================*
      /if defined(HAVE_SRCSTMT_NODEBUGIO)
     H OPTION(*NOSHOWCPY: *SRCSTMT: *NODEBUGIO)
      /endif
     H NOMAIN
      /COPY NTLM_C
      *=====================================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
     D type1_t         DS                  qualified               based(pDummy)
     D  flags                        10U 0
     D  domain                             like(ntlm_domain_t       )
     D  workstation                        like(ntlm_workstation_t  )
      *
     D type3_t         DS                  qualified               based(pDummy)
     D  flags                        10U 0
     D  domain                             like(ntlm_domain_t       )
     D  user                               like(ntlm_user_t         )
     D  workstation                        like(ntlm_workstation_t  )
     D  lmResponse                         like(ntlm_lmResponse_t   )
     D  ntResponse                         like(ntlm_ntlmResponse_t )
     D  sessionKey                         like(ntlm_sessionKey_t   )
      *
      *  Transcoder handle
     D transcoder_t...
     D                 DS                  qualified               based(pDummy)
     D  fromCcsid                    10U 0
     D  toCcsid                      10U 0
     D  hIconv                             likeds(iconv_t )
      *
      * ------------------------------------
      *  Exported prototypes
      * ------------------------------------
      /COPY NTLM_H
      /COPY NTLM_P
      *
      * ------------------------------------
      *  Imported prototypes
      * ------------------------------------
      /COPY HTTPAPI_H
      /COPY PRIVATE_H
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      *
      *  Resets the NTLM authentication status.
     D resetAuthentication...
     D                 PR
     D                                     extproc('resetAuthentication')
     D  i_resetAll                     N   const
      *
      *  Appends a given buffer to the NULL device.
     D nullWrite...
     D                 PR            10I 0
     D                                     extproc('nullWrite')
     D  i_fd                         10I 0 value
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
      *  Calculate the 'ResponseKeyLM' as described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
     D LMOWFv1...
     D                 PR            16A
     D                                     extproc('LMOWFv1')
     D  i_password                         const  like(ntlm_password_t )
     D                                            options(*varsize)
      *
      *  Encrypts an 8-byte data item D with the 16-byte key K using the
      *  Data Encryption Standard Long (DESL) algorithm.
      *  The result is 24 bytes in length.
     D desl...
     D                 PR            24A
     D                                     extproc('desl')
     D  i_key                        16A   const
     D  i_data                        8A   const
      *
      *  Creates a byte array of length N. Each byte
      *  in the array is initialized to the value zero.
     D z...
     D                 PR           128A          varying
     D                                     extproc('z')
     D  i_n                          10I 0 const
      *
      *  Parses a given URL.
     D parseUrl...
     D                 PR
     D                                     extproc('parseUrl')
     D   i_URL                    32767A   const  varying options(*varsize)
     D   o_service                   32A          varying
     D   o_host                     256A          varying
      *
      *  Returns an EBCDIC to ASCII transcoder.
     D getTranscoderToAscii...
     D                 PR                         like(hTranscoder_t )
     D                                     extproc('getTranscoderToAscii')
      *
      *  Returns an EBCDIC to UNICODE transcoder.
     D getTranscoderToUnicode...
     D                 PR                         like(hTranscoder_t )
     D                                     extproc('getTranscoderToUnicode')
      *
      *  Converts a given EBCDIC string to UNICODE or ASCII.
     D transcode...
     D                 PR          4096A          varying
     D                                     extproc('transcode')
     D  i_ebcdic                   2048A   const  varying
     D  i_isUnicode                    N   const
      *
      *  Returns the domain name of the i5 computer.
     D getDefaultDomain...
     D                 PR                         like(ntlm_domain_t )
     D                                     extproc('getDefaultDomain')
      *
      *  Returns the default workstation name.
     D getDefaultWorkstation...
     D                 PR                         like(ntlm_workstation_t )
     D                                     extproc('getDefaultWorkstation')
      *
      *  Returns the default flags for a all message types.
     D getDefaultFlags...
     D                 PR            10U 0
     D                                     extproc('getDefaultFlags')
      *
      *  Returns the default flags for a Type-1 message.
     D getDefaultFlagsType1...
     D                 PR            10U 0
     D                                     extproc('getDefaultFlagsType1')
      *
      *  Returns the default flags for a Type-3 message.
     D getDefaultFlagsType3...
     D                 PR            10U 0
     D                                     extproc('getDefaultFlagsType3')
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D                                            options(*varsize: *nopass)
      *
      *  Returns cTrue if the specified message matches a given type.
     D isMessageTypeOf...
     D                 PR              N
     D                                     extproc('isMessageTypeOf')
     D  i_message                          const  like(ntlm_message_t    )
     D                                            options(*varsize)
     D  i_type                             const  like(NtlmMessage_t.type)
      *
      *  Returns the specified target information block of a given
      *  Type-2 message.
     D getTargetInfo...
     D                 PR                         like(ntlm_targetName_t)
     D                                     extproc('getTargetInfo')
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D  i_type                        5I 0 const
      *
      *  Return the NTLM message signature.
     D NTLMSSP_SIGNATURE...
     D                 PR                         like(NtLmMessage_t.signature)
     D                                     extproc('NTLMSSP_SIGNATURE')
      *
      *  Serializes a type 1 message to a byte array.
     D Type1_toByteArray...
     D                 PR                         like(ntlm_message_t )
     D                                     extproc('Type1_toByteArray')
     D  i_type1                                   likeds(type1_t )
      *
      *  Serializes a type 3 message to a byte array.
     D Type3_toByteArray...
     D                 PR                         like(ntlm_message_t )
     D                                     extproc('Type3_toByteArray')
     D  i_type3                                   likeds(type3_t )
      *
      *  Write a security bufer.
     D writeSecurityBuffer...
     D                 PR                         likeds(ntlm_securityBuffer_t)
     D                                     extproc('writeSecurityBuffer')
     D  io_message                                like(ntlm_message_t )
     D                                            options(*varsize)
     D  io_offset                    10I 0
     D  i_data                     2048A   const  varying options(*varsize)
      *
      *  Returns the current time in milliseconds.
     D getCurrentTimeMillis...
     D                 PR            20U 0
     D                                     extproc('getCurrentTimeMillis')
      *
      *  base64_encode:  Encode binary data using Base64 encoding
     D NTLM_Base64_encode...
     D                 PR            10U 0 extproc('NTLM_Base64_encode')
     D   Input                         *   value
     D   InputLen                    10U 0 value
     D   Output                        *   value
     D   OutputSize                  10U 0 value
      *
      *  base64_decode: Decode base64 encoded data back to binary
     D NTLM_Base64_decode...
     D                 PR            10U 0 extproc('NTLM_Base64_decode')
     D   Input                         *   value
     D   InputLen                    10U 0 value
     D   Output                        *   value
     D   OutputSize                  10U 0 value
      *
     D invalidChar     PR                  extproc('invalidChar')
     D   CharPos                     10i 0 value
     D   Char                         3u 0 value
      *
      *  Initializes character translation.
     D Transcoder_new...
     D                 PR                         like(hTranscoder_t )
     D                                     extproc('Transcoder_new')
     D  i_toCcsid                    10U 0 const
     D  i_fromCcsid                  10U 0 const
      *
      *  Translate a given varying string.
     D Transcoder_xlateString...
     D                 PR         32767A   opdesc varying
     D                                     extproc('Transcoder_xlateString')
     D  i_hTranscoder                      const  like(hTranscoder_t )
     D  i_string                  32767A   const  varying options(*varsize)
      *
      *  Frees a given transcoder.
     D Transcoder_delete...
     D                 PR
     D                                     extproc('Transcoder_delete')
     D  io_hTranscoder...
     D                                            like(hTranscoder_t )
      *
      *  Returns a Transcoder NULL-handle.
     D Transcoder_null...
     D                 PR                         like(hTranscoder_t )
     D                                     extproc('Transcoder_null')
      *
      *  Returns cTrue if a given Transcoder handle is NULL.
     D Transcoder_isNull...
     D                 PR              N
     D                                     extproc('Transcoder_isNull')
     D  i_hTranscoder                      const  like(hTranscoder_t )
      *
      *  Performs charcater translation.
     D performTranslation...
     D                 PR            10U 0
     D                                     extproc('performTranslation')
     D  i_hTranscoder                      const  like(hTranscoder_t )
     D  i_pInBuf                       *   value
     D  i_length                     10I 0 const
     D  o_pTo                          *
     D  i_maxSize                    10I 0 const
      *
      *  Sets the C runtime error number to ZERO (no error).
     D c_clearErrno...
     D                 PR
     D                                     extproc('c_clearErrno')
      *
      *  Sets the C runtime error number to a given error code.
     D c_errno...
     D                 PR            10I 0
     D                                     extproc('c_errno')
     D  i_errno                      10I 0 const  options(*nopass)
      *
      *  Returns the message text of a C runtime error number.
     D c_strerror...
     D                 PR           128A          varying
     D                                     extproc('c_strerror')
     D  i_errno                      10I 0 const
      *
      *  Kills utility with an ESCAPE message.
     D kill...
     D                 PR
     D                                     extproc('kill')
     D  i_text                      128A   const  varying
      *
      *  Get String Information (CEEGSI) API
     D CEEGSI...
     D                 PR
     D                                            extproc('CEEGSI')
     D  i_posn                       10I 0 const
     D  o_datatype                   10I 0
     D  o_curlen                     10I 0
     D  o_maxlen                     10I 0
     D  o_fb                         12A          options(*omit   )
      *
      *  Reference fields for CEEGSI API
     D strInf_t        DS                  based(pDummy)   qualified
     D  datatype                     10I 0
     D  curlen                       10I 0
     D  maxlen                       10I 0
      *
      *  erno--Set Pointer to Runtime Error Code
     D errno           PR              *                     extproc('__errno')
      *
      *  strerror -- Set Pointer to Runtime Error Message
     D strerror        PR              *                     extproc('strerror')
     D  errno                        10I 0 value
      *
      *  QtqIconvOpen()--Code Conversion Allocation API
     D QtqIconv_open...
     D                 PR                  extproc('QtqIconvOpen')
     D                                     likeds(iconv_t )
     D  i_toCode                           const  likeds(QtqCode_t)
     D  i_fromCode                         const  likeds(QtqCode_t)
      *
     D iconv_t         DS                  qualified   based(pDummy)   align
     D  return_value                 10I 0
     D  cd                           10I 0 dim(12)
      *
     D QtqCode_t...
     D                 DS                  qualified   based(pDummy)
     D  ccsid                        10I 0
     D  conversionA                  10I 0
     D  substitutionA                10I 0
     D  shiftStateA                  10I 0
     D  inpLenOpt                    10I 0
     D  errOptMxdDta                 10I 0
     D  reserved                     12A
      *
      *  iconv()--Code Conversion API
     D iconv...
     D                 PR            10U 0        extproc('iconv')
     D  i_cd                               value likeds(iconv_t  )
     D  i_pInBuf                       *
     D  i_inBytLeft                  10U 0
     D  i_pOutBuf                      *
     D  i_outBytLeft                 10U 0
      *
     D ICONV_ERROR     C                   const(4294967295)
     D E2BIG_C         C                   const(3491)                          Argument list
      *
      *  iconv_close()--Code Conversion Deallocation API
     D iconv_close...
     D                 PR            10I 0        extproc('iconv_close')
     D  i_cd                               value likeds(iconv_t  )
      *
      *  memcpy -- Copy Bytes
      *     The behavior is undefined if copying takes place
      *     between objects that overlap.
      *     The memcpy() function returns a pointer to dest.
     D memcpy2         PR              *          extproc('memcpy')
     D  i_pDest                        *   value
     D  i_pSrc                         *   value
     D  i_count                      10U 0 value
      *
      *  rand -- Generate Random Number                x = rand()
     D rand            PR            10I 0        extproc('rand')
      *
     D RAND_MAX        C                   const(32767)
      *
      *  srand -- Set Seed for rand Function   e.g.:   srand(getSeed(*null))
     D srand           PR                         extproc('srand')
     D  i_seed                       10U 0 value
      *
      *  time -- Determine Current Time
      *     The time() function returns the current calendar time.
      *     The return value is also stored in the location that
      *     is given by timeptr.
     D time...
     D                 PR            10i 0 extproc('time')
     D  timeptr                        *   value
      *
      *  AND String (ANDSTR)
      *     MI function that Returns the bit-wise ANDing
      *     of the arguments.
     D ANDSTR...
     D                 PR                  extproc('_ANDSTR')
     D  i_pReceiver                    *   value
     D  i_pFirstSrc                    *   value
     D  i_pSecondSrc                   *   value
     D  i_length                     10U 0 value
      *
      *  OR String (ORSTR)
      *     MI function that Returns the bit-wise ORing
      *     of the arguments.
     D ORSTR...
     D                 PR                  extproc('_ORSTR')
     D  i_pReceiver                    *   value
     D  i_pFirstSrc                    *   value
     D  i_pSecondSrc                   *   value
     D  i_length                     10U 0 value
      *
      *  Retrieve Network Attributes (QWCRNETA) API
     D QWCRNETA...
     D                 PR                  extpgm('QWCRNETA')
     D  o_rcvVar                  32767A          options(*varsize)
     D  i_lenRcv                     10I 0 const
     D  i_numAttr                    10I 0 const
     D  i_attrNames                  10A   const  dim(50) options(*varsize)
     D  io_errorCode              32767A          options(*varsize)
      *
     D QWCRNETA_returned...
     D                 DS                  qualified               based(pDummy)
     D  numE                         10I 0
     D  offsAttr                     10I 0
      *  Network attribute information table   CHAR(*)
      *
     D QWCRNETA_attr...
     D                 DS                  qualified               based(pDummy)
     D  name                         10A
     D  type                          1A
     D  status                        1A
     D  length                       10I 0
     D  data_char                   256A
     D  data_bin                     10I 0 overlay(data_char)
      *
     D QWCRNETA_STATUS_OK...
     D                 C                       ' '
     D QWCRNETA_STATUS_LOCKED...
     D                 C                       'L'
      *
     D QWCRNETA_DATA_NONE...
     D                 C                       ' '
     D QWCRNETA_DATA_CHAR...
     D                 C                       'C'
     D QWCRNETA_DATA_BIN...
     D                 C                       'B'
      *
      *  Convert Case (QLGCNVCS, QlgConvertCase) API
     D QlgConvertCase...
     D                 PR                  extproc('QlgConvertCase')
     D  i_reqCtrlBlk              32767A   const  options(*varsize)
     D  i_inData                  32767A   const  options(*varsize)
     D  o_outData                 32767A          options(*varsize)
     D  i_length                     10I 0 const
     D  io_ErrCode                32767A          options(*nopass: *varsize)
      *
     D QLGCNVCS_reqCtrlBlk_t...
     D                 DS                  qualified
     D  type                         10I 0
     D  CCSID                        10I 0
     D  case                         10I 0
     D  reserved                     10A
      *
     D CVTCASE_TYPE_CCSID...
     D                 C                   const(1)
     D CVTCASE_TYPE_TABLE...
     D                 C                   const(2)
     D CVTCASE_TYPE_USER_DEF...
     D                 C                   const(3)
     D CVTCASE_TO_UPPER...
     D                 C                   const(0)
     D CVTCASE_TO_LOWER...
     D                 C                   const(1)
     D CVTCASE_CCSID_Job...
     D                 C                   const(0)
      *
      * ------------------------------------
      *  Global fields
      * ------------------------------------
     D CRLF            C                   CONST(x'0D25')
      *
     D g_preferUnicode...
     D                 S               N   inz(cTrue )
     D g_LMCompatibility...
     D                 S             10I 0 inz(DEFAULT_LM_COMPATIBILITY_MODE)
     D g_hToAscii      S                   like(hTranscoder_t ) inz
     D g_hToUnicode    S                   like(hTranscoder_t ) inz
      *
     D g_saveProc      DS                  qualified
     D  procPtr                        *   procptr inz
     D  fd                           10I 0 inz
      *
     D g_isTestMode    S               N   inz(cFalse)
      *
     D b64_alphabet    DS
     D   alphabet                    64A   inz('-
     D                                     ABCDEFGHIJKLMNOPQRSTUVWXYZ-
     D                                     abcdefghijklmnopqrstuvwxyz-
     D                                     0123456789+/')
     D   base64f                      1A   dim(64)
     D                                     overlay(alphabet)
      *
     D b64_reverse     DS
     D   revalphabet                256A   inz(x'-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFF3eFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FF3fFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FF1a1b1c1d1e1f202122FFFFFFFFFFFF-
     D                                     FF232425262728292a2bFFFFFFFFFFFF-
     D                                     FFFF2c2d2e2f30313233FFFFFFFFFFFF-
     D                                     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF-
     D                                     FF000102030405060708FFFFFFFFFFFF-
     D                                     FF090a0b0c0d0e0f1011FFFFFFFFFFFF-
     D                                     FFFF1213141516171819FFFFFFFFFFFF-
     D                                     3435363738393a3b3c3dFFFFFFFFFFFF-
     D                                     ')
     D   base64r                      3U 0 dim(255)
     D                                     overlay(revalphabet:2)
      *
     D dsAuth          DS                  qualified
     D   isRequired                   1N   inz(cFalse)
     D   type                         1A   inz(HTTP_AUTH_NONE)
     D   rcvErrPage                   1N   inz(cFalse)
     D   ntlmStatus                  10I 0 inz(NTLM_NONE)
     D   ntlmType2Msg              1024A   varying inz
     D   header                    1476A   varying inz
     D   user                              like(ntlm_user_t     ) inz
     D   passwd                            like(ntlm_password_t ) inz
     D   realm                      124A   varying inz
     D   host                       256A   varying inz
      *
      * Fix encryption value (ASCII)
      * See: The LM Response
      *      http://davenport.sourceforge.net/ntlm.html#type3MessageExample
     D ASCII_STRING    C                   x'4B47532140232425'
      *
      * ------------------------------------
      *  Program Status Information DS
      * ------------------------------------
     D sds            SDS                  qualified
     D  job                  244    253A                                        Job Name
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Interprets a given authentication header.
      *  Called by procedure interpret_auth() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  This procedure is called from interpret_auth() for each
      *  "www-authenticate" HTTP header. It resets the negotiate status
      *  when it encounters a 'NTLM' header without a message and it retrieves
      *  the Type-2 message from a given 'Challenge' header.
      * -------------------------------------------------------------------
      *  i_header    = Authentication header that must be interpreted.
      *=====================================================================*
     P AuthPlugin_interpretAuthenticationHeader...
     P                 B                   export
      *
     D AuthPlugin_interpretAuthenticationHeader...
     D                 PI
     D  i_header                   2048A   const
      *
      *  Local fields
     D word            S           2048A   varying inz
      *
     D TAB             C                   x'05'
     D LF              C                   x'25'
     D CR              C                   x'0D'
     D NULL            C                   x'00'
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         word = toLower(getToken(i_header: ' =,'+TAB+CR+LF+NULL));

         dow (word <> '');

            select;
            when (word = 'ntlm');
               dsAuth.rcvErrPage = cTrue;
               dsAuth.realm = dsAuth.host;
               word = getToken(*omit: ' '+TAB+CR+LF+NULL);
               if (word <> '');
                  dsAuth.ntlmType2Msg = word;
               else;
                  dsAuth.ntlmType2Msg = '';
                  // An empty 'NTLM' header indicates that the
                  // server requires NTLM authentication and
                  // that we need to start the authentication
                  // process.
                  dsAuth.ntlmStatus = NTLM_NONE;
                  dsAuth.isRequired = cTrue;
               endif;

            when (word = 'realm');
               word = getToken(*omit: '"');
               if (word <> '');
                  dsAuth.realm = word;
               endif;

            endsl;

            word = toLower(getToken(*omit: ' =,'+TAB+CR+LF+NULL));
         enddo;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Returns *ON if, HTTPAPI should receive the the 401 error page and
      *  returns the procedure that is called to receive the error page.
      *  Called by procedure do_oper() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  In contrast to BASIC and DIGEST authentication the 401 error page
      *  must be received by HTTPAPI, because NTLM uses a persistent
      *  HTTP connection when negotiating the NTLM parameters with the
      *  server. If the 401 error page is not received, it stays on the
      *  wire and eventually is received, when HTTPAPI attempts to get the
      *  actual data from the server. For BASIC and DIGEST authentication
      *  the connection is closed after having received a 401 error code
      *  and hence the 401 error page is being dropped automatically.
      * -------------------------------------------------------------------
      *  io_saveProc = Procedure pointer of the procedure that is called
      *                to receive the error page.
      *  io_saveFD   = File descriptor that is passed to io_saveProc.
      *=====================================================================*
     P AuthPlugin_mustReceiceAuthErrorPage...
     P                 B                   export
     D                 PI              N
     D  io_saveProc                    *          procptr
     D  io_saveFD                    10I 0
      *
      *  Return value
     D ignoreError     S               N   inz(*OFF)
      *
      *  Local fields
     D errorNo         S             10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         http_dmsg('AuthPlugin_mustReceiceAuthErrorPage(): entered');

         // Ignore 401 error for NTLM authentication, if
         // we did not yet sent the type-3 message because we
         // need to receive the 401 error page. Otherwise we will
         // get it with the actual response when sending the type-3
         // message.
         ignoreError = *OFF;

         if (dsAuth.rcvErrPage);
            http_error(errorNo);
            if (errorNo = HTTP_NDAUTH and
               dsAuth.ntlmStatus = NTLM_AUTHENTICATE);
               // keep error status for NTLM authentication
               // and type-3 message
            else;
               // for type-1 and type-2 messages ignore the
               // 401 error and receive the html error page
               ignoreError = *ON;
               g_saveProc.procPtr = io_saveProc;
               g_saveProc.fd = io_saveFD;
               io_saveProc = %paddr('nullWrite');
               io_saveFD = 0;
            endif;
         endif;

         return ignoreError;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Negotiates the NTLM authentication parameters with the server and
      *  produces the NTLM authentication header value (type-3) message.
      *  Called by procedure http_persist_req() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  First the Type-1 message is produced and sent to the server. Then
      *  the procedure receices the Type-2 messages and produces the
      *  Type-3 messages which is used later on to complete the
      *  authentication process.
      * -------------------------------------------------------------------
      *  i_comm      = Pointer to persistent HTTP comm session.
      *  i_URL       = URL to GET from or POST with persistent HTTP comm.
      *  i_timeout   = Timeout is seconds when no data is received.
      *=====================================================================*
     P AuthPlugin_negotiateAuthentication...
     P                 B                   export
     D                 PI            10I 0
     D  i_comm                         *   const
     D  i_URL                     32767A   const  varying options(*varsize)
     D  i_timeout                    10I 0 const
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D authUser        S                   like(dsAuth.user    ) inz
     D authDomain      S                   like(dsAuth.passwd  ) inz
     D pos             S             10I 0 inz
     D URL             S                   like(i_URL          ) inz
      *
     D type1Msg        S                   like(ntlm_message_t ) inz
     D type2Msg        S                   like(ntlm_message_t ) inz
     D type3Msg        S                   like(ntlm_message_t ) inz
      *
     D errorNo         S             10I 0 inz
     D negotiating     S               N   inz(cFalse) static
      *
     D service         S             32A   varying inz
     D host            S            256A   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parseUrl(i_URL: service: host);
         dsAuth.host = host;

         if (dsAuth.ntlmStatus <> NTLM_NEGOTIATE);
            return 0;
         endif;

         if (negotiating);
            return 0;
         endif;

         http_dmsg('NTLM_negotiateAuthentication(): entered');

         negotiating = cTrue;

         // *********************************************************
         //   Splitt user into user & passowrd
         // *********************************************************
         //   scan for a backslash:
         //   possible domain/name formats are:
         //      Format              Type 3 Field Content
         //      DOMAIN\user         User Name = "user",
         //                          Domain    = "DOMAIN"
         //      domain.com\user     User Name = "user"
         //                          Domain    = "domain.com"
         //      user@DOMAIN         User Name = "user@DOMAIN"
         //                          Domain is empty
         //      user@domain.com     User Name = "user@domain.com"
         //                          Domain is empty
         // *********************************************************

         // pos = %scan(%char(u'005C'): i_user);
         pos = %scan(%char(u'005C'): dsAuth.user);
         if (pos = 0);
            authDomain = '';
            // authUser = i_user;
            authUser = dsAuth.user;
         else;
            // authDomain = %subst(i_user: 1: pos-1);
            // authUser = %subst(i_user: pos+1);
            authDomain = %subst(dsAuth.user: 1: pos-1);
            authUser = %subst(dsAuth.user: pos+1);
         endif;

         // *********************************************************
         //   Produce Type-1 message and send it to the server
         // *********************************************************

         dou ('1');

            type1Msg = Message_newType1();

            dsAuth.header = Message_encodeBase64(type1Msg);

            URL = removeAuthFromUrl(i_URL);
            rc = http_persist_get(
                       i_comm: URL: 0: %paddr('nullWrite'): i_timeout);

            if (rc = -1);
               http_error(errorNo);
               if (errorNo <> HTTP_NDAUTH);
                  dsAuth.ntlmStatus = NTLM_NONE;
                  SetError(HTTP_NDAUTH: ' failed sending type-1 message');
                  rc = -1;
                  leave;
               endif;
            endif;

            // *********************************************************
            //   Validate the Type-2 message.
            // *********************************************************

            type2Msg = Message_decodeBase64(dsAuth.ntlmType2Msg);

            if (not Message_isType2(type2Msg));
               dsAuth.ntlmStatus = NTLM_NONE;
               SetError(HTTP_NDAUTH: ' failed validating type-2 message');
               rc = -1;
               leave;
            endif;

            if (not Message_validateType2(type1Msg: type2Msg));
               http_dmsg('NTLM_negotiateAuthentication(): +
                          Invalid Type-2 message');
               dsAuth.ntlmStatus = NTLM_NONE;
               SetError(HTTP_NDAUTH: ' failed validating type-2 message');
               rc = -1;
               leave;
            endif;

            // *********************************************************
            //   Produce Type-3 message
            // *********************************************************

            type3Msg = Message_newType3(type2Msg
                                        : %trim(authUser)
                                        : %trim(dsAuth.passwd)
                                        : %trim(authDomain));

            dsAuth.header = Message_encodeBase64(type3Msg);
            dsAuth.ntlmStatus = NTLM_AUTHENTICATE;

            rc = 0;
         enddo;

         negotiating = cFalse;

         return rc;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Produces the NTLM authentication header when negotiating
      *  the NTLM authentication parameters with the server.
      *  Called by procedure do_oper() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  Depending on the status of the authentication process either
      *  a Type-1 or a Type-3 authentication header is being produced
      *  and added to the HTTP request chain.
      * -------------------------------------------------------------------
      *  io_reqChain = HTTP request chain that is send to the server.
      *=====================================================================*
     P AuthPlugin_produceAuthenticationHeader...
     P                 B                   export
     D                 PI
     D  io_reqChain               32767A   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (dsAuth.ntlmStatus <> NTLM_NEGOTIATE and
             dsAuth.ntlmStatus <> NTLM_AUTHENTICATE);
            return;
         endif;

         http_dmsg('AuthPlugin_produceAuthenticationHeader(): entered');

         // Add NTLM authentication header for type-1
         // and type-3 messages.
         io_reqChain = io_reqChain +
                       'Authorization: NTLM ' +
                        dsAuth.header + CRLF;
         if (dsAuth.ntlmStatus = NTLM_NEGOTIATE);
            dsAuth.ntlmStatus = NTLM_AUTHENTICATE;
         else;
            // Finish the NTLM authentication process
            dsAuth.ntlmStatus = NTLM_NONE;
         endif;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Returns cTrue if the server requires authentication.
      *  Called by procedure http_getauth() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  no parameters
      *=====================================================================*
     P AuthPlugin_isAuthenticationRequired...
     P                 B                   export
     D                 PI              N
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return dsAuth.isRequired;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Returns the realm of the server.
      *  Called by procedure http_getauth() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  no parameters
      *=====================================================================*
     P AuthPlugin_getRealm...
     P                 B                   export
     D                 PI           124A   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return dsAuth.realm;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Sets the NTLM authentication credentials
      *  Called by procedure http_setAuth() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  i_authType  = Authentication type used to specify login credentials.
      *  i_username  = User name to use.
      *  i_passwd    = Password to use.
      *=====================================================================*
     P AuthPlugin_setAuthentication...
     P                 B                   export
     D                 PI              N
     D  i_authType                    1A   const
     D  i_username                   80A   const
     D  i_passwd                   1024A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_authType <> HTTP_AUTH_NTLM);
            resetAuthentication(cTrue);
            return cFalse;
         endif;

         http_dmsg('NTLM_setCredentials(): entered');

         dsAuth.ntlmStatus = NTLM_NEGOTIATE;
         dsAuth.header = '';
         dsAuth.user = i_username;
         dsAuth.passwd = i_passwd;

         return cTrue;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Official API procedure ***
      *  Resets authentication parameters.
      *  Called by procedure interpret_auth() of module HTTPAPIR4.
      * -------------------------------------------------------------------
      *  no parameters
      *=====================================================================*
     P AuthPlugin_resetAuthentication...
     P                 B                   export
     D                 PI
      *
      * Parameter positions
     D p_resetAll      C                   1
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         resetAuthentication(cFalse);

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Resets authentication parameters.
      *=====================================================================*
     P resetAuthentication...
     P                 B
     D                 PI
     D  i_resetAll                     N   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dsAuth.isRequired = cFalse;
         dsAuth.rcvErrPage = cFalse;
         dsAuth.ntlmStatus = NTLM_NONE;
         dsAuth.ntlmType2Msg = '';
         dsAuth.header = '';

         if (i_resetAll);
            dsAuth.user = '';
            dsAuth.passwd = '';
            dsAuth.realm = '';
            dsAuth.host = '';
         endif;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Removes user and password from a given URL.
      *=====================================================================*
     P removeAuthFromUrl...
     P                 B                   export
     D                 PI         32767A          varying
     D   i_URL                    32767A   const  varying options(*varsize)
      *
      *  Return value
     D URL             S                   like(i_URL) inz
      *
      *  Local fields
     D service         S             32A
     D user            S             32A
     D passwd          S             32A
     D host            S            256A
     D port            S             10I 0
     D path            S          32767A   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         http_long_ParseURL(i_URL: service: user: passwd: host: port: path);
         URL = %trim(service) + '://' +
               %trim(host);

         if (port <> 0);
            URL = URL + ':' + %char(port);
         endif;

         URL = URL + path;

         return URL;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Enables Test Mode for RPGUnit Test Cases
      *=====================================================================*
     P NTLM_enableTestMode...
     P                 B                   export
     D                 PI
     D  i_mode                         N   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         g_isTestMode = i_mode;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Sets the LM compatibility mode.
      *    0 -- Sends NTLMv1 response. That may also include the weak
      *         LM response.
      *    1 -- Sends only the NTLM response. This is more secure than
      *         Levels 0, because it eliminates the cryptographically-weak
      *         LM response.
      *    2 -- Sends only the NTLM2 response.
      *    3 -- Sends LMv2 and NTLMv2 data.
      *         Session security is not yet supported.
      *         This is the default mode.
      *=====================================================================*
      *  Corresponds to JCIFS property:   jcifs.smb.lmCompatibility
      *=====================================================================*
     P NTLM_setLMCompatibility...
     P                 B                   export
     D                 PI
     D  i_mode                       10I 0 const  options(*nopass)
      *
      *  Parameter positions
     D p_mode          C                   1
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_mode);
            if (i_mode >= 0 and i_mode <= 3);
               g_LMCompatibility = i_mode;
            else;
               g_LMCompatibility = DEFAULT_LM_COMPATIBILITY_MODE;
            endif;
         else;
            g_LMCompatibility = DEFAULT_LM_COMPATIBILITY_MODE;
         endif;

         return;
      /end-free
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Produces a Type-1 message:   NtLmNegotiate
      * -------------------------------------------------------------------
      *  i_flags          Message flags. 0=use default flags.
      *  i_workstation    Workstation name of the client.
      *  i_domain         Name of the domain in which the workstation has
      *                   membership.
      *=====================================================================*
      *  Corresponds to JCIFS class:   Type1Message
      *=====================================================================*
     P Message_newType1...
     P                 B                   export
     D                 PI                         like(ntlm_message_t )
     D  i_flags                      10U 0 const  options(*nopass: *omit)
     D  i_workstation                      const  like(ntlm_workstation_t )
     D                                            options(*varsize:
     D                                                    *nopass: *omit)
     D  i_domain                           const  like(ntlm_domain_t  )
     D                                            options(*varsize:
     D                                                    *nopass: *omit)
      *
      *  Return value
     D message         S                   like(ntlm_message_t ) inz
      *
      *  Parameter positions
     D p_flags         C                   1
     D p_workstation   C                   2
     D p_domain        C                   3
      *
      *  Fields for optional parameters
     D workstation     S                   like(i_workstation ) inz
     D domain          S                   like(i_domain      ) inz
      *
      *  Local fields
     D offs            S             10I 0 inz
      *
     D tmpMessage      S           2048A   inz
      *
     D type1           DS                  likeds(type1_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear type1;

         if (%parms() >= p_flags and %addr(i_flags) <> *NULL);
            type1.flags = %bitor(i_flags: getDefaultFlagsType1());
         else;
            type1.flags = getDefaultFlagsType1();
         endif;

         if (%parms() >= p_domain and %addr(i_domain) <> *NULL);
            type1.domain = i_domain;
         else;
            type1.domain = '';
         endif;

         if (%parms() >= p_workstation and %addr(i_workstation) <> *NULL);
            type1.workstation = i_workstation;
         else;
            type1.workstation = getDefaultWorkstation();
         endif;

         if (type1.domain <> '');
            type1.flags =
               %bitor(type1.flags: NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED);
         endif;

         if (type1.workstation <> '');
            type1.flags =
               %bitor(type1.flags: NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED);
         endif;

         message = Type1_toByteArray(type1);

         return message;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used ***
      *  Validates a Type-2 message.
      * -------------------------------------------------------------------
      *  i_type1Msg       Type-1 message that was sent to the server.
      *  i_type2Msg       Type-2 message responded by the server.
      *=====================================================================*
     P Message_validateType2...
     P                 B
     D                 PI              N
     D  i_type1Msg                                like(ntlm_message_t )
     D                                            options(*varsize)
     D  i_type2Msg                                like(ntlm_message_t )
     D                                            options(*varsize)
     D  o_rc                         10I 0        options(*nopass)
      *
      *  Fields for optional parameters
     D rc              S                   like(o_rc ) inz(0)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Local fields
     D NtlmNegotiate   DS                  likeds(NtLmNegotiate_t)
     D                                     based(pNtlmNegotiate)
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D type1Flags      S             10U 0 inz
     D type2Flags      S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pNtlmNegotiate = %addr(i_type1Msg)+2;
         pNtLmChallenge = %addr(i_type2Msg)+2;

         dou '1';

            // Validate types
            if (not Message_isType1(i_type1Msg));
               rc = NTLM_EINV_TYPE1_MSG;
               leave;
            endif;

            if (not Message_isType2(i_type2Msg));
               rc = NTLM_EINV_TYPE2_MSG;
               leave;
            endif;

            type1Flags = uint32LE(NtlmNegotiate.flags);
            type2Flags = uint32LE(NtLmChallenge.flags);

            // Validate encoding
            // The encoding must either be set to NTLMSSP_NEGOTIATE_UNICODE or
            // NTLMSSP_NEGOTIATE_OEM.
            if (not (isBit(type2Flags: NTLMSSP_NEGOTIATE_UNICODE) or
                     isBit(type2Flags: NTLMSSP_NEGOTIATE_OEM)));
               rc = NTLM_EINV_ENCODING;
               leave;
            endif;

            // Validate encoding
            // Either NTLMSSP_NEGOTIATE_UNICODE or NTLMSSP_NEGOTIATE_OEM must
            // be set but not both.
            if (isBit(type2Flags: NTLMSSP_NEGOTIATE_UNICODE) and
                isBit(type2Flags: NTLMSSP_NEGOTIATE_OEM));
               rc = NTLM_EINV_ENCODING;
               leave;
            endif;

            // Validate encoding
            // Encoding of Type-1 message must match the encoding of the
            // Type-2 message.
            if (isBit(type2Flags:NTLMSSP_NEGOTIATE_UNICODE) and
                not isBit(type1Flags:NTLMSSP_NEGOTIATE_UNICODE));
               rc = NTLM_ENSUP_ENCODING;
               leave;
            endif;

            if (isBit(type2Flags:NTLMSSP_NEGOTIATE_OEM) and
                not isBit(type1Flags:NTLMSSP_NEGOTIATE_OEM));
               rc = NTLM_ENSUP_ENCODING;
               leave;
            endif;

         enddo;

         if (%parms() >= p_rc and %addr(o_rc) <> *NULL);
            o_rc = rc;
         endif;

         if (rc = 0);
            return cTrue;
         endif;

         return cFalse;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Produces a Type-3 message:   NtLmAuthenticate
      * -------------------------------------------------------------------
      *  i_type2Msg       Type-2 message responded by the server.
      *  i_user           The username for the authenticating user.
      *  i_password       The password to use when constructing the response.
      *  i_domain         The domain in which the user has an account.
      *=====================================================================*
      *  Corresponds to JCIFS class:   Type3Message
      *=====================================================================*
     P Message_newType3...
     P                 B                   export
     D                 PI                         like(ntlm_message_t )
     D  i_type2Msg                                like(ntlm_message_t )
     D                                            options(*varsize)
     D  i_user                             const  like(ntlm_user_t     )
     D                                            options(*varsize)
     D  i_password                         const  like(ntlm_password_t )
     D                                            options(*varsize)
     D  i_domain                           const  like(ntlm_domain_t   )
     D                                            options(*varsize
     D                                                    : *omit: *nopass)
      *
      *  Return value
     D message         S                   like(ntlm_message_t ) inz
      *
      *  Parameter positions
     D p_domain        C                   4
      *
      *  Optional parameter fields
      *
      *  Local fields
     D tmpMessage      S           2048A   inz
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t )
     D                                     based(pNtLmChallenge)
      *
     D responseKeyNT   S                   like(MD5_digest_t      ) inz
     D clientChallenge...
     D                 S                   like(ntlm_challenge_t  ) inz
      *
     D userSessionKey  S                   like(MD5_digest_t      ) inz
     D masterKey       S             16A   inz
     D exchangedKey    S             16A   inz
     D nt              S                   like(ntlm_ntResponse_t ) inz
      *
     D type3           DS                  likeds(type3_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pNtLmChallenge = %addr(i_type2Msg)+2;

         clear type3;

         type3.flags = %bitor(0: getDefaultFlagsType3(NtLmChallenge));

         if (%parms() >= p_domain and %addr(i_domain) <> *NULL);
            type3.domain = i_domain;
         else;
            type3.domain = '';
         endif;

         type3.user = i_user;
         type3.workstation = getDefaultWorkstation();

         select;
         // 0 -- Sends NTLMv1 response
         // 1 -- Sends only the NTLM response.
         //      This is more secure than Levels 0, because it
         //      eliminates the cryptographically-weak LM response.
         // 2 -- Sends only the NTLM2 response.
         when (g_LMCompatibility = LM_MODE_NTLM_V1 or
               g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM or
               g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY);

            if (g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY or
                isBit(type3.flags: NTLMSSP_NEGOTIATE_NTLM2));
               random(clientChallenge);
               type3.ntResponse =
                  getNTLM2Response(
                     i_password: NtlmChallenge.challenge: clientChallenge);
               type3.lmResponse = clientChallenge + z(16);
            else;
               type3.ntResponse =
                  getNTResponse(NtlmChallenge: i_password);
               if (g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM or
                   isBit(type3.flags: NTLMSSP_NEGOTIATE_NT_ONLY));
                  type3.lmResponse = type3.ntResponse;
               else;
                  type3.lmResponse =
                     getLMResponse(NtlmChallenge: i_password);
               endif;
            endif;

            if (isBit(type3.flags: NTLMSSP_NEGOTIATE_SIGN));
               kill('Unsupported Flag: NTLMSSP_NEGOTIATE_SIGN');
            endif;

         // 3 -- Sends LMv2 and NTLMv2 data.
         //      NTLMv2 session security is also negotiated if the server supports it.
         //      This is the default behavior (in 1.3.0 or later).
         when (g_LMCompatibility = LM_MODE_NTLM_V2);
            responseKeyNT = NTOWFv2(i_password: i_user: type3.domain);

            random(clientChallenge: g_isTestMode);
            type3.lmResponse =
               getLMv2Response(
                  NtLmChallenge: type3.domain
                  : i_user: i_password: clientChallenge);

            random(clientChallenge: g_isTestMode);
            type3.ntResponse =
               getNTLMv2Response(
                  NtLmChallenge: responseKeyNT: clientChallenge);

            if (isBit(type3.flags: NTLMSSP_NEGOTIATE_SIGN));
               kill('Unsupported Flag: NTLMSSP_NEGOTIATE_SIGN');

               // only first 16 bytes of ntResponse
               userSessionKey =
                  MD5Hmac(responseKeyNT: %subst(type3.ntResponse: 1:16));

               if (isBit(type3.flags: NTLMSSP_NEGOTIATE_KEY_EXCH));
                  random(masterKey: g_isTestMode);
                  exchangedKey = RC4(userSessionKey: masterKey);
                  type3.sessionKey = exchangedKey;
               else;
                  masterKey = userSessionKey;
                  type3.sessionKey = masterKey;
               endif;

            endif;

         other;
            type3.lmResponse =
               getLMResponse(NtlmChallenge: i_password);
            type3.ntResponse =
               getNTResponse(NtlmChallenge: i_password);
         endsl;

         message = Type3_toByteArray(type3);

         return message;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns cTrue if the specified message is a Type 1 message.
      *---------------------------------------------------------------------*
      *  i_message        Message, that is tested for a Type-1 message.
      *=====================================================================*
     P Message_isType1...
     P                 B                   export
     D                 PI              N
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return isMessageTypeOf(i_message: NEGOTIATE_MESSAGE);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used ***
      *  Returns cTrue if the specified message is a Type 2 message.
      *---------------------------------------------------------------------*
      *  i_message        Message, that is tested for a Type-2 message.
      *=====================================================================*
     P Message_isType2...
     P                 B
     D                 PI              N
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return isMessageTypeOf(i_message: CHALLENGE_MESSAGE);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used ***
      *  Returns cTrue if the specified message is a Type 3 message.
      *---------------------------------------------------------------------*
      *  i_message        Message, that is tested for a Type-3 message.
      *=====================================================================*
     P Message_isType3...
     P                 B
     D                 PI              N
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return isMessageTypeOf(i_message: AUTHENTICATE_MESSAGE);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns the challenge for a given Type-2 message.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, whose challenge is returned.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type2Message.getChallenge
      *=====================================================================*
     P Message_getChallenge...
     P                 B                   export
     D                 PI                         like(ntlm_challenge_t)
     D  i_type2Msg                                like(ntlm_message_t  )
     D                                            options(*varsize)
      *
      *  Return value
     D challenge       S                   like(ntlm_challenge_t ) inz
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;
         challenge = NtLmChallenge.challenge;

         return challenge;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns cTrue if the specified flag is set in a given message.
      *---------------------------------------------------------------------*
      *  i_message        Message, that is tested for a given flag.
      *  i_flag           Flag, the message is tested for.
      *=====================================================================*
     P Message_hasFlag...
     P                 B                   export
     D                 PI              N
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
     D  i_flag                       10U 0 const
      *
      *  Return value
     D hasFlag         S               N   inz(cFalse)
      *
      *  Local fields
     D flags           S                   like(NtLmNegotiate_t.flags) inz
     D NtlmNegotiate   DS                  likeds(NtLmNegotiate_t    ) inz
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t    ) inz
     D NtlmAuthenticate...
     D                 DS                  likeds(NtLmAuthenticate_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         select;
         when (Message_isType1(i_message));
            NtlmNegotiate = %subst(i_message: 1: %len(i_message));
            flags = uint32LE(NtlmNegotiate.flags);
         when (Message_isType2(i_message));
            NtLmChallenge = %subst(i_message: 1: %len(i_message));
            flags = uint32LE(NtlmChallenge.flags);
         when (Message_isType3(i_message));
            NtlmAuthenticate = %subst(i_message: 1: %len(i_message));
            flags = uint32LE(NtlmAuthenticate.flags);
         other;
            kill('The specified message is not a known message.');
         endsl;

         hasFlag = isBit(flags: i_flag);

         return hasFlag;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests, only ***
      *  Returns the server's NetBIOS computer name.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, the NetBIOS computer name is
      *                   retrieved from.
      *=====================================================================*
     P Message_getTargetNBComputerName...
     P                 B                   export
     D                 PI                         like(ntlm_targetName_t)
     D  i_type2Msg                                like(ntlm_message_t   )
     D                                            options(*varsize)
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D length          S              5I 0 inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;

         return getTargetInfo(NtLmChallenge
                              : NTLM_TARGET_TYPE_NB_COMPUTER_NAME);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests, only ***
      *  Returns the server's NetBIOS domain name.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, the NetBIOS domain name is
      *                   retrieved from.
      *=====================================================================*
     P Message_getTargetNBDomainName...
     P                 B                   export
     D                 PI                         like(ntlm_targetName_t)
     D  i_type2Msg                                like(ntlm_message_t   )
     D                                            options(*varsize)
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D length          S              5I 0 inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;

         return getTargetInfo(NtLmChallenge
                              : NTLM_TARGET_TYPE_NB_DOMAIN_NAME);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests, only ***
      *  Returns the server's Active Directory DNS computer name.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, the Active Directory DNS computer name
      *                   retrieved from.
      *=====================================================================*
     P Message_getTargetDNSComputerName...
     P                 B                   export
     D                 PI                         like(ntlm_targetName_t)
     D  i_type2Msg                                like(ntlm_message_t   )
     D                                            options(*varsize)
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D length          S              5I 0 inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;

         return getTargetInfo(NtLmChallenge
                              : NTLM_TARGET_TYPE_DNS_COMPUTER_NAME);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests, only ***
      *  Returns the server's Active Directory DNS domain name.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, the Active Directory DNS domain name
      *                   retrieved from.
      *=====================================================================*
     P Message_getTargetDNSDomainName...
     P                 B                   export
     D                 PI                         like(ntlm_targetName_t)
     D  i_type2Msg                                like(ntlm_message_t   )
     D                                            options(*varsize)
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D length          S              5I 0 inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;

         return getTargetInfo(NtLmChallenge
                              : NTLM_TARGET_TYPE_DNS_DOMAIN_NAME);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Not yet in use ***
      *  Returns server's Active Directory (AD) DNS forest tree name.
      *---------------------------------------------------------------------*
      *  i_type2Msg       Message, the Active Directory DNS forest tree name
      *                   retrieved from.
      *=====================================================================*
     P Message_getTargetDNSTreeName...
     P                 B
     D                 PI                         like(ntlm_targetName_t)
     D  i_type2Msg                                like(ntlm_message_t   )
     D                                            options(*varsize)
      *
      *  Local fields
     D NtLmChallenge   DS                  likeds(NtLmChallenge_t)
     D                                     based(pNtLmChallenge)
      *
     D length          S              5I 0 inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Message_isType2(i_type2Msg));
            kill('The specified message is not a Type-2 message');
         endif;

         pNtLmChallenge = %addr(i_type2Msg)+2;

         return getTargetInfo(NtLmChallenge
                              : NTLM_TARGET_TYPE_DNS_TREE_NAME);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Encodes a given message to Base64.
      *---------------------------------------------------------------------*
      *  i_message        Message material that is encoded to Base64.
      *=====================================================================*
     P Message_encodeBase64...
     P                 B                   export
     D                 PI                         like(ntlm_message_t )
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
      *
      *  Return value
     D rtn             DS                  qualified
     D  base64                             like(ntlm_message_t ) inz
     D  size                   1      2I 0
     D  data                   3   2050A
      *
      *  Local fields
     D tmpMessage      S           2048A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_message) = 0);
            return '';
         endif;

         tmpMessage = %subst(i_message: 1: %len(i_message));

         rtn.size = NTLM_Base64_encode(%addr(tmpMessage): %len(i_message)
                                       : %addr(rtn.data): %size(rtn.data));
         return rtn.base64;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Decodes a given message from Base64.
      *---------------------------------------------------------------------*
      *  i_message        Base64 encoded message that is decoded to
      *                   its binary form.
      *=====================================================================*
     P Message_decodeBase64...
     P                 B                   export
     D                 PI                         like(ntlm_message_t )
     D  i_message                          const  like(ntlm_message_t )
     D                                            options(*varsize)
      *
      *  Return value
     D rtn             DS                  qualified
     D  message                            like(ntlm_message_t ) inz
     D  size                   1      2I 0
     D  data                   3   2050A
      *
      *  Local fields
     D tmpMessage      S           2048A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_message) = 0);
            return '';
         endif;

         tmpMessage = %subst(i_message: 1: %len(i_message));

         rtn.size = NTLM_Base64_decode(%addr(tmpMessage): %len(i_message)
                                       : %addr(rtn.data): %size(rtn.data));
         return rtn.message;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Constructs the 'LMChallengeResponse' as  described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
      *=====================================================================*
     P getLMResponse...
     P                 B                   export
     D                 PI                         like(ntlm_lmResponse_t)
     D  i_NtLmChallenge...
     D                                     const  likeds(NtLmChallenge_t)
     D  i_password                         const  like(ntlm_password_t  )
      *
      *  Return value
     D LMResponse      S                   like(ntlm_lmResponse_t ) inz
      *
      *  Local fields
     D responseKeyLM   S             16A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         responseKeyLM = LMOWFv1(i_password);

         LMResponse = desl(responseKeyLM: i_NtLmChallenge.challenge);

         return LMResponse;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Constructs the 'NTChallengeResponse' as  described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
      *=====================================================================*
     P getNTResponse...
     P                 B                   export
     D                 PI                         like(ntlm_ntResponse_t)
     D  i_NtLmChallenge...
     D                                     const  likeds(NtLmChallenge_t)
     D  i_password                         const  like(ntlm_password_t  )
      *
      *  Return value
     D NTResponse      S                   like(ntlm_ntResponse_t ) inz
      *
      *  Local fields
     D responseKeyNT   S                   like(MD4_digest_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         responseKeyNT = NTOWFv1(i_password);

         NTResponse = desl(responseKeyNT: i_NtLmChallenge.challenge);

         return NTResponse;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Constructs the 'NTChallengeResponse' as  described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
      *  This procedure is called when the 'NTLMSSP_NEGOTIATE_NTLM2' flag
      *  is set.
      *=====================================================================*
     P getNTLM2Response...
     P                 B                   export
     D                 PI                         like(ntlm_ntResponse_t)
     D  i_password                         const  like(ntlm_password_t  )
     D                                            options(*varsize)
     D  i_serverChallenge...
     D                                     const  like(ntlm_challenge_t )
     D  i_clientChallenge...
     D                                     const  like(ntlm_challenge_t )
      *
      *  Return value
     D NTLM2Response   S                   like(ntlm_ntResponse_t ) inz
      *
      *  Local fields
     D responseKeyNT   S                   like(MD4_digest_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         responseKeyNT = NTOWFv1(i_password);

         NTLM2Response = desl(responseKeyNT
                            : MD5Digest(i_serverChallenge + i_clientChallenge));

         return NTLM2Response;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Constructs the LMv2 response to the given Type-2 message
      *  using the supplied information.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.getLMv2Response
      *=====================================================================*
     P getLMv2Response...
     P                 B                   export
     D                 PI                         like(ntlm_lmResponse_t)
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D  i_domain                           const  like(ntlm_domain_t    )
     D  i_user                             const  like(ntlm_user_t      )
     D  i_password                         const  like(ntlm_password_t  )
     D  i_clientChallenge...
     D                                     const  like(ntlm_challenge_t )
      *
      *  Return value
     D LMResponse      DS                  qualified
     D  value                              like(ntlm_lmResponse_t) inz
     D  hmac                               like(MD5_digest_t     )
     D                                     overlay(value)
     D  clientChallenge...
     D                                     like(ntlm_challenge_t )
     D                                     overlay(value: *next)
      *
      *  Local fields
     D password        S                   like(i_password    ) inz
     D user            S                   like(i_user        ) inz
     D domain          S                   like(i_domain      ) inz
     D md4_digest      S                   like(MD4_digest_t  ) inz
     D hmac            S                   like(MD5_digest_t  ) inz
     D type2Msg        S                   like(ntlm_message_t)
     D                                     based(pType2Msg)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         password = varstringLE(toUnicode(i_password));
         user = varstringLE(toUnicode(toUpper(i_user)));
         domain = varstringLE(toUnicode(toUpper(i_domain)));

         md4_digest = md4(password);
         hmac = MD5Hmac(md4_digest: user + domain);

         hmac = MD5Hmac(hmac: i_NtLmChallenge.challenge + i_clientChallenge);

         LMResponse.hmac = hmac;
         LMResponse.clientChallenge = i_clientChallenge;

         return LMResponse;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Constructs the NTLMv2 response to the given Type-2 message
      *  using the supplied information.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.getNTLMv2Response
      *=====================================================================*
     P getNTLMv2Response...
     P                 B                   export
     D                 PI                         like(ntlm_ntlmResponse_t)
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D  i_respKeyNT                        const  like(MD5_digest_t     )
     D  i_clientChallenge...
     D                                     const  like(ntlm_challenge_t )
      *
      *  Return value
     D NTLMResponse    S                   like(ntlm_ntlmResponse_t) inz
      *
      *  Local fields
     D timestamp       S             20U 0 inz
     D timeInMillis    S             20U 0 inz
     D length          S              5I 0 inz
     D offset          S             10I 0 inz
     D pNtLmChallenge  S               *   inz
      *
     D targetInfo      S           2048A   based(pTargetInfo)
     D serverChallenge...
     D                 S                   like(ntlm_challenge_t ) inz
      *
     D tempLength      S             10I 0 inz
      *
      *  NTLMv2_CLIENT_CHALLENGE:
     D tempBuffer      S           2048A   based(pTemp)
     D temp            DS                  qualified based(pTemp)
     D  respType                      1A
     D  hiRespType                    1A
     D  reserved_1                    2A
     D  reserved_2                    4A
     D  timestamp                    20U 0
     D  clientChallenge...
     D                                8A
     D  reserved_3                    4A
      *
     D temp_targetInfo...
     D                 S           2020A   based(pTemp_TargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (g_isTestMode);
            timeInMillis = 1334670690000;
         else;
            timeInMillis = getCurrentTimeMillis(); // time in nano seconds
         endif;

         timestamp = (timeInMillis + MILLISECONFS_BETWEEN_1970_AND_1601) *10000;

         // Get length and offset of target name
         length = uint16LE(i_NtLmChallenge.targetInfo.length);
         offset = uint32LE(i_NtLmChallenge.targetInfo.offset);

         // Go to the first target information block
         pNtLmChallenge = %addr(i_NtLmChallenge);
         pTargetInfo = pNtLmChallenge + offset;

         tempLength = %size(temp) + length + 4;
         pTemp = %alloc(tempLength);

         temp = *ALLx'00';
         temp.respType = x'01';
         temp.hiRespType = x'01';
         temp.reserved_1 = *ALLx'00';
         temp.reserved_2 = *ALLx'00';
         temp.timestamp = uint64LE(timestamp);
         temp.clientChallenge = i_clientChallenge;
         temp.reserved_3 = *ALLx'00';

         pTemp_TargetInfo = %addr(temp) + %size(temp);
         %subst(temp_targetInfo: 1: length) = %subst(targetInfo: 1: length);

         serverChallenge = i_NtLmChallenge.challenge;
         NTLMResponse =
            computeResponse(
               i_respKeyNT: serverChallenge: tempBuffer: tempLength);

         dealloc(N) pTemp;

         return NTLMResponse;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Creates the NTLMv2 response for the supplied information.
      *=====================================================================*
      *  Corresponds to JCIFS method:   NtlmPasswordAuthentication.computeResponse
      *=====================================================================*
     P computeResponse...
     P                 B                   export
     D                 PI                         like(ntlm_ntlmResponse_t)
     D  i_respKeyNT                        const  like(MD5_digest_t     )
     D  i_serverChallenge...
     D                                     const  like(ntlm_challenge_t )
     D  i_clientData               2048A   const
     D  i_length                     10I 0 const
      *
      *  Return value
     D NTLMResponse    S                   like(ntlm_ntlmResponse_t) inz
      *
      *  Local fields
     D hmac            S                   like(MD5_digest_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         hmac = MD5Hmac(i_respKeyNT: i_serverChallenge +
                                     %subst(i_clientData: 1: i_length));

         NTLMResponse = hmac + %subst(i_clientData: 1: i_length);

         return %subst(NTLMResponse: 1: %len(hmac) + i_length);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Calculate the 'ResponseKeyLM' as described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
      *=====================================================================*
     P LMOWFv1...
     P                 B
     D                 PI            16A
     D  i_password                         const  like(ntlm_password_t )
     D                                            options(*varsize)
      *
      *  Return value
     D responseKeyLM   DS            16    qualified
     D  first                         8A   inz(*ALLx'00')
     D  second                        8A   inz(*ALLx'00')
      *
      *  Local fields
     D password        S                   like(i_password  ) inz
      *
     D tmpKey          DS            21    qualified
     D  first                         7A   inz(*ALLx'00')
     D  second                        7A   inz(*ALLx'00')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         responseKeyLM = *ALLx'00';

         if (%len(i_password) = 0);
            return responseKeyLM;
         endif;

         password = toAscii(toUpper(i_password));

         tmpKey = *ALLx'00';
         if (password <> '');
            %subst(tmpKey: 1: %len(password)) =
                  %subst(password: 1: %len(password));
         endif;

         responseKeyLM.first = des(ASCII_STRING: DES_produceKey(tmpKey.first ));
         responseKeyLM.second= des(ASCII_STRING: DES_produceKey(tmpKey.second));

         return responseKeyLM;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Calculate the 'ResponseKeyNT' as described in document
      *  'NT LAN Manager (NTLM) Authentication Protocol Specification'.
      *=====================================================================*
     P NTOWFv1...
     P                 B                   export
     D                 PI                         like(MD4_digest_t    )
     D  i_password                         const  like(ntlm_password_t )
     D                                            options(*varsize)
      *
      *  Return value
     D digest          S                   like(MD4_digest_t ) inz(*ALLx'00')
      *
      *  Local fields
     D password        S                   like(i_password  ) inz
     D md4_digest      S                   like(MD4_digest_t) inz
     D hmac            S                   like(MD5_digest_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_password) = 0);
            return digest;
         endif;

         password = varstringLE(toUnicode(i_password));

         md4_digest = md4(password);

         digest = md4_digest;

         return digest;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Calculate the key used in NTLM v2 authentication.
      *=====================================================================*
      *  Corresponds to JCIFS method:   NtlmPasswordAuthentication.NTOWFv2
      *=====================================================================*
     P NTOWFv2...
     P                 B                   export
     D                 PI                         like(MD5_digest_t    )
     D  i_password                         const  like(ntlm_password_t )
     D                                            options(*varsize)
     D  i_user                             const  like(ntlm_user_t     )
     D                                            options(*varsize)
     D  i_domain                           const  like(ntlm_domain_t   )
     D                                            options(*varsize)
      *
      *  Return value
     D digest          S                   like(MD5_digest_t ) inz(*ALLx'00')
      *
      *  Local fields
     D password        S                   like(i_password  ) inz
     D user            S                   like(i_user      ) inz
     D domain          S                   like(i_domain    ) inz
     D md4_digest      S                   like(MD4_digest_t) inz
     D hmac            S                   like(MD5_digest_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_password) = 0);
            return digest;
         endif;

         password = varstringLE(toUnicode(i_password));
         user = varstringLE(toUnicode(toUpper(i_user)));
         domain = varstringLE(toUnicode(i_domain));

         md4_digest = md4(password);
         hmac = MD5Hmac(md4_digest: user + domain);

         digest = hmac;

         return digest;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Parses a given URL.
      *=====================================================================*
     P parseUrl...
     P                 B
     D                 PI
     D   i_URL                    32767A   const  varying options(*varsize)
     D   o_service                   32A          varying
     D   o_host                     256A          varying
      *
      *  Return value
     D URL             S                   like(i_URL) inz
      *
      *  Local fields
     D service         S             32A
     D user            S             32A
     D passwd          S             32A
     D host            S            256A
     D port            S             10I 0
     D path            S          32767A   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         http_long_ParseURL(i_URL: service: user: passwd: host: port: path);

         o_service = service;
         o_host = host;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns cTrue if the specified message matches a given type.
      *=====================================================================*
     P isMessageTypeOf...
     P                 B
     D                 PI              N
     D  i_message                          const  like(ntlm_message_t    )
     D                                            options(*varsize)
     D  i_type                             const  like(NtlmMessage_t.type)
      *
      *  Local fields
     D type            S                   like(NtlmMessage_t.type) inz
     D tmpMessage      DS                  likeds(NtLmMessage_t   ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_message) < %len(NtLmMessage_t));
            return cFalse;
         endif;

         tmpMessage = %subst(i_message: 1: %len(i_message));

         type = uint32LE(tmpMessage.type);

         if (type <> i_type);
            return cFalse;
         endif;

         return cTrue;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the specified target information of a given Type-2 message.
      *=====================================================================*
     P getTargetInfo...
     P                 B
     D                 PI                         like(ntlm_targetName_t)
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D  i_type                        5I 0 const
      *
      *  Return value
     D targetInfo      DS                  likeds(targetNameChars_t)
      *
      *  Local fields
     D type            S              5I 0 inz
     D length          S              5I 0 inz
     D offset          S             10I 0 inz
     D pNtLmChallenge  S               *   inz
      *
     D tmpTargetInfo   DS                  likeds(targetInfo_t )
     D                                     based(pTmpTargetInfo)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
                                                                                           //R
         // Get length and offset of target info
         length = uint16LE(i_NtLmChallenge.targetInfo.length);
         offset = uint32LE(i_NtLmChallenge.targetInfo.offset);

         if (length = 0);
            return u'';
         endif;

         // Go to the first target information block
         pNtLmChallenge = %addr(i_NtLmChallenge);
         pTmpTargetInfo = pNtLmChallenge + offset;

         // Spin through the target information blocks
         type = uint16LE(tmpTargetInfo.type);
         dow (type <> 0);
            length = uint16LE(tmptargetInfo.length);
            if (type <> i_type);
               pTmpTargetInfo = pTmpTargetInfo + length +                                   //RADDAT
                                %size(tmpTargetInfo.type) +                                 //RADDAT
                                %size(tmpTargetInfo.length);
               type = uint16LE(tmptargetInfo.type);
            else;
               targetInfo = stringLE(tmpTargetInfo.value: length);
               return %subst(targetInfo.unicode: 1: %int(length/2));
            endif;
         enddo;

         return u'';

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Serializes a type 1 message to a byte array.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type1Message.toByteArray
      *=====================================================================*
     P Type1_toByteArray...
     P                 B
     D                 PI                         like(ntlm_message_t )
     D  i_type1                                   likeds(type1_t )
      *
      *  Return value
     D message         S                   like(ntlm_message_t ) inz(*ALLx'00')
      *
      *  Local fields
     D isUnicode       S               N   inz(cTrue)
     D isHostInfo      S               N   inz(cFalse)
     D domain          S                   like(i_type1.domain      ) inz
     D workstation     S                   like(i_type1.workstation ) inz
     D length          S             10I 0 inz
     D NtLmNegotiate...
     D                 DS                  likeds(NtLmNegotiate_t)
     D                                     based(pNtLmNegotiate)
     D offset          S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         isUnicode = isBit(i_type1.flags: NTLMSSP_NEGOTIATE_UNICODE);

         if (%len(i_type1.domain) > 0);
            domain = toAscii(i_type1.domain);
            isHostInfo = cTrue;
         endif;

         if (%len(i_type1.workstation) > 0);
            workstation = toAscii(i_type1.workstation);
            isHostInfo = cTrue;
         endif;

         if (isHostInfo);
            length = 32 + %len(domain) + %len(workstation);
         else;
            length = 16;
         endif;

         pNtLmNegotiate = %addr(message)+2;

         NtLmNegotiate.signature = NTLMSSP_SIGNATURE;
         NtLmNegotiate.type      = uint32LE(NEGOTIATE_MESSAGE);

         if (isHostInfo);
            offset = 32;
            NtLmNegotiate.domain = writeSecurityBuffer(message: offset: domain);
            NtLmNegotiate.workstation = writeSecurityBuffer(
                                           message: offset: workstation);
         endif;

         NtLmNegotiate.flags = uint32LE(i_type1.flags);

         return %subst(message: 1: length);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Serializes a type 3 message to a byte array.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.toByteArray
      *=====================================================================*
     P Type3_toByteArray...
     P                 B
     D                 PI                         like(ntlm_message_t )
     D  i_type3                                   likeds(type3_t )
      *
      *  Return value
     D message         S                   like(ntlm_message_t ) inz(*ALLx'00')
      *
      *  Local fields
     D isUnicode       S               N   inz(cTrue)
     D domain          S                   like(i_type3.domain      ) inz
     D user            S                   like(i_type3.user        ) inz
     D workstation     S                   like(i_type3.workstation ) inz
     D length          S             10I 0 inz
     D NtLmAuthenticate...
     D                 DS                  likeds(NtLmAuthenticate_t)
     D                                     based(pNtLmAuthenticate)
     D offset          S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         isUnicode = isBit(i_type3.flags: NTLMSSP_NEGOTIATE_UNICODE);

         if (%len(i_type3.domain) > 0);
            domain = transcode(i_type3.domain: isUnicode);
         endif;

         if (%len(i_type3.user) > 0);
            if (isUnicode);
               user = transcode(i_type3.user: isUnicode);
            else;
               user = transcode(toUpper(i_type3.user): isUnicode);
            endif;
         endif;

         if (%len(i_type3.workstation) > 0);
            if (isUnicode);
               workstation = transcode(i_type3.workstation: isUnicode);
            else;
               workstation = transcode(toUpper(i_type3.workstation): isUnicode);
            endif;
         endif;

         if (isUnicode);
            domain = varstringLE(domain);
            user = varstringLE(user);
            workstation = varstringLE(workstation);
         endif;

         length = 64 + %len(domain) + %len(user) + %len(workstation) +
                  %len(i_type3.lmResponse) + %len(i_type3.ntResponse) +
                  %len(i_type3.sessionKey);

         pNtLmAuthenticate = %addr(message)+2;

         NtLmAuthenticate.signature   = NTLMSSP_SIGNATURE;
         NtLmAuthenticate.type        = uint32LE(AUTHENTICATE_MESSAGE);

         offset = 64;
         NtLmAuthenticate.LM_resp     = writeSecurityBuffer(
                                           message: offset: i_type3.lmResponse);
         NtLmAuthenticate.NTLM_resp   = writeSecurityBuffer(
                                           message: offset: i_type3.ntResponse);
         NtLmAuthenticate.targetName  = writeSecurityBuffer(
                                           message: offset: domain);
         NtLmAuthenticate.userName    = writeSecurityBuffer(
                                           message: offset: user);
         NtLmAuthenticate.workstation = writeSecurityBuffer(
                                           message: offset: workstation);
         NtLmAuthenticate.sessionKey  = writeSecurityBuffer(
                                           message: offset: i_type3.sessionKey);
         NtLmAuthenticate.flags       = uint32LE(i_type3.flags);

         return %subst(message: 1: length);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Return the NTLM message signature.
      *=====================================================================*
     P NTLMSSP_SIGNATURE...
     P                 B
     D                 PI                         like(NtLmMessage_t.signature)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return toAscii('NTLMSSP' + x'00');

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Writes a security buffer.
      *=====================================================================*
      *  Corresponds to JCIFS method:   NtlmMessage.writeSecurityBuffer
      *=====================================================================*
     P writeSecurityBuffer...
     P                 B
     D                 PI                         likeds(ntlm_securityBuffer_t)
     D  io_message                                like(ntlm_message_t )
     D                                            options(*varsize)
     D  io_offset                    10I 0
     D  i_data                     2048A   const  varying options(*varsize)
      *
      *  Return value
     D securityBuffer  DS                  likeds(ntlm_securityBuffer_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_data) = 0);
            return securityBuffer;
         endif;

         securityBuffer.length = uint16LE(%len(i_data));
         securityBuffer.maxLen = uint16LE(%len(i_data));
         securityBuffer.offset = uint32LE(io_offset);

         %subst(io_message: io_offset+1: %len(i_data)) = i_data;

         io_offset = io_offset + %len(i_data);

         return securityBuffer;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Converts a given EBCDIC string to UNICODE or ASCII.
      *=====================================================================*
     P transcode...
     P                 B
     D                 PI          4096A          varying
     D  i_ebcdic                   2048A   const  varying
     D  i_isUnicode                    N   const
      *
      *  Return value
     D transcoded      S           4096A   varying inz
      *
      *  Local fields
     D hTranscoder     S                   like(hTranscoder_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_ebcdic) = 0);
            return '';
         endif;

         if (i_isUnicode);
            transcoded = toUnicode(i_ebcdic);
         else;
            transcoded = toAscii(i_ebcdic);
         endif;

         return transcoded;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the default domain name of the i5 computer.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.getDefaultDomain
      *                     property:   jcifs.smb.client.domain
      *=====================================================================*
     P getDefaultDomain...
     P                 B
     D                 PI                         like(ntlm_domain_t )
      *
      *  Return value
     D domain          S                   like(ntlm_domain_t ) inz
      *
      *  Local fields
     D rcvVar          S            256A   inz
     D attributes      DS                  likeds(QWCRNETA_returned)
     D                                     based(pAttributes)
     D attr            DS                  likeds(QWCRNETA_attr)
     D                                     based(pAttr)
     D errCode         DS                  likeds(errCode_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pAttributes = %addr(rcvVar);
         clear errCode;

         QWCRNETA(rcvVar: %size(rcvVar): 1: 'NWSDOMAIN': errCode);

         pAttr = pAttributes + attributes.offsAttr;
         domain = %subst(attr.data_char: 1: attr.length);

         return domain;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the default workstation name of the i5 computer.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.getDefaultWorkstation
      *  Instead of returning the host name, this method returns the name
      *  of the current job.
      *=====================================================================*
     P getDefaultWorkstation...
     P                 B
     D                 PI                         like(ntlm_workstation_t )
      *
      *  Return value
     D workstation     S                   like(ntlm_workstation_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (g_isTestMode);
            return 'WORKSTATION';
         endif;

         workstation = sds.job;

         return workstation;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the default flags for a all messages.
      *=====================================================================*
     P getDefaultFlags...
     P                 B
     D                 PI            10U 0
      *
      *  Return value
     D flags           S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Default flags as used by Firefox
         // See: http://mxr.mozilla.org/mozilla/source/
         //      security/manager/ssl/src/nsNTLMAuthModule.cpp
         // Note: We do not yet support NTLMSSP_NEGOTIATE_ALWAYS_SIGN
         flags = NTLMSSP_NEGOTIATE_UNICODE   +
                 NTLMSSP_NEGOTIATE_OEM       +
                 NTLMSSP_REQUEST_TARGET      +
                 NTLMSSP_NEGOTIATE_NTLM;

         select;
         when (g_LMCompatibility = LM_MODE_NTLM_V1);            // NTLMv1
            flags = flags + NTLMSSP_NEGOTIATE_NT_ONLY                                       //RADDAT
                          + NTLMSSP_NEGOTIATE_NTLM2;

         when (g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM);      // NTLMv1 (no LM response)
            flags = flags + NTLMSSP_NEGOTIATE_NT_ONLY
                          + NTLMSSP_NEGOTIATE_NTLM2;

         when (g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY); // NTLMv1 (NTLM2 only)
            flags = flags + NTLMSSP_NEGOTIATE_NTLM2;

         when (g_LMCompatibility = LM_MODE_NTLM_V2);            // NTLMv2

         endsl;

         // Set flags to match the flags at:
         // http://davenport.sourceforge.net/ntlm.html#type3MessageExample
         if (g_isTestMode);
            flags = NTLMSSP_NEGOTIATE_UNICODE   +
                    NTLMSSP_NEGOTIATE_NTLM;
         endif;

         return flags;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the default flags for a Type-1 message.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type1Message.getDefaultFlags
      *  This method has been changed to emulate the way Firefox
      *  does NTLM authentication.
      *=====================================================================*
     P getDefaultFlagsType1...
     P                 B
     D                 PI            10U 0
      *
      *  Return value
     D flags           S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         flags = getDefaultFlags();

         return flags;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the default flags for a Type-3 message.
      *=====================================================================*
      *  Corresponds to JCIFS method:   Type3Message.getDefaultFlags
      *  This method has been changed to emulate the way Firefox
      *  does NTLM authentication.
      *=====================================================================*
     P getDefaultFlagsType3...
     P                 B
     D                 PI            10U 0
     D  i_NtLmChallenge...
     D                                            likeds(NtLmChallenge_t)
     D                                            options(*varsize: *nopass)
      *
      *  Return value
     D flags           S             10U 0 inz
      *
      *  Parameter positions
     D p_NtLmChallenge...
     D                 C                   1
      *
      *  Local fields
     D type2Flags      S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         flags = getDefaultFlags();

         if (%parms() < p_NtLmChallenge);
            if (g_preferUnicode);
               return %bitor(flags: NTLMSSP_NEGOTIATE_UNICODE);
            else;
               return %bitor(flags: NTLMSSP_NEGOTIATE_OEM);
            endif;
         endif;

         type2Flags = uint32LE(i_NtLmChallenge.flags);

         flags = bitand(type2Flags: getDefaultFlagsType1());

         return flags;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns an EBCDIC to ASCII transcoder.
      *=====================================================================*
     P getTranscoderToAscii...
     P                 B
     D                 PI                         like(hTranscoder_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (Transcoder_isNull(g_htoAscii));
            g_hToAscii = Transcoder_new(850: 0);
         endif;

         return g_hToAscii;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns an EBCDIC to UNICODE transcoder.
      *=====================================================================*
     P getTranscoderToUnicode...
     P                 B
     D                 PI                         like(hTranscoder_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (Transcoder_isNull(g_htoUnicode));
            g_hToUnicode = Transcoder_new(1200: 0);
         endif;

         return g_hToUnicode;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a given EBCDIC string to ASCII.
      *=====================================================================*
     P toAscii...
     P                 B                   export
     D                 PI          2048A          varying
     D  i_ebcdic                   2048A   const  varying
      *
      *  Return value
     D ascii           S           2048A   varying inz
      *
      *  Local fields
     D hToAscii        S                   like(hTranscoder_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_ebcdic) = 0);
            return '';
         endif;

         hToAscii = getTranscoderToAscii();
         ascii = Transcoder_xlateString(hToAscii: i_ebcdic);

         return ascii;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Not yet in use ***
      *  Frees the resources allocated by the ASCII transcoder.
      *=====================================================================*
     P freeAsciiTranscoder...
     P                 B
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Transcoder_isNull(g_htoAscii));
            Transcoder_delete(g_hToAscii);
         endif;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a given EBCDIC string to UNICODE.
      *=====================================================================*
     P toUnicode...
     P                 B                   export
     D                 PI          4096A          varying
     D  i_ebcdic                   2048A   const  varying
      *
      *  Return value
     D unicode         S           4096A   varying inz
      *
      *  Local fields
     D hToUnicode      S                   like(hTranscoder_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_ebcdic) = 0);
            return '';
         endif;

         hToUnicode = getTranscoderToUnicode();
         unicode = Transcoder_xlateString(hToUnicode: i_ebcdic);

         return unicode;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Frees the resources allocated by the UNICODE transcoder.
      *=====================================================================*
     P freeUnicodeTranscoder...
     P                 B                   export
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not Transcoder_isNull(g_htoUnicode));
            Transcoder_delete(g_hToUnicode);
         endif;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Sets the C runtime error number to ZERO (no error).
      *=====================================================================*
     P c_clearErrno...
     P                 B
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         c_errno(0);

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Sets and returns the C runtime error number.
      *=====================================================================*
     P c_errno...
     P                 B
     D                 PI            10I 0
     D  i_errno                      10I 0 const  options(*nopass)
      *
      *  Parameter positions
     D p_errno         C                   1
      *
      *  Local fields
     D runTimeError    S             10I 0 based(pRunTimeError)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pRunTimeError = errno();

         if (%parms() >= p_errno);
            runTimeError = i_errno;
         endif;

         return runTimeError;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the message text of a C runtime error number.
      *=====================================================================*
     P c_strerror...
     P                 B
     D                 PI           128A          varying
     D  i_errno                      10I 0 const
      *
      *  Return value
     D errText         S            128A   inz  varying
      *
      *  Local fields
     D pErrText        S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pErrText = strerror(i_errno);
         if   pErrText = *NULL;
            errText = '';
         else;
            errText = %str(pErrText);
         endif;

         return   errText;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns cTrue if the specified bit is set.
      *=====================================================================*
     P isBit...
     P                 B                   export
     D                 PI              N
     D  i_value                      20U 0 const
     D  i_bit                        20U 0 const
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_value = 0);
            isSet = cFalse;
         else;
            isSet = (bitand(i_value: i_bit) = i_bit);
         endif;

         return isSet;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by ENCRYPTR4, RPGUNIT tests ***
    R *  Backward compatibility to V5R1.
      *  Returns the bit-wise ANDing of the bits of all the arguments.
      *=====================================================================*
     P bitand...
     P                 B                   export
     D                 PI            20U 0
     D  i_source1                    20U 0 value
     D  i_source2                    20U 0 value
      *
      *  Return value
     D result          S             20U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ANDSTR(%addr(result)
                : %addr(i_source1): %addr(i_source2): %size(i_source2));

         return result;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by ENCRYPTR4, RPGUNIT tests ***
    R *  Backward compatibility to V5R1.
      *  Returns the bit-wise ANDing of the bits of all the arguments.
      *=====================================================================*
     P byteand...
     P                 B                   export
     D                 PI             1A
     D  i_source1                     1A   value
     D  i_source2                     1A   value
      *
      *  Return value
     D result          S              1A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ANDSTR(%addr(result)
                : %addr(i_source1): %addr(i_source2): %size(i_source2));

         return result;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
    R *  Backward compatibility to V5R1.
      *  Returns the bit-wise ORing of the bits of all the arguments.
      *=====================================================================*
     P bitor...
     P                 B                   export
     D                 PI            20U 0
     D  i_source1                    20U 0 value
     D  i_source2                    20U 0 value
      *
      *  Return value
     D result          S             20U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ORSTR(%addr(result)
               : %addr(i_source1): %addr(i_source2): %size(i_source2));

         return result;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by ENCRYPTR4, RPGUNIT tests ***
    R *  Backward compatibility to V5R1.
      *  Returns the bit-wise ANDing of the bits of all the arguments.
      *=====================================================================*
     P byteor...
     P                 B                   export
     D                 PI             1A
     D  i_source1                     1A   value
     D  i_source2                     1A   value
      *
      *  Return value
     D result          S              1A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ORSTR(%addr(result)
               : %addr(i_source1): %addr(i_source2): %size(i_source2));

         return result;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Sends an ESCAPE message to kill the application.
      *=====================================================================*
     P kill...
     P                 B
     D                 PI
     D  i_text                      128A   const  varying
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';

         clear errCode;
         errCode.bytPrv = %size(errCode);

         QMHSNDPM('CPF9898': qMsgF: i_text: %len(i_text): '*ESCAPE'
                  : '*': 1: msgKey: errCode);

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a 2-byte integer to little-endian format.
      *=====================================================================*
     P uint16LE...
     P                 B                   export
     D                 PI             5U 0
     D  i_int2                        5U 0 const
      *
      *  Return value
     D rtn             DS                  qualified
     D  int2                          5U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
      *
      *  Local fields
     D input           DS                  qualified
     D  int2                          5U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         input.int2 = i_int2;

         rtn.byte1 = input.byte2;
         rtn.byte2 = input.byte1;

         return rtn.int2;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a 4-byte integer to little-endian format.
      *=====================================================================*
     P uint32LE...
     P                 B                   export
     D                 PI            10U 0
     D  i_int4                       10U 0 const
      *
      *  Return value
     D rtn             DS                  qualified
     D  int4                         10U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
     D  byte3                  3      3U 0
     D  byte4                  4      4U 0
      *
      *  Local fields
     D input           DS                  qualified
     D  int4                         10U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
     D  byte3                  3      3U 0
     D  byte4                  4      4U 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         input.int4 = i_int4;

         rtn.byte1 = input.byte4;
         rtn.byte2 = input.byte3;
         rtn.byte3 = input.byte2;
         rtn.byte4 = input.byte1;

         return rtn.int4;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a 8-byte integer to little-endian format.
      *=====================================================================*
     P uint64LE...
     P                 B                   export
     D                 PI            20U 0
     D  i_int8                       20U 0 const
      *
      *  Return value
     D rtn             DS                  qualified
     D  int8                         20U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
     D  byte3                  3      3U 0
     D  byte4                  4      4U 0
     D  byte5                  5      5U 0
     D  byte6                  6      6U 0
     D  byte7                  7      7U 0
     D  byte8                  8      8U 0
      *
      *  Local fields
     D input           DS                  qualified
     D  int8                         20U 0
     D  byte1                  1      1U 0
     D  byte2                  2      2U 0
     D  byte3                  3      3U 0
     D  byte4                  4      4U 0
     D  byte5                  5      5U 0
     D  byte6                  6      6U 0
     D  byte7                  7      7U 0
     D  byte8                  8      8U 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         input.int8 = i_int8;

         rtn.byte1 = input.byte8;
         rtn.byte2 = input.byte7;
         rtn.byte3 = input.byte6;
         rtn.byte4 = input.byte5;
         rtn.byte5 = input.byte4;
         rtn.byte6 = input.byte3;
         rtn.byte7 = input.byte2;
         rtn.byte8 = input.byte1;

         return rtn.int8;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a string value to little-endian format.
      *=====================================================================*
     P stringLE...
     P                 B                   export
     D                 PI          1024A          varying
     D  i_string                   1024A          options(*varsize)
     D  i_length                     10I 0 const
      *
      *  Return value
     D rtn             S           1024A   varying inz
      *
      *  Local fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         %len(rtn) = i_length;

         for x = 2 to i_length by 2;
            %subst(rtn: x-1: 1) = %subst(i_string:x   : 1);
            %subst(rtn: x  : 1) = %subst(i_string:x-1 : 1);
         endfor;

         return rtn;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a string value to little-endian format.
      *=====================================================================*
     P varstringLE...
     P                 B                   export
     D                 PI          1024A          varying
     D  i_string                   1024A   const  varying options(*varsize)
      *
      *  Return value
     D rtn             S           1024A   varying inz
      *
      *  Local fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         %len(rtn) = %len(i_string);

         for x = 2 to %len(i_string) by 2;
            %subst(rtn: x-1: 1) = %subst(i_string:x   : 1);
            %subst(rtn: x  : 1) = %subst(i_string:x-1 : 1);
         endfor;

         return rtn;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns a random 8-byte challenge.
      *=====================================================================*
     P random...
     P                 B                   export
     D                 PI                  opdesc
     D  o_random                    128A          options(*varsize)
     D  i_isTestMode                   N   const  options(*nopass)
      *
      *  Parameter positions
     D p_random        C                   1
     D p_isTestMode    C                   2
      *
      *  Optional parameter fields
     D isTestMode      S                   like(i_isTestMode) inz
      *
      *  Local fields
     D isInit          S               N   inz(cFalse) static
     D randInf         DS                  likeds(strInf_t ) inz
     D offs            S             10I 0 inz
     D i               S              3U 0 inz
     D p               S              3U 0 inz
      *
     D randNum         DS                  qualified
     D  int4                   1      4U 0
     D  chars                  3      4A
     D  int1                   3      4U 0 dim(2)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_isTestMode);
            isTestMode = i_isTestMode;
         else;
            isTestMode = cFalse;
         endif;

         if (not isInit);
            srand(time(*null));
            isInit = cTrue;
         endif;

         CEEGSI(p_random: randInf.dataType
                : randInf.curlen: randInf.maxLen: *omit);

         // rand() returns a number between 0 and RAND_MAX (qsysinc/h.stdlib)
         // where RAND_MAX is 32767.
         offs = 0;
         i = 1;
         dow (offs < randInf.curlen);
            if (not isTestMode);
               randNum.int4 = rand();
            else;
               for p = 1 to %size(randNum.chars);
                  randNum.int1(p) = i;
                  i = i + 1;
               endfor;
            endif;

            if (offs + %size(randNum.chars) <= randInf.curlen);
               %subst(o_random: offs+1: %size(randNum.chars))= randNum.chars;
            else;
               %subst(o_random: offs+1) = randNum.chars;
            endif;
            offs = offs + %size(randNum.chars);
         enddo;

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a given string to upper case.
      *=====================================================================*
     P toUpper...
     P                 B                   export
     D                 PI          1024A          varying
     D  i_string                   1024A   const  varying
      *
      *  Return value
     D upper           S           1024A   varying inz
      *
      *  Fields for QlgConvertCase API
     D tmpBuffer       S           1024A   inz
     D reqCtrlBlk      DS                  likeds(QLGCNVCS_reqCtrlBlk_t) inz
     D errCode         DS                  likeds(errCode_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return i_string;
         endif;

         reqCtrlBlk.type  = CVTCASE_TYPE_CCSID;
         reqCtrlBlk.CCSID = CVTCASE_CCSID_JOB;
         reqCtrlBlk.case  = CVTCASE_TO_UPPER;
         reqCtrlBlk.reserved = *ALLx'00';
         clear errCode;
         QlgConvertCase(reqCtrlBlk:
                        i_string: tmpBuffer: %len(i_string): errCode);
         upper = %subst(tmpBuffer: 1: %len(i_string));

         return upper;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Converts a given string to lower case.
      *=====================================================================*
     P toLower...
     P                 B                   export
     D                 PI          1024A          varying
     D  i_string                   1024A   const  varying
      *
      *  Return value
     D lower           S           1024A   varying inz
      *
      *  Fields for QlgConvertCase API
     D tmpBuffer       S           1024A   inz
     D reqCtrlBlk      DS                  likeds(QLGCNVCS_reqCtrlBlk_t) inz
     D errCode         DS                  likeds(errCode_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_string = '');
            return i_string;
         endif;

         reqCtrlBlk.type  = CVTCASE_TYPE_CCSID;
         reqCtrlBlk.CCSID = CVTCASE_CCSID_JOB;
         reqCtrlBlk.case  = CVTCASE_TO_LOWER;
         reqCtrlBlk.reserved = *ALLx'00';
         clear errCode;
         QlgConvertCase(reqCtrlBlk:
                        i_string: tmpBuffer: %len(i_string): errCode);
         lower = %subst(tmpBuffer: 1: %len(i_string));

         return lower;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Encrypts an 8-byte data item D with the 16-byte key K using the
      *  Data Encryption Standard Long (DESL) algorithm.
      *  The result is 24 bytes in length.
      *=====================================================================*
     P desl...
     P                 B
     D                 PI            24A
     D  i_key                        16A   const
     D  i_data                        8A   const
      *
      *  Return value
     D digest          DS            24    qualified
     D  first                         8A   inz(*ALLx'00')
     D  second                        8A   inz(*ALLx'00')
     D  third                         8A   inz(*ALLx'00')
      *
      *  Local fields
     D tmpKey          DS            21    qualified
     D  first                         7A   inz(*ALLx'00')
     D  second                        7A   inz(*ALLx'00')
     D  third                         7A   inz(*ALLx'00')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         %subst(tmpKey: 1: %len(i_key)) = i_key;
         digest.first  = des(i_data: DES_produceKey(tmpKey.first));
         digest.second = des(i_data: DES_produceKey(tmpKey.second));
         digest.third  = des(i_data: DES_produceKey(tmpKey.third));

         return digest;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Creates a byte array of length N. Each byte
      *  in the array is initialized to the value zero.
      *=====================================================================*
     P z...
     P                 B
     D                 PI           128A          varying
     D  i_n                          10I 0 const
      *
      *  Return value
     D zeroBytes       S            128A   varying inz(*ALLx'00')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         %len(zeroBytes) = i_n;

         return zeroBytes;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns the current time in milliseconds.
      *=====================================================================*
     P getCurrentTimeMillis...
     P                 B
     D                 PI            20U 0
      *
      *  Return value
     D timeInMillis    S             20U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         timeInMillis = time(*null) * 10000;

         return timeInMillis;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** Exported because, internally used by RPGUNIT tests ***
      *  Returns the next token from a list of tokens.
      *=====================================================================*
     P getToken...
     P                 B                   export
     D                 PI          2048A          varying
     D  i_tokens                   2048A   const  varying options(*omit)
     D  i_delimiters                 16A   const  varying
      *
      *  Return value
     D token           S           2048A   varying inz
      *
      *  Parameter positions
     D p_tokens        C                   1
      *
      *  Local fields
     D start           S             10I 0 inz
      *
      *  Local static fields
     D tokens          S                   like(i_tokens) inz  static
     D offs            S             10I 0 inz                 static
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_tokens and %addr(i_tokens) <> *NULL);
            tokens = i_tokens;
            offs = 0;
         endif;

         token = '';

         // Skip leading delimiters
         dow (offs < %len(tokens) and
              %scan(%subst(tokens: offs+1: 1): i_delimiters) > 0);
            offs = offs + 1;
         enddo;

         start = offs;

         // Get next token
         dow (offs < %len(tokens) and
              %scan(%subst(tokens: offs+1: 1): i_delimiters) = 0);
            offs = offs + 1;
         enddo;

         if (offs-start > 0);
            token = %subst(tokens: start+1: offs-start);
         endif;

         return token;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Appends a given buffer to the NULL device.
      *=====================================================================*
     P nullWrite...
     P                 B
     D                 PI            10I 0
     D  i_fd                         10I 0 value
     D  i_data                         *   value
     D  i_length                     10I 0 value
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return i_length;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  base64_encode:  Encode binary data using Base64 encoding
      *
      *       Input = (input) pointer to data to convert
      *    InputLen = (input) length of data to convert
      *      Output = (output) pointer to memory to receive output
      *     OutSize = (input) size of area to store output in
      *
      *  Returns length of encoded data, or space needed to encode
      *      data. If this value is greater than OutSize, then
      *      output may have been truncated.
      *=====================================================================*
     P NTLM_Base64_encode...
     P                 B
     D                 PI            10U 0
     D   Input                         *   value
     D   InputLen                    10U 0 value
     D   Output                        *   value
     D   OutputSize                  10U 0 value

     D                 DS
     D   Numb                  1      2U 0 inz(0)
     D   Byte                  2      2A

     D data            DS                  based(Input)
     D   B1                           1A
     D   B2                           1A
     D   B3                           1A

     D OutData         S              4A   based(Output)
     D Temp            S              4A
     D Pos             S             10I 0
     D OutLen          S             10I 0
     D Save            s              1A

      /free

          Pos = 1;

          dow (Pos <= InputLen);

             // -------------------------------------------------
             // First output byte comes from bits 1-6 of input
             // -------------------------------------------------

             Byte = byteand(B1: x'FC');
             Numb /= 4;
             %subst(Temp:1) = base64f(Numb+1);

             // -------------------------------------------------
             // Second output byte comes from bits 7-8 of byte 1
             //                           and bits 1-4 of byte 2
             // -------------------------------------------------
             Byte = byteand(B1: x'03');
             Numb *= 16;

             if (Pos+1 <= InputLen);
                Save = Byte;
                Byte = byteand(B2: x'F0');
                Numb /= 16;
                Byte = %bitor(Save: Byte);
             endif;

             %subst(Temp: 2) = base64f(Numb+1);

             // -------------------------------------------------
             // Third output byte comes from bits 5-8 of byte 2
             //                          and bits 1-2 of byte 3
             // (or is set to '=' if there was only one byte)
             // -------------------------------------------------

             if (Pos+1 > InputLen);
                 %subst(Temp: 3) = '=';
             else;
                 Byte = byteand(B2: x'0F');
                 Numb *= 4;

                 if (Pos+2 <= InputLen);
                     Save = Byte;
                     Byte = byteand(B3: x'C0');
                     Numb /= 64;
                     Byte = %bitor(Save: Byte);
                 endif;

                 %subst(Temp:3) = base64f(Numb+1);
             endif;

             // -------------------------------------------------
             // Fourth output byte comes from bits 3-8 of byte 3
             // (or is set to '=' if there was only one/two bytes)
             // -------------------------------------------------

             if (Pos+2 > InputLen);
                 %subst(Temp:4:1) = '=';
             else;
                 Byte = byteand(B3: x'3F');
                 %subst(Temp:4) = base64f(Numb+1);
             endif;

             // -------------------------------------------------
             //   Advance to next chunk of data.
             // -------------------------------------------------

             Input += %size(data);
             Pos += %size(data);
             OutLen += %size(Temp);

             if (OutLen <= OutputSize);
                OutData = Temp;
                Output += %size(Temp);
             endif;

          enddo;

          return OutLen;

      /end-free
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  base64_decode: Decode base64 encoded data back to binary
      *
      *       Input = (input) pointer to base64 data to decode
      *    InputLen = (input) length of base64 data
      *      Output = (output) pointer to memory to receive output
      *     OutSize = (input) size of area to store output in
      *
      *  Returns length of decoded data, or space needed to decode
      *      data. If this value is greater than OutSize, then
      *      output may have been truncated.
      *=====================================================================*
     P NTLM_Base64_decode...
     P                 B
     D                 PI            10U 0
     D   Input                         *   value
     D   InputLen                    10U 0 value
     D   Output                        *   value
     D   OutputSize                  10U 0 value

     D                 DS
     D   Numb                  1      2U 0 inz(0)
     D   Byte                  2      2A

     D data            DS                  based(Input)
     D   B1                           3U 0
     D   B2                           3U 0
     D   B3                           3U 0
     D   B4                           3U 0

     D OutData         S              3A   based(Output)
     D temp            S              3A   varying
     D Pos             S             10I 0
     D OutLen          S             10I 0

      /free

          Pos = 1;

          dow (Pos <= InputLen);

             if (base64r(B1)=x'FF');
                 invalidChar(Pos:B1);
             endif;
             if (base64r(B2)=x'FF');
                 invalidChar(Pos+1:B2);
             endif;
             if (base64r(B3)=x'FF' and B3<>126);
                 invalidChar(Pos+2:B3);
             endif;
             if (base64r(B4)=x'FF' and B4<>126);
                 invalidChar(Pos+3:B4);
             endif;

             // -------------------------------------------------
             // First output byte comes from bits 3-8 of byte 1
             //                          and bits 3-4 of byte 2
             // -------------------------------------------------

             Numb = base64r(B1) * 4
                  + base64r(B2) / 16;
             Temp = Byte;

             // -------------------------------------------------
             // Second output byte comes from bits 5-8 of byte 2
             //                           and bits 3-6 of byte 3
             // -------------------------------------------------
             if %subst(data: 3: 1) <> '=';
                  numb = bitand(base64r(B2):x'0f') * 16
                       + base64r(B3) / 4;
                  Temp += Byte;
             endif;

             // -------------------------------------------------
             // Third output byte comes from bits 7-8 of byte 3
             //                          and bits 3-8 of byte 4
             // (or is set to '=' if there was only one byte)
             // -------------------------------------------------
             if %subst(data: 4: 1) <> '=';
                  numb = bitand(base64r(B3):x'03') * 64
                       + base64r(B4);
                  Temp += Byte;
             endif;

             // -------------------------------------------------
             //   Advance to next chunk of data.
             // -------------------------------------------------

             Input += %size(data);
             Pos += %size(data);
             OutLen += %len(Temp);

             if (OutLen <= OutputSize);
                OutData = Temp;
                Output += %len(Temp);
             endif;

          enddo;

          return OutLen;

      /end-free
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      * invalidChar(): Report an invalid input character
      *                in a fashion dramatic enough that people
      *                won't blame me when they provide invalid
      *                input characters|
      *=====================================================================*
     P invalidChar...
     P                 B
     D                 PI
     D   CharPos                     10i 0 value
     D   Char                         3u 0 value

     D QMHSNDPM        PR                  ExtPgm('QMHSNDPM')
     D   MessageID                    7A   Const
     D   QualMsgF                    20A   Const
     D   MsgData                  32767a   Const options(*varsize)
     D   MsgDtaLen                   10I 0 Const
     D   MsgType                     10A   Const
     D   CallStkEnt                  10A   Const
     D   CallStkCnt                  10I 0 Const
     D   MessageKey                   4A
     D   ErrorCode                 8192A   options(*varsize)

     D ErrorCode       DS                  qualified
     D  BytesProv              1      4I 0 inz(0)
     D  BytesAvail             5      8I 0 inz(0)

     D cvthc           PR                  ExtProc('cvthc')
     D   target                       2A   options(*varsize)
     D   src_bits                     3u 0 const
     D   tgt_length                  10I 0 value

     D Hex             s              2a
     D MsgKey          S              4A
     D MsgDta          s            100a   varying

      /free

         cvthc(hex:char:%size(hex));

         MsgDta = 'Unable to decode character at position '
                + %char(CharPos) + '. (Char=x''' + hex + ''')';

         QMHSNDPM( 'CPF9897'
                 : 'QCPFMSG   *LIBL'
                 : MsgDta
                 : %len(MsgDta)
                 : '*ESCAPE'
                 : '*PGMBDY'
                 : 2
                 : MsgKey
                 : ErrorCode         );

      /end-free
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Initializes character translation.
      *=====================================================================*
     P Transcoder_new...
     P                 B
     D                 PI                         like(hTranscoder_t )
     D  i_toCcsid                    10U 0 const
     D  i_fromCcsid                  10U 0 const
      *
      *  Return value
     D hTranscoder     S                   like(hTranscoder_t ) inz
      *
      *  Helper fields
     D toCode          DS                  likeds(QtqCode_t   ) inz
     D fromCode        DS                  likeds(QtqCode_t   ) inz
     D hIconv          DS                  likeds(iconv_t     ) inz
      *
      *  Transcoder handle
     D transcoder      DS                  likeds(transcoder_t )
     D                                     based(pTranscoder)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear fromCode;
         fromCode.ccsid         = i_fromCcsid;
         fromCode.conversionA   = 0;
         fromCode.substitutionA = 0;
         fromCode.shiftStateA   = 0;
         fromCode.inpLenOpt     = 0;
         fromCode.errOptMxdDta  = 1;
         fromCode.reserved      = *ALLx'00';

         clear toCode;
         toCode.ccsid         = i_toCcsid;
         toCode.conversionA   = 0;
         toCode.substitutionA = 0;
         toCode.shiftStateA   = 0;
         toCode.inpLenOpt     = 0;
         toCode.errOptMxdDta  = 0;
         toCode.reserved      =   *ALLx'00';

         hIconv = QtqIconv_open(toCode: fromCode);
         if (hIconv.return_value = -1);
            kill('Failed to initialize character: ' +
                  c_strerror(c_errno()));
         endif;

         pTranscoder = %alloc(%size(transcoder));

         clear transcoder;
         transcoder.fromCcsid = i_fromCcsid;
         transcoder.toCcsid   = i_toCcsid;
         transcoder.hIconv    = hIconv;

         hTranscoder = pTranscoder;

         return hTranscoder;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Translates a given varying string.
      *=========================================================================
      *  Parameters:
      *   i_hTranscoder - Handle of the character transcoder.
      *   i_string      - Varying field containing the input data.
      *   o_msg         - Optional. Error message.
      *
      *  Returns:
      *   string        - Varying field containing the translated data on
      *                   success, else an empty string.
      *=====================================================================*
     P Transcoder_xlateString...
     P                 B
     D                 PI         32767A   opdesc varying
     D  i_hTranscoder                      const  like(hTranscoder_t )
     D  i_string                  32767A   const  varying options(*varsize)
      *
      *  Return value
     D rtn             DS                  qualified
     D  string                    32767A   varying
     D  len                    1      2I 0
     D  data                   3  32767A
      *
      *  Helper fields
     D tRc             S             10U 0 inz
     D pInBuf          S               *   inz
     D pOutBuf         S               *   inz
      *
      *  Transcoder handle
     D transcoder      DS                  likeds(transcoder_t )
     D                                     based(i_hTranscoder)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         rtn.string = i_string;

         pInBuf  = %addr(rtn.data);
         pOutBuf = *NULL;

         tRc = performTranslation(i_hTranscoder
                                  : pInBuf
                                  : %len(i_string)
                                  : pOutBuf
                                  : %size(rtn.data));

         if (tRc = ICONV_ERROR);
            rtn.len = 0;
         else;
            rtn.len = tRc;
            memcpy2(%addr(rtn.data): pOutBuf: rtn.len);
         endif;

         if (pOutBuf <> *NULL);
            dealloc(N) pOutBuf;
         endif;

         return rtn.string;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Frees a given transcoder.
      *=========================================================================
      *  Parameters:
      *   io_hTranscoder - Handle of the character transcoder.
      *
      *  Returns:
      *   void
      *=====================================================================*
     P Transcoder_delete...
     P                 B
     D                 PI
     D  io_hTranscoder...
     D                                            like(hTranscoder_t )
      *
      *  Transcoder handle
     D transcoder      DS                  likeds(transcoder_t )
     D                                     based(io_hTranscoder)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         iconv_close(transcoder.hIconv);
         io_hTranscoder = Transcoder_null();

         return;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns cTrue if a given Transcoder handle is NULL.
      *=====================================================================*
     P Transcoder_isNull...
     P                 B
     D                 PI              N
     D  i_hTranscoder                      const  like(hTranscoder_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_hTranscoder = Transcoder_null());
            return cTrue;
         else;
            return cFalse;
         endif;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Returns a Transcoder NULL-handle.
      *=====================================================================*
     P Transcoder_null...
     P                 B
     D                 PI                         like(hTranscoder_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return *NULL;

      /END-FREE
     P                 E
      *
      *=====================================================================*
    R *  *** private ***
      *  Performs charcater translation. Returns the length of the
      *  transcoded buffer.
      *=====================================================================*
     P performTranslation...
     P                 B
     D                 PI            10U 0
     D  i_hTranscoder                      const  like(hTranscoder_t )
     D  i_pInBuf                       *   value
     D  i_length                     10I 0 const
     D  o_pOutBuf                      *
     D  i_maxSize                    10I 0 const
      *
      *  Return value
     D length          S             10U 0 inz
      *
      *  Helper fields
     D rc              S             10U 0 inz
     D bytPrv          S             10U 0 inz
     D bytLeft         S             10U 0 inz
     D bufSize         S             10I 0 inz
     D pInBuf          S               *   inz
     D pOutBuf         S               *   inz
     D inpBuf          S          32767A   based(i_pInBuf)
     D extendSize      S             10I 0 inz
     D isMaxSize       S               N   inz(cFalse)
      *
      * No restriction of maximum buffer size
     D MAX_SIZE        C                   -1
      *
      *  Transcoder handle
     D transcoder      DS                  likeds(transcoder_t )
     D                                     based(i_hTranscoder)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         bytPrv    = i_length;
         bytLeft   = i_length;
         bufSize   = i_length;
         pInBuf    = i_pInBuf;
         length    = 0;

         if (o_pOutBuf = *NULL);
            o_pOutBuf = %alloc(bufSize);
         else;
            kill('o_pOutBuf must be *NULL');
         endif;

         if (i_maxSize = -1);
            isMaxSize = cFalse;
         else;
            isMaxSize = cTrue;
         endif;

         c_clearErrno();
         dou (rc <> ICONV_ERROR) or (c_errno() <> E2BIG_C or
              (isMaxSize and bufSize >= i_maxSize));

            if (c_errno() = E2BIG_C);
               if (isMaxSize and bufSize >= i_maxSize);
                  leave;
               endif;
               if (pInBuf = i_pInBuf);
                  // No bytes have been transcoded. Reset values.
                  bytPrv  = i_length;
                  bytLeft = bufSize;
                  length  = 0;
               endif;
               extendSize = bytPrv * 2;
               if (MAX_SIZE > 0 and extendSize > MAX_SIZE);
                  extendSize = MAX_SIZE - bufSize;
               endif;
               if (isMaxSize and (bufSize + extendSize) > i_maxSize);
                  extendSize = i_maxSize - bufSize;
               endif;
               bufSize   = bufSize + extendSize;
               bytLeft   = bytLeft + extendSize;
               o_pOutBuf = %realloc(o_pOutBuf: bufSize);
            endif;

            pOutBuf = o_pOutBuf + length;
            length = length + bytLeft;
            rc = iconv(transcoder.hIconv: pInBuf: bytPrv: pOutBuf: bytLeft);
            length = length - bytLeft;

         enddo;

         if (rc = ICONV_ERROR);
            length = rc;
            if (c_errno() = E2BIG_C);
               kill('Target buffer too small to hold result.');
            else;
               kill('Failed to transcode characters: ' +
                    c_strerror(c_errno()));
            endif;
         endif;

         return length;

      /END-FREE
     P                 E
      *
     H NOMAIN

      /define HTTP_ORIG_SOAPACTION
      /copy httpapi_h
      /copy private_h

     D setErrorNotSupported...
     D                 PR            10i 0

     P http_url_get_xml...
     P                 B                   export
     D http_url_get_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E


     P http_url_post_xml...
     P                 B                   export
     D http_url_post_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E

     P http_url_post_stmf_xml...
     P                 B                   export
     D http_url_post_stmf_xml...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFile                32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E


     P http_parse_xml_stmf...
     P                 B                   export
     D http_parse_xml_stmf...
     D                 PI            10I 0
     D  peFile                    32767A   varying const options(*varsize)
     D  peCCSID                      10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     c                   return    setErrorNotSupported()
     P                 E


     P http_get_xmltf...
     P                 B                   export
     D http_get_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peModTime                      Z   const options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E


     P http_post_xmltf...
     P                 B                   export
     D http_post_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostData                     *   value
     D  pePostDataLen                10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E


     P http_post_stmf_xmltf...
     P                 B                   export
     D http_post_stmf_xmltf...
     D                 PI            10I 0
     D  peURL                     32767A   varying const options(*varsize)
     D  pePostFile                32767A   varying const options(*varsize)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     D  peTimeout                    10I 0 value options(*nopass)
      /if defined(HTTP_ORIG_SHORTFIELD)
     D  peUserAgent                  64A   const options(*nopass:*omit)
     D  peContentType                64A   const options(*nopass:*omit)
     D  peSOAPAction                 64A   const options(*nopass:*omit)
      /else
     D  peUserAgent               16384A   varying const
     D                                     options(*nopass:*omit)
     D  peContentType             16384A   varying const
     D                                     options(*nopass:*omit)
     D  peSOAPAction              16384A   varying const
     D                                     options(*nopass:*omit)
      /endif
     c                   return    setErrorNotSupported()
     P                 E


     P http_xmlns      B                   export
     D http_xmlns      PI
     D   peEnable                     1N   const
     c                   callp     setErrorNotSupported()
     P                 E


     P http_XmlReturnPtr...
     P                 B                   export
     D http_XmlReturnPtr...
     D                 PI
     D   peEnable                     1N   const
     c                   callp     setErrorNotSupported()
     P                 E


     P http_XmlStripCRLF...
     P                 B                   export
     D http_XmlStripCRLF...
     D                 PI
     D   peEnable                     1N   const
     c                   callp     setErrorNotSupported()
     P                 E


     P http_parser_switch_cb...
     P                 B                   export
     D http_parser_switch_cb...
     D                 PI            10I 0
     D  peUsrDta                       *   value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr options(*nopass)
     c                   return    setErrorNotSupported()
     P                 E


     P http_parser_get_start_cb...
     P                 B                   export
     D http_parser_get_start_cb...
     D                 PI              *   procptr
     c                   callp     setErrorNotSupported()
     c                   return    *null
     P                 E


     P http_parser_get_end_cb...
     P                 B                   export
     D http_parser_get_end_cb...
     D                 PI              *   procptr
     c                   callp     setErrorNotSupported()
     c                   return    *null
     P                 E


     P http_parser_get_userdata...
     P                 B                   export
     D http_parser_get_userdata...
     D                 PI              *
     c                   callp     setErrorNotSupported()
     c                   return    *null
     P                 E


     P http_parse_xml_string...
     P                 B                   export
     D http_parse_xml_string...
     D                 PI            10i 0
     D  peString                       *   value
     D  peLen                        10I 0 value
     D  peCCSID                      10I 0 value
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     c                   return    setErrorNotSupported()
     P                 E


     P HTTP_nextXmlAttr...
     P                 B                   EXPORT
     D HTTP_nextXmlAttr...
     D                 PI             1N
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D   num                         10i 0
     D   name                      1024a   varying
     D   val                      65535a   varying
     c                   callp     setErrorNotSupported()
     c                   return    *OFF
     P                 E


     P http_EscapeXml  B                   export
     D http_EscapeXml  PI          4096a   varying
     D  peString                   4096a   varying const
     c                   callp     setErrorNotSupported()
     c                   return    peString
     P                 E


     P http_XmlReturnUCS...
     P                 B                   export
     D http_XmlReturnUCS...
     D                 PI
     D   peEnable                     1N   const
     c                   callp     setErrorNotSupported()
     P                 E


     P http_parser_init...
     P                 B                   export
     D http_parser_init...
     D                 PI
     D  peCCSID                      10I 0 const options(*omit)
     D  peStartProc                    *   value procptr
     D  peEndProc                      *   value procptr
     D  peUsrDta                       *   value
     c                   callp     setErrorNotSupported()
     P                 E


     P http_parser_parseChunk...
     P                 B                   export
     D http_parser_parseChunk...
     D                 PI            10I 0
     D   peFD                        10I 0 value
     D   peData                        *   value  options(*string)
     D   peLength                    10I 0 value
     c                   return    setErrorNotSupported()
     P                 E


     P http_parser_free...
     P                 B                   export
     D http_parser_free...
     D                 PI            10I 0
     D   peUpdError                    N   const  options(*nopass: *omit)
     c                   return    setErrorNotSupported()
     P                 E


     P HTTP_nextXmlAttrUCS...
     P                 B                   EXPORT
     D HTTP_nextXmlAttrUCS...
     D                 PI             1N
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
     D   num                         10i 0
     D   name                      1024c   varying
     D   val                      65535c   varying
     c                   callp     setErrorNotSupported()
     c                   return    *off
     P                 E


     P setErrorNotSupported...
     P                 B
     D                 pi            10i 0
     c                   callp     seterror(HTTP_NOTSUPP
     c                                     : 'HTTPAPI was not built '
     c                                     + 'with XML support.')
     c                   return    -1
     P                 E
