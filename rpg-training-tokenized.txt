
 
 H NOMAIN 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * SRCSTMT ) 
 / endif 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy httpapi_h 
 / copy private_h 
 / copy errno_h 
 
 D ToASCII DS 
 D ICORV_A 10I 0 
 D ICOC_A 10I 0 dim ( 12 ) 
 
 D ToEBCDIC DS 
 D ICORV_E 10I 0 
 D ICOC_E 10I 0 dim ( 12 ) 
 
 D xmlEBCDIC DS 
 D ICORV_X 10I 0 
 D ICOC_X 10I 0 dim ( 12 ) 
 
 D pToASCII DS 
 D ICORV_PA 10I 0 
 D ICOC_PA 10I 0 dim ( 12 ) 
 
 D pToEBCDIC DS 
 D ICORV_PE 10I 0 
 D ICOC_PE 10I 0 dim ( 12 ) 
 
 D dsFROM DS 
 D from_ccsid 10I 0 
 D from_ca 10I 0 INZ ( 0 ) 
 D from_sa 10I 0 INZ ( 0 ) 
 D from_ss 10I 0 INZ ( 0 ) 
 D from_il 10I 0 INZ ( 0 ) 
 D from_eo 10I 0 INZ ( 0 ) 
 D from_r 8A INZ ( * allx'00' ) 
 
 D dsTO DS 
 D to_ccsid 10I 0 
 D to_ca 10I 0 INZ ( 0 ) 
 D to_sa 10I 0 INZ ( 0 ) 
 D to_ss 10I 0 INZ ( 0 ) 
 D to_il 10I 0 INZ ( 0 ) 
 D to_eo 10I 0 INZ ( 0 ) 
 D to_r 8A INZ ( * allx'00' ) 
 
 D iconv_open PR ExtProc ( 'QtqIconvOpen' ) 
 D like ( ToASCII ) 
 D ToCode like ( dsFrom ) 
 D FromCode like ( dsTo ) 
 
 D iconv PR 10U 0 ExtProc ( 'iconv' ) 
 D Descriptor like ( ToASCII ) value 
 D p_inbuf * 
 D in_left 10U 0 
 D p_outbuf * 
 D out_left 10U 0 
 
 D iconv_close PR 10I 0 extproc ( 'iconv_close' ) 
 D cd like ( ToASCII ) value 
 
 D EBCDIC s 10I 0 inz ( - 1 ) 
 D ASCII s 10I 0 inz ( - 1 ) 
 
 D xml_EBCDIC s 10I 0 inz ( - 1 ) 
 D xml_ASCII s 10I 0 inz ( - 1 ) 
 
 D TblXlate PR 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D CCSIDxlate PR 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D TblXlateDyn PR 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D peOutput * 
 D CCSIDXlateDyn PR 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D peOutbuf * 
 D xlate_symbols PR 25a 
 D BinaryCopy PR 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peOutbuf * 
 
 D CCSIDs_Set s 1A inz ( * OFF ) 
 D Xml_CCSID_Set s 1A inz ( * OFF ) 
 D BinaryData s 1A inz ( * OFF ) 
 
 
 P HTTP_SetCCSIDs B export 
 D HTTP_SetCCSIDs PI 10I 0 
 D pePostRem 10I 0 value 
 D pePostLoc 10I 0 value 
 D peProtRem 10I 0 value options ( * nopass ) 
 D peProtLoc 10I 0 value options ( * nopass ) 
 
 D wwProtRem s 10I 0 
 D wwProtLoc s 10I 0 
 
 c if % parms >= 3 
 c eval wwProtRem = peProtRem 
 c else 
 c eval wwProtRem = HTTP_ASCII 
 c endif 
 
 c if % parms >= 4 
 c eval wwProtLoc = peProtLoc 
 c else 
 c eval wwProtLoc = HTTP_EBCDIC 
 c endif 
 
 c eval p_global = getGlobalPtr ( ) 
 c eval global . net_ccsid = pePostRem 
 c eval global . local_ccsid = pePostLoc 
 
 c if CCSIDs_Set = * ON 
 c callp iconv_close ( PToASCII ) 
 c callp iconv_close ( PToEBCDIC ) 
 c callp iconv_close ( ToEBCDIC ) 
 c callp iconv_close ( ToASCII ) 
 c endif 
 
 c eval BinaryData = * off 
 c if pePostRem = pePostLoc 
 c eval BinaryData = * on 
 c endif 
 
 c if BinaryData = * Off 
 c eval from_ccsid = pePostRem 
 c eval to_ccsid = pePostLoc 
 c eval pToEBCDIC = iconv_open ( dsTo : dsFrom ) 
 c if ICORV_PE < 0 
 c return - 1 
 c endif 
 c endif 
 
 c if BinaryData = * off 
 c eval from_ccsid = pePostLoc 
 c eval to_ccsid = pePostRem 
 c eval pToASCII = iconv_open ( dsTo : dsFrom ) 
 c if ICORV_PA < 0 
 c callp iconv_close ( pToEBCDIC ) 
 c return - 1 
 c endif 
 c endif 
 
 c eval from_ccsid = wwProtRem 
 c eval to_ccsid = wwProtLoc 
 c eval toEBCDIC = iconv_open ( dsTo : dsFrom ) 
 
 c if ICORV_E < 0 
 c if BinaryData = * off 
 c callp iconv_close ( pToEBCDIC ) 
 c callp iconv_close ( pToASCII ) 
 c endif 
 c return - 1 
 c endif 
 
 c eval from_ccsid = wwProtLoc 
 c eval to_ccsid = wwProtRem 
 c eval toASCII = iconv_open ( dsTo : dsFrom ) 
 
 c if ICORV_A < 0 
 c if BinaryData = * off 
 c callp iconv_close ( pToEBCDIC ) 
 c callp iconv_close ( pToASCII ) 
 c endif 
 c callp iconv_close ( toEBCDIC ) 
 c return - 1 
 c endif 
 
 c eval CCSIDs_set = * ON 
 
 c eval EBCDIC = wwProtLoc 
 c eval ASCII = wwProtRem 
 
 c callp http_dmsg ( 'New iconv ( ) objects set , ' 
 c + 'PostRem = ' 
 c + % trim ( % editc ( pePostRem : 'L' ) ) 
 c + ' . PostLoc = ' 
 c + % trim ( % editc ( pePostLoc : 'L' ) ) 
 c + ' . ProtRem = ' 
 c + % trim ( % editc ( wwProtRem : 'L' ) ) 
 c + ' . ProtLoc = ' 
 c + % trim ( % editc ( wwProtLoc : 'L' ) ) ) 
 
 c return 0 
 P E 
 
 
 P HTTP_SetfileCCSID ... 
 P B export 
 D HTTP_SetfileCCSID ... 
 D PI 
 D peCCSID 10I 0 value 
 c eval p_global = getGlobalPtr ( ) 
 c eval global . file_ccsid = peCCSID 
 c callp http_dmsg ( 'File CCSID changed to ' 
 c + % trim ( % editc ( peCCSID : 'L' ) ) ) 
 P E 
 
 
 P HTTP_xlate B export 
 D HTTP_xlate PI 10I 0 
 D peSize 10I 0 value 
 D peData 32766A options ( * varsize ) 
 D peDirection 1A const 
 
 c return CCSIDxlate ( peSize 
 c : % addr ( peData ) 
 c : peDirection ) 
 P E 
 
 
 P HTTP_xlatep B export 
 D HTTP_xlatep PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 
 c return CCSIDxlate ( peSize 
 c : peData 
 c : peDirection ) 
 P E 
 
 
 P CCSIDxlate B 
 D CCSIDxlate PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 
 D Size s 10U 0 
 D OutSize s 10U 0 
 
 c if CCSIDs_Set = * OFF 
 c if HTTP_SetCCSIDs ( HTTP_ASCII 
 c : HTTP_EBCDIC ) < 0 
 c return - 1 
 c endif 
 c endif 
 
 c eval Size = peSize 
 c eval OutSize = peSize 
 
 c if peDirection = TO_ASCII 
 c callp iconv ( ToASCII 
 c : peData 
 c : Size 
 c : peData 
 c : OutSize ) 
 c else 
 c callp iconv ( ToEBCDIC 
 c : peData 
 c : Size 
 c : peData 
 c : OutSize ) 
 c endif 
 
 c return 0 
 P E 
 
 
 P FILE_CCSID B export 
 D FILE_CCSID PI 10I 0 
 c eval p_global = getGlobalPtr ( ) 
 c return global . file_ccsid 
 P E 
 
 
 P HTTP_xml_SetCCSIDs ... 
 P B export 
 D HTTP_xml_SetCCSIDs ... 
 D PI 10I 0 
 D peRemote 10I 0 value 
 D peLocal 10I 0 value 
 
 c if Xml_CCSID_Set = * ON 
 c callp iconv_close ( xmlEBCDIC ) 
 c endif 
 
 c eval from_ccsid = peRemote 
 c eval to_ccsid = peLocal 
 c eval xmlEBCDIC = iconv_open ( dsTo : dsFrom ) 
 
 c if ICORV_X < 0 
 c return - 1 
 c endif 
 
 c eval Xml_CCSID_set = * ON 
 
 c eval xml_EBCDIC = peLocal 
 c eval xml_ASCII = peRemote 
 
 c callp http_dmsg ( 'New XML iconv ( ) objects set , ' 
 c + 'xml_Remote = ' 
 c + % trim ( % editc ( peRemote : 'L' ) ) 
 c + ' . xml_Local = ' 
 c + % trim ( % editc ( peLocal : 'L' ) ) ) 
 
 c return 0 
 P E 
 
 
 P xml_xlate B export 
 D xml_xlate PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peOutBuf * 
 
 c if Xml_CCSID_Set = * OFF 
 c if HTTP_xml_SetCCSIDs ( 819 : 1208 ) < 0 
 c return - 1 
 c endif 
 c endif 
 
 c return iconvdyn ( peSize 
 c : peData 
 c : xmlEBCDIC 
 c : peOutbuf ) 
 P E 
 
 
 P HTTP_xlatedyn B export 
 D HTTP_xlatedyn PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D peOutput * 
 c if BinaryData = * on 
 c return BinaryCopy ( peSize 
 c : peData 
 c : peOutput ) 
 c else 
 c return CCSIDXLateDyn ( peSize 
 c : peData 
 c : peDirection 
 c : peOutput ) 
 c endif 
 P E 
 
 
 P CCSIDXlateDyn B 
 D CCSIDXlateDyn PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDirection 1A const 
 D peOutbuf * 
 
 D desc s like ( ToAscii ) 
 
 c if CCSIDs_Set = * OFF 
 c if HTTP_SetCCSIDs ( HTTP_ASCII 
 c : HTTP_EBCDIC ) < 0 
 c return - 1 
 c endif 
 c endif 
 
 c if peDirection = TO_ASCII 
 c eval desc = pToAscii 
 c else 
 c eval desc = pToEbcdic 
 c endif 
 
 c return iconvdyn ( peSize 
 c : peData 
 c : desc 
 c : peOutBuf ) 
 
 c return - 1 
 P E 
 
 
 P new_iconv b export 
 D new_iconv PI 52a 
 D peFrom 10i 0 value 
 D peTo 10i 0 value 
 
 D Result DS 
 D RC 10I 0 
 D Xlate 10I 0 dim ( 12 ) 
 
 c eval from_ccsid = peFrom 
 c eval to_ccsid = peTo 
 
 c eval Result = iconv_open ( dsTo : dsFrom ) 
 
 c if RC < 0 
 c callp SetError ( HTTP_CONVERR 
 c : 'iconv_open failed : ' 
 c + % str ( strerror ( errno ) ) ) 
 c callp http_crash 
 c return * blanks 
 c endif 
 
 c return Result 
 P E 
 
 P iconvdyn B export 
 D iconvdyn PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peDesc 52a 
 D peOutbuf * 
 
 D len s 10I 0 
 
 D insize s 10U 0 
 D desc s like ( ToAscii ) 
 D p_outbuf s * 
 D size s 10U 0 
 D spaceleft s 10U 0 
 D GROW_CHUNK C const ( 65536 ) 
 
 D ds 
 D rcU 10U 0 
 D rcI 10I 0 overlay ( rcU ) 
 
 c eval insize = peSize 
 c eval size = insize 
 c eval peOutbuf = xalloc ( size ) 
 c eval p_outbuf = peOutbuf 
 c eval spaceleft = size 
 
 c dow '1' 
 
 c eval rcU = iconv ( peDesc 
 c : peData 
 c : insize 
 c : p_outbuf 
 c : spaceleft ) 
 
 c if rcI >= 0 
 c leave 
 c endif 
 
 c if errno <> E2BIG 
 c callp SetError ( HTTP_CONVERR 
 c : 'CCSID conversion failed : ' 
 c + % str ( strerror ( errno ) ) ) 
 c callp xdealloc ( peOutbuf ) 
 c return - 1 
 c endif 
 
 c eval size = size + GROW_CHUNK 
 c eval len = p_outbuf - peOutbuf 
 c eval peOutbuf = xrealloc ( peOutbuf : size ) 
 c eval p_outbuf = peOutbuf + len 
 c eval spaceleft = size - len 
 
 c enddo 
 
 c eval len = size - spaceleft 
 
 c return len 
 P E 
 
 
 P close_iconv b export 
 D close_iconv PI 
 D This 52a value 
 C callp iconv_close ( This ) 
 P E 
 
 
 P xlate_symbols B 
 D xlate_symbols PI 25a 
 
 D Ucs2Symbols ds 
 D Slash 2a inz ( x'002F' ) 
 D Lt 2a inz ( x'003C' ) 
 D Gt 2a inz ( x'003E' ) 
 D Amp 2a inz ( x'0026' ) 
 D Question 2a inz ( x'003F' ) 
 D Plus 2a inz ( x'002B' ) 
 D Pct 2a inz ( x'0025' ) 
 D Equal 2a inz ( x'003D' ) 
 D At 2a inz ( x'0040' ) 
 D DblQuote 2a inz ( x'0022' ) 
 D SngQuote 2a inz ( x'0027' ) 
 D Comma 2a inz ( x'002C' ) 
 D SemiColon 2a inz ( x'003B' ) 
 D Colon 2a inz ( x'003A' ) 
 D Dollar 2a inz ( x'0024' ) 
 D Pound 2a inz ( x'0023' ) 
 D BackSlash 2a inz ( x'005C' ) 
 D LSQB 2a inz ( x'005B' ) 
 D RSQB 2a inz ( x'005D' ) 
 D LBRACE 2a inz ( x'007B' ) 
 D RBRACE 2a inz ( x'007D' ) 
 D Caret 2a inz ( x'005E' ) 
 D BackTick 2a inz ( x'0060' ) 
 D Pipe 2a inz ( x'007C' ) 
 D Tilde 2a inz ( x'007E' ) 
 
 D Table DS 
 D RC 10I 0 
 D Xlate 10I 0 dim ( 12 ) 
 
 D Result s 25a inz ( ' /<>&?+%=@ " '' , ; :$#\ [ ] { } ^ ` |~ ' ) 
 D Temp s 25a based ( p_Temp ) 
 D Len s 10i 0 
 
 c eval from_ccsid = 13488 
 c eval to_ccsid = 0 
 
 c eval Table = iconv_open ( dsTo : dsFrom ) 
 c if RC < 0 
 c return Result 
 c endif 
 
 C eval Len = iconvdyn ( % size ( Ucs2Symbols ) 
 C : % addr ( Ucs2Symbols ) 
 C : Table 
 C : p_Temp ) 
 C eval Result = Temp 
 c callp xdealloc ( p_Temp ) 
 
 C callp iconv_close ( Table ) 
 
 C return Result 
 P E 
 
 
 P get_symbols b export 
 D get_symbols PI 25a 
 D done s 1n static inz ( * OFF ) 
 D symbols s 25a static 
 C if not done 
 c eval symbols = xlate_symbols 
 c eval done = * on 
 c endif 
 c return symbols 
 P E 
 
 
 P BinaryCopy B 
 D PI 10I 0 
 D peSize 10I 0 value 
 D peData * value 
 D peOutbuf * 
 
 c if peSize < 1 
 c return - 1 
 c endif 
 
 c eval peOutbuf = xalloc ( peSize ) 
 c callp memcpy ( peOutBuf : peData : peSize ) 
 c return peSize 
 
 P E 
 
 / define ERRNO_LOAD_PROCEDURE 
 / copy errno_h 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * SRCSTMT : * NOSHOWCPY ) 
 / endif 
 H NOMAIN 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy httpapi_h 
 / copy socket_h 
 / copy gskssl_h 
 / copy errno_h 
 / copy private_h 
 
 D p_CommSSL s * 
 D CommSSL ds based ( p_CommSSL ) 
 D p_Resolve ... 
 D * procptr 
 D p_Connect ... 
 D * procptr 
 D p_Upgrade ... 
 D * procptr 
 D p_Read ... 
 D * procptr 
 D p_BlockRead ... 
 D * procptr 
 D p_BlockWrite ... 
 D * procptr 
 D p_LineRead ... 
 D * procptr 
 D p_LineWrite ... 
 D * procptr 
 D p_Hangup ... 
 D * procptr 
 D p_Cleanup ... 
 D * procptr 
 D fd 10I 0 
 D bufSize 10u 0 
 D bufLen 10u 0 
 D sslmode 1n 
 D 3a 
 D bufBase * 
 D bufCurr * 
 D sslh * 
 
 
 D CommSSL_New PR * 
 
 D CommSSL_Resolve ... 
 D PR * 
 D peHandle * value 
 D peHost * value options ( * string ) 
 D peService * value options ( * string ) 
 D pePort 10I 0 value 
 D peForced 1N const 
 
 D CommSSL_Connect ... 
 D PR 1N 
 D peHandle * value 
 D peSockaddr * value 
 D peTimeout 10P 3 value 
 
 D CommSSL_Upgrade ... 
 D PR 1N 
 D peHandle * value 
 D peTimeout 10P 3 value 
 D peEndHost * value options ( * string ) 
 
 D CommSSL_Read ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommSSL_BlockRead ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommSSL_BlockWrite ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommSSL_LineRead ... 
 D PR 10I 0 
 D handle * value 
 D buffer * value 
 D bufsize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommSSL_LineWrite ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peBufSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommSSL_Hangup ... 
 D PR 1N 
 D peHandle * value 
 
 D CommSSL_Cleanup ... 
 D PR 1N 
 D peHandle * value 
 
 D ssl_error PR 256A 
 D peErr 10I 0 value 
 
 D SSL_protocol PR 20A varying 
 D peHandle like ( gsk_handle ) value 
 D peVersion like ( GSK_ENUM_ID ) 
 D options ( * omit ) 
 
 D SSL_force_protocol ... 
 D PR 1N 
 D peHandle like ( gsk_handle ) value 
 D peSSLv2 1N const 
 D peSSLv3 1N const 
 D peTLSv10 1N const 
 
 D TLS_force_protocol ... 
 D PR 1N 
 D peHandle like ( gsk_handle ) value 
 D peTLSv10 1N const 
 D peTLSv11 1N const 
 D peTLSv12 1N const 
 D peTLSv13 1N const 
 
 D TLS_set_version ... 
 D PR 1N 
 D peHandle like ( gsk_handle ) value 
 D peVersion like ( GSK_ENUM_ID ) value 
 D peValue 1N const 
 
 D gskit_cleanup PR 
 D peAgMark 10U 0 
 D peReason 10U 0 
 D peResult 10U 0 
 D peUserRc 10U 0 
 
 D https_connect PR 10I 0 
 D peSockAddr * value 
 D peTimeout 10I 0 value 
 D peSSLh * 
 
 D https_close PR 10I 0 
 D peSSLh like ( gsk_handle ) value 
 
 D SSL_debug_cert_info ... 
 D PR 
 D peSSLh like ( GSK_HANDLE ) value 
 D peInfoID 10I 0 value 
 D SSL_debug_cert_body ... 
 D PR 
 d peBody * value 
 D peLen 10I 0 value 
 D SSL_debug_cert_elem ... 
 D PR 
 D peElemNo 10I 0 value 
 D peData * value 
 D peLen 10I 0 value 
 D SSL_validate_cert ... 
 D PR 10i 0 
 D peSSLh like ( GSK_HANDLE ) value 
 D SSL_get_proto PR 
 D peValue 10a dim ( 10 ) 
 
 D refill PR 10i 0 
 D peTimeout 10P 3 value 
 
 D wkEnvH s * inz ( * NULL ) 
 D wkFullAuth s 1n inz ( * OFF ) 
 D wkValProc s * inz ( * null ) procptr 
 D wkValUsrDta s * inz ( * null ) 
 D wkGskValProc s * inz ( * null ) procptr 
 D wkGskValUsrDta s * inz ( * null ) 
 D HTTP_DEBUG_LEVEL ... 
 D s 10i 0 inz ( 1 ) 
 
 D Kdb ds qualified 
 D Override 1n inz ( * off ) 
 D Path 256a varying inz ( '' ) 
 D Label 256a varying inz ( '' ) 
 D Password 256a varying inz ( '' ) 
 
 P CommSSL_New B export 
 D CommSSL_New PI * 
 
 C eval p_CommSSL = xalloc ( % size ( CommSSL ) ) 
 
 c eval CommSSL = * ALLx'00' 
 c eval p_Read =% paddr ( 'COMMTCP_READ' ) 
 c eval p_BlockRead =% paddr ( 'COMMTCP_BLOCKREAD' ) 
 c eval p_BlockWrite =% paddr ( 'COMMTCP_BLOCKWRITE' ) 
 c eval p_LineRead =% paddr ( 'COMMTCP_LINEREAD' ) 
 c eval p_LineWrite =% paddr ( 'COMMTCP_LINEWRITE' ) 
 c eval p_Hangup =% paddr ( 'COMMTCP_HANGUP' ) 
 c eval p_Resolve =% paddr ( 'COMMSSL_RESOLVE' ) 
 c eval p_Connect =% paddr ( 'COMMSSL_CONNECT' ) 
 c eval p_Upgrade =% paddr ( 'COMMSSL_UPGRADE' ) 
 c eval p_Cleanup =% paddr ( 'COMMSSL_CLEANUP' ) 
 c eval fd = - 1 
 c eval sslh = * NULL 
 c eval sslmode = * off 
 
 c eval bufSize = 131072 
 c eval bufBase = xalloc ( bufSize ) 
 c eval bufLen = 0 
 c eval bufCurr = bufBase 
 
 c eval HTTP_DEBUG_LEVEL = getDebugLevel ( ) 
 c return p_CommSSL 
 P E 
 
 P CommSSL_Resolve ... 
 P B export 
 D PI * 
 D peHandle * value 
 D peHost * value options ( * string ) 
 D peService * value options ( * string ) 
 D pePort 10I 0 value 
 D peForced 1N const 
 
 c return CommTcp_Resolve ( peHandle 
 c : peHost 
 c : peService 
 c : pePort 
 c : peForced ) 
 P E 
 
 P CommSSL_Connect ... 
 P B export 
 D CommSSL_Connect ... 
 D PI 1N 
 D peHandle * value 
 D peSockaddr * value 
 D peTimeout 10P 3 value 
 
 D s S 10I 0 
 
 c eval p_CommSSL = peHandle 
 
 c if wkEnvH = * NULL 
 c if https_init ( * blanks ) = - 1 
 c return * OFF 
 c endif 
 c endif 
 
 c eval s = CommTCP_ConnectNonBlock ( peSockAddr 
 c : peTimeout ) 
 C if s < 0 
 c return * OFF 
 c endif 
 
 c eval fd = s 
 C return * ON 
 P E 
 
 
 P CommSSL_Upgrade ... 
 P B export 
 D CommSSL_Upgrade ... 
 D PI 1N 
 D peHandle * value 
 D peTimeout 10P 3 value 
 D peEndHost * value options ( * string ) 
 
 D s S 10I 0 
 D wwfds S like ( fdset ) 
 D wwFlags S 10U 0 
 D wwBufSize s 10I 0 
 D wwTV s like ( timeval ) 
 D wwSSLh s * 
 D rc S 10I 0 
 D wwValCode s 10I 0 
 D wwSniHost s 256a inz ( * blanks ) 
 
 c eval p_CommSSL = peHandle 
 c eval s = fd 
 
 c if % parms >= 3 and peEndHost <> * null 
 c eval wwSniHost = % str ( peEndHost ) 
 c endif 
 
 c eval rc = gsk_secure_soc_open ( wkEnvH : wwSSLh ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSOPEN : 'gsk_sec_soc_open : ' + 
 c ssl_error ( rc ) ) 
 c callp close ( s ) 
 c return * OFF 
 c endif 
 
 c eval rc = gsk_attribute_set_numeric_value ( 
 c wwSSLh : GSK_HANDSHAKE_TIMEOUT : peTimeout ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSSNTO : 'Setting timeout : ' + 
 c ssl_error ( rc ) ) 
 c callp close ( s ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 
 c eval rc = gsk_attribute_set_numeric_value ( 
 c wwSSLh : GSK_IBMI_READ_TIMEOUT : 
 c peTimeout * 1000 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSSNTO : 'Setting timeout : ' + 
 c ssl_error ( rc ) ) 
 c callp close ( s ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 
 c eval rc = gsk_attribute_set_numeric_value ( 
 c wwSslh : GSK_FD : s ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSSNFD : 'Setting fd : ' + 
 c ssl_error ( rc ) ) 
 c callp close ( s ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 
 c if wwSniHost <> * blanks 
 c eval rc = gsk_attribute_set_buffer ( wwSSLh 
 c : GSK_SSL_EXTN_SERVERNAME_REQUEST 
 c : % trim ( wwSniHost ) 
 c : % len ( % trim ( wwSniHost ) ) ) 
 c if rc = GSK_OK 
 c callp http_dmsg ( 'SNI hostname set to : ' 
 c + % trim ( wwSniHost ) ) 
 c else 
 c callp http_dmsg ( 'SNI hostname error : ' 
 c + ssl_error ( rc ) ) 
 c callp http_dmsg ( 'NOTE : SNI errors are not ' 
 c + 'usually fatal . ' ) 
 c endif 
 c endif 
 
 c eval rc = gsk_secure_soc_init ( wwSslh ) 
 c if rc <> GSK_OK 
 c if rc = GSK_IBMI_ERROR_TIMED_OUT 
 c callp SetError ( HTTP_SSTIMO : 'Time out during ' + 
 c 'SSL handshake' ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 c callp SetError ( HTTP_SSSNFD : 'SSL Handshake : ' + 
 c ssl_error ( rc ) ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' ---- ' ) 
 
 c callp http_dmsg ( 'Dump of server - side certifi' + 
 c 'cate information : ' ) 
 
 c callp http_dmsg ( ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' ---- ' ) 
 
 c callp gsk_attribute_get_numeric_value ( 
 c wwSSlh : 
 c GSK_CERTIFICATE_VALIDATION_CODE : 
 c wwValCode ) 
 
 c callp http_dmsg ( 'Cert Validation Code = ' 
 c + % trim ( % editc ( wwValCode : 'L' ) ) ) 
 
 c callp SSL_debug_cert_info ( wwSslh 
 c : GSK_PARTNER_CERT_INFO ) 
 
 c if rc <> GSK_OK 
 c callp close ( s ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( 'Protocol Used : ' + 
 c SSL_protocol ( wwSSLh : * OMIT ) ) 
 
 
 c if SSL_validate_cert ( wwSSLh ) <> 0 
 c callp close ( s ) 
 c callp gsk_secure_soc_close ( wwsslh ) 
 c return * OFF 
 c endif 
 
 c eval p_Read =% paddr ( 'COMMSSL_READ' ) 
 c eval p_BlockRead =% paddr ( 'COMMSSL_BLOCKREAD' ) 
 c eval p_BlockWrite =% paddr ( 'COMMSSL_BLOCKWRITE' ) 
 c eval p_LineRead =% paddr ( 'COMMSSL_LINEREAD' ) 
 c eval p_LineWrite =% paddr ( 'COMMSSL_LINEWRITE' ) 
 c eval p_Hangup =% paddr ( 'COMMSSL_HANGUP' ) 
 c eval sslh = wwSSLh 
 
 c return * ON 
 P E 
 
 
 P CommSSL_Read ... 
 P B export 
 D CommSSL_Read ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwLen S 10I 0 
 
 c eval p_CommSSL = pehandle 
 
 c if refill ( peTimeout ) = - 1 
 c return - 1 
 c endif 
 
 c eval wwLen = peSize 
 c if wwLen > bufLen 
 c eval wwLen = bufLen 
 c endif 
 
 c callp memcpy ( peBuffer : bufCurr : wwLen ) 
 c eval bufLen = bufLen - wwLen 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + wwLen 
 c endif 
 
 c callp http_dwrite ( peBuffer : wwLen ) 
 c return wwLen 
 P E 
 
 
 P CommSSL_BlockRead ... 
 P B export 
 D CommSSL_BlockRead ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwLen s 10I 0 
 D wwRec s 10I 0 
 
 c eval wwLen = 0 
 
 c dow peSize > 0 
 
 c eval wwRec = CommSSL_read ( peHandle 
 c : peBuffer 
 c : peSize 
 c : peTimeout ) 
 c if wwRec < 1 
 c if wwLen = 0 
 c return - 1 
 c else 
 c return wwLen 
 c endif 
 c endif 
 
 c eval wwLen = wwLen + wwRec 
 c eval peBuffer = peBuffer + wwRec 
 c eval peSize = peSize - wwRec 
 c enddo 
 
 c return wwLen 
 P E 
 
 
 P CommSSL_BlockWrite ... 
 P B export 
 D CommSSL_BlockWrite ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwPos S * 
 D wwDeref S 1A based ( wwPos ) 
 D wwLeft S 10I 0 
 D rc S 10I 0 
 D wwSent S 10I 0 
 D wwLen S 10I 0 
 
 / if defined ( USE_POLL ) 
 D pfd ds likeds ( pollfd_t ) dim ( 1 ) 
 / else 
 D wwFds S like ( fdset ) 
 D wwTimeout S 8A 
 / endif 
 
 c eval wwPos = peBuffer 
 c eval wwLeft = peSize 
 
 c dow wwLeft > 0 
 
 c if HTTP_DEBUG_LEVEL > 1 
 c callp socket_status ( 'CommSSL_BlockWrite' 
 c : 'gsk_secure_soc_write' 
 c : fd ) 
 c endif 
 
 c eval rc = gsk_secure_soc_write ( sslh : 
 c wwPos : wwLeft : wwLen ) 
 
 c if HTTP_DEBUG_LEVEL > 1 
 c callp http_dmsg ( 'CommSSL_BlockWrite ( ) : + 
 c gsk_secure_soc_write rc = ' + 
 c % char ( rc ) + ' , len = ' + % char ( wwLen ) ) 
 c endif 
 
 c if rc <> GSK_OK 
 
 c if rc <> GSK_WOULD_BLOCK 
 c callp SetError ( HTTP_BWSEND 
 c : 'CommSSL_BlockWrite : send : ' 
 c + ssl_error ( rc ) ) 
 c return - 1 
 c endif 
 
 / if defined ( USE_POLL ) 
 c eval pfd ( 1 ) = * ALLx'00' 
 c eval pfd ( 1 ) . fd = fd 
 c eval pfd ( 1 ) . events = POLLOUT 
 
 c eval rc = poll ( pfd : 1 : peTimeout * 1000 ) 
 
 c if rc < 0 
 c callp SetError ( HTTP_BWSELE 
 c : 'CommSSL_BlockWrite : poll : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if rc = 0 
 c callp SetError ( HTTP_BWTIMO 
 c : 'CommSSL_BlockWrite : ' 
 c + 'timeout ! ' ) 
 c return - 1 
 c endif 
 
 / else 
 c eval p_timeval = % addr ( wwTimeout ) 
 c eval tv_sec = peTimeout 
 c eval tv_usec = ( peTimeout - tv_sec ) * 1000000 
 
 c callp CommTCP_FD_ZERO ( wwfds ) 
 c callp CommTCP_FD_SET ( fd : wwfds ) 
 
 c if HTTP_DEBUG_LEVEL > 1 
 c callp select_status ( 'CommSSL_BlockWrite' 
 c : 'before select' 
 c : fd 
 c : * null 
 c : % addr ( wwfds ) 
 c : * null 
 c : % addr ( wwTimeout ) ) 
 c endif 
 
 
 c eval rc = select ( fd + 1 : * NULL : % addr ( wwFds ) : 
 c * NULL : % addr ( wwTimeout ) ) 
 
 c if HTTP_DEBUG_LEVEL > 1 
 c callp select_status ( 'CommSSL_BlockWrite' 
 c : 'after select' 
 c : fd 
 c : * null 
 c : % addr ( wwfds ) 
 c : * null 
 c : % addr ( wwTimeout ) 
 c : rc ) 
 c endif 
 
 c if rc < 0 
 c callp SetError ( HTTP_BWSELE 
 c : 'CommSSL_BlockWrite : select : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if CommTCP_FD_IsSet ( fd : wwfds ) = * Off 
 c callp SetError ( HTTP_BWTIMO 
 c : 'CommSSL_BlockWrite : ' 
 c + 'timeout ! ' ) 
 c return - 1 
 c endif 
 / endif 
 
 c iter 
 c endif 
 
 c callp http_dwrite ( wwPos : wwLen ) 
 
 c eval wwLeft = wwLeft - wwLen 
 c eval wwSent = wwSent + wwLen 
 
 c if wwLeft > 0 
 c eval wwPos = wwPos + wwLen 
 c endif 
 
 c enddo 
 
 c return wwSent 
 P E 
 
 P CommSSL_LineRead ... 
 P B export 
 D CommSSL_LineRead ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 d EOL c const ( x'0a' ) 
 d len s 10I 0 
 D left s 10i 0 
 D bufPos s * 
 D Pos s * 
 
 c if peSize <= 0 
 c return 0 
 c endif 
 
 c eval p_commSSL = peHandle 
 c eval len = 0 
 c eval left = peSize 
 c eval bufPos = peBuffer 
 
 c dow left > 0 
 
 c if refill ( peTimeout ) = - 1 
 c return - 1 
 c endif 
 
 c eval len = bufLen 
 c if len > left 
 c eval len = left 
 c endif 
 
 c eval pos = memchr ( bufCurr : EOL : len ) 
 c if pos <> * null 
 c eval len = ( pos - bufCurr ) + 1 
 c callp memcpy ( bufPos : bufCurr : len ) 
 c eval bufLen = bufLen - len 
 c eval left = left - len 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + len 
 c endif 
 c leave 
 c endif 
 
 c callp memcpy ( bufPos : bufCurr : len ) 
 c eval bufLen = bufLen - len 
 c eval bufPos = bufPos + len 
 c eval left = left - len 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + len 
 c endif 
 
 c enddo 
 
 c callp http_dwrite ( peBuffer : peSize - left ) 
 c return peSize - left 
 P E 
 
 P CommSSL_LineWrite ... 
 P B export 
 D CommSSL_LineWrite ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peBufSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D p_Buf s * 
 D p_EOL s * 
 D wwEOL s 2A based ( p_EOL ) 
 D rc s 10I 0 
 
 c eval p_Buf = xalloc ( peBufSize +% size ( wwEOL ) ) 
 c callp memcpy ( p_Buf : peBuffer : peBufSize ) 
 
 c eval p_EOL = p_Buf + peBufSize 
 c eval wwEOL = x'0d0a' 
 
 c eval rc = CommSSL_BlockWrite ( peHandle 
 c : p_buf 
 c : peBufSize +% size ( wwEOL ) 
 c : peTimeout ) 
 
 c callp xdealloc ( p_buf ) 
 c return rc 
 P E 
 
 P CommSSL_Hangup ... 
 P B export 
 D CommSSL_Hangup ... 
 D PI 1N 
 D peHandle * value 
 c eval p_CommSSL = peHandle 
 c callp gsk_secure_soc_close ( sslh ) 
 c callp close ( fd ) 
 c return * ON 
 P E 
 
 P CommSSL_Cleanup ... 
 P B export 
 D CommSSL_Cleanup ... 
 D PI 1N 
 D peHandle * value 
 c eval p_CommSSL = peHandle 
 c callp xdealloc ( bufBase ) 
 c 
 c callp ( e ) xdealloc ( peHandle ) 
 c if % error 
 c return * OFF 
 c else 
 c return * ON 
 c endif 
 P E 
 
 
 P https_certStore ... 
 P B export 
 D PI 
 D KdbPath 5000a varying const 
 D KdbPassword 256a varying const 
 D KdbLabel 5000a varying const 
 
 c if wkEnvH <> * null 
 c callp https_cleanup 
 c endif 
 
 C if KdbPath = ' * CLEAR' 
 c eval Kdb = * ALLx'00' 
 c eval Kdb . Override = * off 
 c else 
 C eval Kdb . Path = KdbPath 
 C eval Kdb . Password = KdbPassword 
 C eval Kdb . Label = KdbLabel 
 C eval Kdb . Override = * On 
 c endif 
 
 P E 
 
 
 P https_init B export 
 D https_init PI 10I 0 
 D peAppID 100A const 
 D peSSLv2 1N const options ( * nopass ) 
 D peSSLv3 1N const options ( * nopass ) 
 D peTLSv10 1N const options ( * nopass ) 
 D peTLSv11 1N const options ( * nopass ) 
 D peTLSv12 1N const options ( * nopass ) 
 D peTLSv13 1N const options ( * nopass ) 
 
 D LastAppId s 100A static inz ( * blanks ) 
 
 D FdBk ds inz 
 D sev 5u 0 
 D msgno 5u 0 
 D flags 1a 
 D facid 3a 
 D isi 10u 0 
 
 D CEE4RAGE PR 
 D procedure * procptr const 
 D feedback like ( fdbk ) options ( * omit ) 
 
 D CEESGL PR 
 D cond_rep like ( fdbk ) 
 D q_data_token 10i 0 const options ( * omit ) 
 D feedback like ( fdbk ) options ( * omit ) 
 
 D rc S 10I 0 
 D ssl_auth_type s 10i 0 
 
 D sslpcl s 10a dim ( 10 ) 
 D p s 10i 0 
 D pclmsg s 256a 
 
 D mySSLV2 s 1n inz ( * off ) 
 D mySSLV3 s 1n inz ( * off ) 
 D myTLSV10 s 1n inz ( * on ) 
 D myTLSV11 s 1n inz ( * on ) 
 D myTLSV12 s 1n inz ( * on ) 
 D myTLSV13 s 1n inz ( * on ) 
 
 c if % parms >= 2 
 c eval mySSLV2 = peSSLV2 
 c endif 
 
 c if % parms >= 3 
 c eval mySSLV3 = peSSLV3 
 c endif 
 
 c if % parms >= 4 
 c eval myTLSV10 = peTLSV10 
 c endif 
 
 c if % parms >= 5 
 c eval myTLSV11 = peTLSV11 
 c endif 
 
 c if % parms >= 6 
 c eval myTLSV12 = peTLSV12 
 c endif 
 
 c if % parms >= 7 
 c eval myTLSV13 = peTLSV13 
 c endif 
 
 c callp http_dmsg ( 'https_init ( ) : entered' ) 
 
 c if wkEnvH <> * NULL 
 c and peAppID <> LastAppId 
 c callp https_cleanup 
 c eval wkEnvH = * null 
 c endif 
 
 c if wkEnvH <> * NULL 
 c callp SetError ( HTTP_GSKENVI : 'SSL environment' + 
 c ' was already initialized ! ' ) 
 c return 0 
 c endif 
 
 c eval LastAppId = peAppId 
 
 c eval rc = gsk_environment_open ( wkEnvh ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKENVO : 'gsk_env_open : ' + 
 c ssl_error ( rc ) ) 
 c return - 1 
 c endif 
 
 C callp CEE4RAGE ( % paddr ( 'GSKIT_CLEANUP' ) : FdBk ) 
 c if sev <> 0 
 c if facid = 'CEE' and msgno = 12545 
 c callp util_diag ( 'HTTPAPI is running in ' + 
 c 'default activation group . ' + 
 c 'https_cleanup must be run explcitly . ' ) 
 c else 
 C callp CEESGL ( fdbk : * omit : * omit ) 
 c endif 
 c endif 
 
 c if kdb . Override = * on 
 
 c callp http_dmsg ( 'Overriding to alternate + 
 c certificate store ' + kdb . Path ) 
 
 c eval rc = gsk_attribute_set_buffer ( wkEnvH 
 c : GSK_KEYRING_FILE 
 c : kdb . Path 
 c : % len ( kdb . Path ) ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKKEYF : 'Attempt to use ' + 
 c kdb . Path + ' cert store : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 c if kdb . Password <> '' 
 c eval rc = gsk_attribute_set_buffer ( wkEnvH 
 c : GSK_KEYRING_PW 
 c : kdb . Password 
 c : % len ( kdb . Password ) ) 
 c if rc = GSK_OK 
 c callp http_dmsg ( ' - Keyring password + 
 c has been set . ' ) 
 c else 
 c callp SetError ( HTTP_GSKKEYF : 'Keyring PW : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c if kdb . Label <> '' 
 c eval rc = gsk_attribute_set_buffer ( wkEnvH 
 c : GSK_KEYRING_LABEL 
 c : kdb . Label 
 c : % len ( kdb . Label ) ) 
 c if rc = GSK_OK 
 c callp http_dmsg ( ' - Keyring certificate + 
 c label has been set . ' ) 
 c else 
 c callp SetError ( HTTP_GSKKEYF : 'Keyring Label : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c else 
 
 c if % subst ( peAppId : 1 : 1 ) = ' / ' 
 c eval rc = gsk_attribute_set_buffer ( 
 c wkEnvh : GSK_KEYRING_FILE : 
 c peAppId : % len ( % trim ( peAppId ) ) ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKKEYF : 'Attempt to use ' + 
 c % trim ( peAppId ) + ' cert store : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c if peAppId = * blanks 
 c eval rc = gsk_attribute_set_buffer ( 
 c wkEnvh : GSK_KEYRING_FILE : 
 c ' * SYSTEM' : 0 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKKEYF : 'Attempt to use ' + 
 c ' * SYSTEM cert store : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c if peAppID <> * blanks 
 c and % subst ( peAppId : 1 : 1 ) <> ' / ' 
 c eval rc = gsk_attribute_set_buffer ( 
 c wkEnvh : GSK_IBMI_APPLICATION_ID : 
 c % trimr ( peAppID ) : 0 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKAPPID : 'Setting ID : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( wkEnvh : 
 c GSK_SESSION_TYPE : GSK_CLIENT_SESSION ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKSTYP : 'Setting ' + 
 c 'session type : ' + ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 c if wkFullAuth = * ON 
 c eval ssl_auth_type = GSK_SERVER_AUTH_FULL 
 c else 
 c eval ssl_auth_type = GSK_SERVER_AUTH_PASSTHRU 
 c endif 
 
 
 c eval rc = gsk_attribute_set_enum ( wkEnvh 
 c : GSK_SERVER_AUTH_TYPE 
 c : ssl_auth_type ) 
 c if rc <> GSK_OK 
 c and rc <> GSK_ATTRIBUTE_INVALID_ID 
 c callp SetError ( HTTP_GSKATYP : 'Setting ' + 
 c 'auth type : ' + ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 c if wkFullAuth = * ON 
 c eval ssl_auth_type = GSK_CLIENT_AUTH_FULL 
 c else 
 c eval ssl_auth_type = GSK_CLIENT_AUTH_PASSTHRU 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( wkEnvh 
 c : GSK_CLIENT_AUTH_TYPE 
 c : ssl_auth_type ) 
 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_GSKATYP : 'Setting ' + 
 c 'auth type : ' + ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 c eval pclmsg = 'QSSLPCL = ' 
 c callp SSL_get_proto ( sslpcl ) 
 c for p = 1 to % elem ( sslpcl ) 
 c if sslpcl ( p ) <> * blanks 
 c eval pclmsg = % trimr ( pclmsg ) + ' ' 
 c + sslpcl ( p ) 
 c endif 
 c endfor 
 
 c callp http_dmsg ( pclmsg ) 
 
 c if SSL_force_protocol ( wkEnvh 
 c : mySSLv2 
 c : mySSLv3 
 c : myTLSv10 ) = * OFF 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 c if TLS_force_protocol ( wkEnvh 
 c : myTLSv10 
 c : myTLSv11 
 c : myTLSv12 
 c : myTLSv13 ) = * OFF 
 c callp https_cleanup 
 c return - 1 
 c endif 
 
 / if defined ( V5R3_GSKIT ) 
 c if wkGskValUsrDta <> * null 
 c callp gsk_attribute_set_callback ( wkEnvh 
 c : GSK_CERT_VALIDATION_CALLBACK 
 c : wkGskValUsrDta ) 
 c endif 
 / endif 
 
 c callp http_dmsg ( 'initializing GSK environment' ) 
 
 c eval rc = gsk_environment_init ( wkEnvh ) 
 c if rc <> GSK_OK 
 c if rc = GSK_IBMI_ERROR_NOT_REGISTERED 
 c callp SetError ( HTTP_NOTREG : 'Application ' + 
 c 'is not registered with DCM ! ' ) 
 c callp https_cleanup 
 c return - 1 
 c else 
 c callp SetError ( HTTP_GSKATYP : 'gsk_env_init : ' + 
 c ssl_error ( rc ) ) 
 c callp https_cleanup 
 c return - 1 
 c endif 
 c endif 
 
 c callp http_dmsg ( 'GSK Environment now available' ) 
 
 c callp http_dmsg ( ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' ---- ' ) 
 
 c callp http_dmsg ( 'Dump of local - side certific' + 
 c 'ate information : ' ) 
 
 c callp http_dmsg ( ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' --------------------------- ' + 
 c ' ---- ' ) 
 
 c callp SSL_debug_cert_info ( wkEnvh 
 c : GSK_LOCAL_CERT_INFO ) 
 
 c if rc = GSK_OK 
 c return 0 
 c else 
 c callp https_cleanup 
 c return - 1 
 c endif 
 P E 
 
 P https_dcm_reg B export 
 D https_dcm_reg PI 10I 0 
 D peAppID 100A const 
 D peLimitCA 1N const 
 
 D QSYRGAP PR ExtPgm ( 'QSYRGAP' ) 
 D ApplicID 100A options ( * varsize ) 
 D ApplicIDLen 10I 0 const 
 D ApplicCtrls 256A const 
 D ErrorCode 32766A options ( * varsize ) 
 
 D p_RGAP_DS1 S * 
 D RGAP_DS1 DS BASED ( p_RGAP_DS1 ) 
 D RGAP_DS1_VarRecLen ... 
 D 10I 0 
 D RGAP_DS1_AppCtrlKey ... 
 D 10I 0 
 D RGAP_DS1_DataLen ... 
 D 10I 0 
 D RGAP_DS1_Data ... 
 D 50A 
 
 D RGAP_QEXITPGM C 1 
 D RGAP_APPTEXT C 2 
 D RGAP_QMSGF C 3 
 D RGAP_LIMITCA C 4 
 D RGAP_REPLACE C 5 
 D RGAP_THRSAFE C 6 
 D RGAP_THRACTN C 7 
 D RGAP_APPTYPE C 8 
 
 D SERVER C '1' 
 D CLIENT C '2' 
 
 D wwAppID S 100A 
 D wwAppIDLen S 10I 0 
 D wwBuf s 100A 
 D p_NumKeys S * 
 D wwNumKeys S 10I 0 based ( p_NumKeys ) 
 
 D dsEC DS 
 D dsECBytesP 1 4I 0 INZ ( 256 ) 
 D dsECBytesA 5 8I 0 INZ ( 0 ) 
 D dsECMsgID 9 15 
 D dsECReserv 16 16 
 D dsECMsgDta 17 256 
 c callp http_dmsg ( 'https_dcm_reg ( ) : entered' ) 
 
 c eval p_NumKeys = % addr ( wwBuf ) 
 c eval wwNumKeys = 0 
 
 c eval wwNumKeys = wwNumKeys + 1 
 c eval p_RGAP_DS1 = % addr ( wwBuf ) + 4 
 c eval RGAP_DS1_VarRecLen = 13 
 c eval RGAP_DS1_AppCtrlKey = RGAP_LIMITCA 
 c eval RGAP_DS1_DataLen = 1 
 c eval % subst ( RGAP_DS1_Data : 1 : 1 ) = peLimitCA 
 
 c eval wwNumKeys = wwNumKeys + 1 
 c eval p_RGAP_DS1 = % addr ( wwBuf ) + 17 
 c eval RGAP_DS1_VarRecLen = 13 
 c eval RGAP_DS1_AppCtrlKey = RGAP_REPLACE 
 c eval RGAP_DS1_DataLen = 1 
 c eval % subst ( RGAP_DS1_Data : 1 : 1 ) = '1' 
 
 / if not defined ( V4R5_GSKIT ) 
 c eval wwNumKeys = wwNumKeys + 1 
 c eval p_RGAP_DS1 = % addr ( wwBuf ) + 30 
 c eval RGAP_DS1_VarRecLen = 13 
 c eval RGAP_DS1_AppCtrlKey = RGAP_APPTYPE 
 c eval RGAP_DS1_DataLen = 1 
 c eval % subst ( RGAP_DS1_Data : 1 : 1 ) = CLIENT 
 / endif 
 
 c eval wwAppId = % triml ( peAppId ) 
 c eval wwAppIdLen = % len ( % trimr ( wwAppId ) ) 
 c callp ( e ) QSYRGAP ( wwAppID : wwAppIdLen : wwBuf : dsEC ) 
 c if % error 
 c callp SetError ( HTTP_REGERR : 'Failure trying ' + 
 c 'to register app . See job log' ) 
 c return - 1 
 c endif 
 c if dsECBytesA > 0 
 c callp SetError ( HTTP_REGERR : 'Register App ' + 
 c 'failed with ' + dsECMsgID ) 
 c return - 1 
 c endif 
 
 c return 0 
 P E 
 
 P ssl_error B 
 D ssl_error PI 256A 
 D peErr 10I 0 value 
 
 D wwMsg S 256A 
 
 c select 
 c when peErr = GSK_OK 
 c eval wwMsg = 'No error' 
 c when peErr = GSK_ERROR_IO 
 c eval wwMsg = ' ( GSKit ) I / O : ' + 
 c % str ( strerror ( errno ) ) 
 c callp util_diag ( wwMsg ) 
 c other 
 / if defined ( V4R5_GSKIT ) 
 c eval wwMsg = 'GSKit error # ' + 
 c % trim ( % editc ( peErr : 'P' ) ) 
 c callp util_diag ( wwMsg ) 
 / else 
 c eval wwMsg = ' ( GSKit ) ' + 
 c % str ( gsk_strerror ( peErr ) ) 
 c callp util_diag ( wwMsg ) 
 / endif 
 c endsl 
 
 c callp http_dmsg ( 'ssl_error ( ' + 
 c % trim ( % editc ( peErr : 'P' ) ) + 
 c ' ) : ' + wwMsg ) 
 
 c return wwMsg 
 P E 
 
 
 P SSL_protocol B 
 D SSL_protocol PI 20A varying 
 D peHandle like ( gsk_handle ) value 
 D peVersion like ( GSK_ENUM_ID ) 
 D options ( * omit ) 
 
 D wwName s 20A varying 
 D wwVersion s like ( GSK_ENUM_VALUE ) 
 D rc s 10I 0 
 
 c eval rc = gsk_attribute_get_enum ( peHandle : 
 c GSK_PROTOCOL_USED : 
 c wwVersion ) 
 c select 
 c when rc <> GSK_OK 
 c callp SetError ( HTTP_SSPROT : 'SSL_protocol : ' + 
 c ssl_error ( rc ) ) 
 c return '' 
 c when wwVersion = GSK_PROTOCOL_USED_SSLV2 
 c eval wwName = 'SSL Version 2' 
 c when wwVersion = GSK_PROTOCOL_USED_SSLV3 
 c eval wwName = 'SSL Version 3' 
 c when wwVersion = GSK_PROTOCOL_USED_TLSV1 
 c eval wwName = 'TLS Version 1 . 0' 
 c when wwVersion = GSK_PROTOCOL_USED_TLSV11 
 c eval wwName = 'TLS Version 1 . 1' 
 c when wwVersion = GSK_PROTOCOL_USED_TLSV12 
 c eval wwName = 'TLS Version 1 . 2' 
 c when wwVersion = GSK_PROTOCOL_USED_TLSV13 
 c eval wwName = 'TLS Version 1 . 3' 
 c other 
 c callp SetError ( HTTP_SSPUNK : 'SSL_protocol : ' + 
 c 'Unknown protocol ' + 
 c % trim ( % editc ( wwVersion : 'Z' ) ) ) 
 c return '' 
 c endsl 
 
 c if % addr ( peVersion ) <> * NULL 
 c eval peVersion = wwVersion 
 c endif 
 
 c return wwName 
 P E 
 
 P SSL_force_protocol ... 
 P B 
 D SSL_force_protocol ... 
 D PI 1N 
 D peHandle like ( gsk_handle ) value 
 D peSSLv2 1N const 
 D peSSLv3 1N const 
 D peTLSv10 1N const 
 
 D rc s 10I 0 
 D wwSSLv2 s like ( GSK_ENUM_VALUE ) 
 D wwSSLv3 s like ( GSK_ENUM_VALUE ) 
 D wwTLSv10 s like ( GSK_ENUM_VALUE ) 
 D myAction s 8a 
 
 c if peSSLv2 = * ON 
 c eval wwSSLv2 = GSK_PROTOCOL_SSLV2_ON 
 c eval myAction = 'enabled' 
 c else 
 c eval wwSSLv2 = GSK_PROTOCOL_SSLV2_OFF 
 c eval myAction = 'disabled' 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( peHandle : 
 c GSK_PROTOCOL_SSLV2 : 
 c wwSSLv2 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSPSET : SSL_error ( rc ) ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( 'SSL version 2' 
 c + ' support ' 
 c + % trim ( myAction ) ) 
 
 c if peSSLv3 = * ON 
 c eval wwSSLv3 = GSK_PROTOCOL_SSLV3_ON 
 c eval myAction = 'enabled' 
 c else 
 c eval wwSSLv3 = GSK_PROTOCOL_SSLV3_OFF 
 c eval myAction = 'disabled' 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( peHandle : 
 c GSK_PROTOCOL_SSLV3 : 
 c wwSSLv3 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSPSET : SSL_error ( rc ) ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( 'SSL version 3' 
 c + ' support ' 
 c + % trim ( myAction ) ) 
 
 c if peTLSv10 = * ON 
 c eval wwTLSv10 = GSK_PROTOCOL_TLSV1_ON 
 c eval myAction = 'enabled' 
 c else 
 c eval wwTLSv10 = GSK_PROTOCOL_TLSV1_OFF 
 c eval myAction = 'disabled' 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( peHandle : 
 c GSK_PROTOCOL_TLSV1 : 
 c wwTLSv10 ) 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_SSPSET : SSL_error ( rc ) ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( 'Old interface to ' 
 c + 'TLS version 1 . 0 support ' 
 c + % trim ( myAction ) ) 
 
 c return * ON 
 P E 
 
 P TLS_force_protocol ... 
 P B 
 D PI 1N 
 D peHandle like ( gsk_handle ) value 
 D peTLSv10 1N const 
 D peTLSv11 1N const 
 D peTLSv12 1N const 
 D peTLSv13 1N const 
 
 C if TLS_set_version ( peHandle 
 C : GSK_PROTOCOL_TLSV10 
 c : peTLSv10 ) = * OFF 
 c return * OFF 
 c endif 
 
 C if TLS_set_version ( peHandle 
 C : GSK_PROTOCOL_TLSV11 
 c : peTLSv11 ) = * OFF 
 c return * OFF 
 c endif 
 
 C if TLS_set_version ( peHandle 
 C : GSK_PROTOCOL_TLSV12 
 c : peTLSv12 ) = * OFF 
 c return * OFF 
 c endif 
 
 C if TLS_set_version ( peHandle 
 C : GSK_PROTOCOL_TLSV13 
 c : peTLSv13 ) = * OFF 
 c return * OFF 
 c endif 
 
 c return * ON 
 P E 
 
 
 P TLS_set_version ... 
 P B 
 D PI 1N 
 D peHandle like ( gsk_handle ) value 
 D peVersion like ( GSK_ENUM_ID ) value 
 D peValue 1N const 
 
 D rc s 10I 0 
 D myVersion s 3a 
 D myAction s 8a 
 D myValue s like ( GSK_ENUM_VALUE ) 
 
 c select 
 c when peVersion = GSK_PROTOCOL_TLSV10 
 c eval myVersion = '1 . 0' 
 c when peVersion = GSK_PROTOCOL_TLSV11 
 c eval myVersion = '1 . 1' 
 c when peVersion = GSK_PROTOCOL_TLSV12 
 c eval myVersion = '1 . 2' 
 c when peVersion = GSK_PROTOCOL_TLSV13 
 c eval myVersion = '1 . 3' 
 c other 
 c callp SetError ( HTTP_TLSSET 
 c : 'Unknown TLS version' ) 
 c return * OFF 
 c endsl 
 
 c if peValue = * ON 
 c eval myValue = GSK_TRUE 
 c eval myAction = 'enabled' 
 c else 
 c eval myValue = GSK_FALSE 
 c eval myAction = 'disabled' 
 c endif 
 
 c eval rc = gsk_attribute_set_enum ( peHandle 
 c : peVersion 
 c : myValue ) 
 
 c if rc = GSK_ATTRIBUTE_INVALID_ID 
 c or rc = GSK_ERROR_UNSUPPORTED 
 c callp http_dmsg ( 'Support for TLS ' 
 c + % trim ( myVersion ) 
 c + ' unavailable . ' ) 
 c return * ON 
 c endif 
 
 c if rc <> GSK_OK 
 c callp SetError ( HTTP_TLSSET : SSL_error ( rc ) ) 
 c return * OFF 
 c endif 
 
 c callp http_dmsg ( 'TLS version ' 
 c + % trim ( myVersion ) 
 c + ' support ' 
 c + % trim ( myAction ) ) 
 
 c return * ON 
 p e 
 
 P gskit_cleanup B export 
 D gskit_cleanup PI 
 D peAgMark 10U 0 
 D peReason 10U 0 
 D peResult 10U 0 
 D peUserRc 10U 0 
 
 D rc s 10I 0 
 
 c if wkEnvH = * NULL 
 c eval peResult = 0 
 c return 
 c endif 
 
 c eval rc = gsk_environment_close ( wkEnvH ) 
 
 c if rc = GSK_OK 
 c eval wkEnvH = * NULL 
 c eval peResult = 0 
 c else 
 c eval peResult = 20 
 c endif 
 
 P E 
 
 
 P https_cleanup B export 
 D https_cleanup PI 10I 0 
 
 D wwAgMark s 10U 0 inz ( 0 ) 
 D wwReason s 10U 0 inz ( 0 ) 
 D wwResult s 10U 0 inz ( 21 ) 
 D wwUserRC s 10U 0 inz ( 0 ) 
 
 c if wkEnvH = * NULL 
 c return 0 
 c endif 
 
 c callp gskit_cleanup ( wwAgMark 
 c : wwReason 
 c : wwResult 
 c : wwUserRC ) 
 
 c if wwReason = 0 
 c return 0 
 c else 
 c return - 1 
 c endif 
 P E 
 
 
 P https_connect B export 
 D https_connect PI 10I 0 
 D peSockAddr * value 
 D peTimeout 10I 0 value 
 D peSSLh * 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This procedure is no ' 
 c + 'longer supported . ' ) 
 c return - 1 
 P E 
 
 
 P https_close B export 
 D https_close PI 10I 0 
 D peSSLh like ( gsk_handle ) value 
 c return 0 
 P E 
 
 
 P https_idname B export 
 D https_idname PI 50A varying 
 D peID 10I 0 value 
 c select 
 c when peID = CERT_BODY_DER 
 c return 'Body ( DER ) ' 
 c when peID = CERT_BODY_BASE64 
 c return 'Body ( base64 ) ' 
 c when peID = CERT_SERIAL_NUMBER 
 c return 'Serial Number' 
 c when peID = CERT_COMMON_NAME 
 c return 'Common Name' 
 c when peID = CERT_LOCALITY 
 c return 'Locality' 
 c when peID = CERT_STATE_OR_PROVINCE 
 c return 'State / Province' 
 c when peID = CERT_COUNTRY 
 c return 'Country' 
 c when peID = CERT_ORG 
 c return 'Org Unit' 
 c when peID = CERT_ORG_UNIT 
 c return 'Org' 
 c when peID = CERT_DN_PRINTABLE 
 c return 'DN' 
 c when peID = CERT_DN_DER 
 c return 'DN ( DER ) ' 
 c when peID = CERT_POSTAL_CODE 
 c return 'PostalCode' 
 c when peID = CERT_EMAIL 
 c return 'E - Mail' 
 c when peID = CERT_ISSUER_COMMON_NAME 
 c return 'Issuer CN' 
 c when peID = CERT_ISSUER_LOCALITY 
 c return 'Issuer Locality' 
 c when peID = CERT_ISSUER_STATE_OR_PROVINCE 
 c return 'Issuer State / Province' 
 c when peID = CERT_ISSUER_COUNTRY 
 c return 'Issuer Country' 
 c when peID = CERT_ISSUER_ORG 
 c return 'Issuer Org' 
 c when peID = CERT_ISSUER_ORG_UNIT 
 c return 'Issuer Org Unit' 
 c when peID = CERT_ISSUER_DN_PRINTABLE 
 c return 'Issuer DN' 
 c when peID = CERT_ISSUER_DN_DER 
 c return 'Issuer DN ( DER ) ' 
 c when peID = CERT_ISSUER_POSTAL_CODE 
 c return 'Issuer Postal Code' 
 c when peID = CERT_ISSUER_EMAIL 
 c return 'Issuer E - Mail' 
 c when peID = CERT_VERSION 
 c return 'Version' 
 c when peID = CERT_SIGNATURE_ALGORITHM 
 c return 'signature algorithm' 
 c when peID = CERT_VALID_FROM 
 c return 'not before' 
 c when peID = CERT_VALID_TO 
 c return 'not after' 
 c when peID = CERT_PUBLIC_KEY_ALGORITHM 
 c return 'pub key alg' 
 c when peID = CERT_ISSUER_UNIQUEID 
 c return 'issuer unique id' 
 c when peID = CERT_SUBJECT_UNIQUEID 
 c return 'subject unique id' 
 c other 
 c return 'Unknown Field' 
 c endsl 
 P E 
 
 
 P SSL_debug_cert_info ... 
 P B 
 D SSL_debug_cert_info ... 
 D PI 
 D peSSLh like ( GSK_HANDLE ) value 
 D peInfoID 10I 0 value 
 
 D p_start s * 
 D rc s 10I 0 
 D wwCount s 10I 0 
 D wwSize s 10I 0 
 D wwEntry s 10I 0 
 
 c eval rc = gsk_attribute_get_cert_info ( 
 c peSSLh : 
 c peInfoID : 
 c p_start : 
 c wwCount ) 
 
 c if rc <> GSK_OK 
 c callp http_dmsg ( SSL_error ( rc ) ) 
 c return 
 c endif 
 
 c eval wwCount = wwCount - 1 
 c eval wwSize = % size ( gsk_cert_data_elem ) 
 
 c 0 do wwCount wwEntry 
 
 c eval p_gsk_cert_data_elem = 
 c p_start + ( wwEntry * wwSize ) 
 
 c select 
 c when cert_data_id = CERT_BODY_BASE64 
 c callp ssl_debug_cert_body ( cert_data_p 
 c : cert_data_l ) 
 
 c when cert_data_id = CERT_DN_PRINTABLE 
 c or cert_data_id = CERT_DN_DER 
 c or cert_data_id = CERT_BODY_DER 
 c or cert_data_id = CERT_ISSUER_DN_DER 
 c or cert_data_id = 
 c CERT_ISSUER_DN_PRINTABLE 
 
 c other 
 c callp ssl_debug_cert_elem ( cert_data_id 
 c : cert_data_p 
 c : cert_data_l ) 
 c endsl 
 
 c enddo 
 P E 
 
 
 P SSL_debug_cert_body ... 
 P B 
 D SSL_debug_cert_body ... 
 D PI 
 d peBody * value 
 D peLen 10I 0 value 
 
 D CHUNK C 64 
 D wwCRLF s 2A inz ( x'0d25' ) 
 
 c callp http_xlate ( % len ( wwCRLF ) 
 c : wwCRLF 
 c : TO_ASCII ) 
 
 c callp http_dmsg ( ' ----- BEGIN CERTIFICATE ----- ' ) 
 
 c dow peLen > CHUNK 
 c callp http_dwrite ( peBody : CHUNK ) 
 c callp http_dwrite ( % addr ( wwCRLF ) : % size ( wwCRLF ) ) 
 c eval peLen = peLen - CHUNK 
 c eval peBody = peBody + CHUNK 
 c enddo 
 
 c if peLen > 0 
 c callp http_dwrite ( peBody : peLen ) 
 c endif 
 
 c callp http_dmsg ( ' ----- END CERTIFICATE ----- ' ) 
 P E 
 
 
 P SSL_debug_cert_elem ... 
 P B 
 D SSL_debug_cert_elem ... 
 D PI 
 D peElemNo 10I 0 value 
 D peData * value 
 D peLen 10I 0 value 
 
 D wwName s 52A varying 
 D p_data s * 
 D wwCRLF s 2A inz ( x'0d25' ) 
 
 c callp http_xlate ( % len ( wwCRLF ) 
 c : wwCRLF 
 c : TO_ASCII ) 
 
 c eval wwName = https_IDname ( peElemNo ) + ' : ' 
 
 c eval p_data = % addr ( wwName ) + VARPREF 
 c callp http_xlatep ( % len ( wwName ) 
 c : p_data 
 c : TO_ASCII ) 
 
 c callp http_dwrite ( p_data : % len ( wwName ) ) 
 c callp http_dwrite ( peData : peLen ) 
 c callp http_dwrite ( % addr ( wwCRLF ) : % len ( wwCRLF ) ) 
 P E 
 
 
 P commssl_setxproc ... 
 P B export 
 D commssl_setxproc ... 
 D PI 
 D pePoint 10I 0 value 
 D peProc * procptr value 
 D peUsrDta * value 
 C select 
 c when pePoint = HTTP_POINT_CERT_VAL 
 c eval wkValProc = peProc 
 c eval wkValUsrDta = peUsrDta 
 c when pePoint = HTTP_POINT_GSKIT_CERT_VAL 
 c eval wkGskValProc = peProc 
 c eval wkGskValUsrDta = peUsrDta 
 c endsl 
 
 c callp https_cleanup 
 P E 
 
 
 P SSL_validate_cert ... 
 P B 
 D SSL_validate_cert ... 
 D PI 10i 0 
 D peSSLh like ( GSK_HANDLE ) value 
 
 D cert_val_callback ... 
 D PR 10i 0 extPRoc ( wkValProc ) 
 D usrdta * value 
 D id 10i 0 value 
 D data 32767a varying const 
 D errmsg 80a 
 
 D p_start s * 
 D rc s 10I 0 
 D wwCount s 10I 0 
 D wwSize s 10I 0 
 D wwEntry s 10I 0 
 D wwCancel s 1n 
 D wwMsg s 80a 
 D Data s 32767a based ( p_data ) 
 D wwParm s 32767a varying 
 
 c if wkValProc = * null 
 c return 0 
 c endif 
 
 c eval rc = gsk_attribute_get_cert_info ( 
 c peSSLh : 
 c GSK_PARTNER_CERT_INFO : 
 c p_start : 
 c wwCount ) 
 
 c if rc <> GSK_OK 
 c callp http_dmsg ( SSL_error ( rc ) ) 
 c callp SetError ( HTTP_SSLGCI 
 c : 'gsk_attribute_get_cert_info : ' 
 c + SSL_error ( rc ) ) 
 c return - 1 
 c endif 
 
 c eval wwCount = wwCount - 1 
 c eval wwSize = % size ( gsk_cert_data_elem ) 
 
 c 0 do wwCount wwEntry 
 
 c eval p_gsk_cert_data_elem = 
 c p_start + ( wwEntry * wwSize ) 
 
 c eval p_data = cert_data_p 
 c eval wwParm = % subst ( data : 1 : cert_data_l ) 
 
 c if cert_data_id <> CERT_DN_DER 
 c and cert_data_id <> CERT_BODY_DER 
 c and cert_data_id <> CERT_ISSUER_DN_DER 
 c and cert_data_l > 0 
 c eval p_data = % addr ( wwParm ) + VARPREF 
 c callp http_xlatep ( cert_data_l 
 c : p_data 
 c : TO_EBCDIC ) 
 c endif 
 
 c eval rc = cert_val_callback ( wkValUsrDta 
 c : cert_data_id 
 c : wwParm 
 c : wwMsg ) 
 c if rc <> 0 
 c callp SetError ( HTTP_SSLVAL : wwMsg ) 
 c return - 1 
 c endif 
 
 c enddo 
 
 c return 0 
 P E 
 
 
 P https_strict B export 
 D https_strict PI 
 D peSetting 1n const 
 c if peSetting <> wkFullAuth 
 c eval wkFullAuth = peSetting 
 c callp https_cleanup 
 c endif 
 P E 
 
 
 P SSL_get_proto B export 
 D PI 
 D peValue 10a dim ( 10 ) 
 
 D QWCRSVAL PR ExtPgm ( 'QSYS / QWCRSVAL' ) 
 D RcvVar 32767a options ( * varsize ) 
 D RcvVarLen 10i 0 const 
 D NbrSysVal 10i 0 const 
 D SysValName 10a dim ( 1000 ) options ( * varsize ) 
 D ErrorCode 32767a options ( * varsize ) 
 
 D SysValBuf DS 32767 
 D NbrRtn 10i 0 
 D Offsets 10i 0 dim ( 1000 ) 
 
 D p_SysVal s * inz ( * null ) 
 D SysValDS DS based ( p_SysVal ) 
 D SysVal 10a 
 D Type 1a 
 D Status 1a 
 D DataLen 10i 0 
 D Data 10a dim ( 10 ) 
 
 D ErrorCode DS 
 D BytesPrv 10i 0 inz ( % size ( ErrorCode ) ) 
 D BytesAvl 10i 0 inz ( 0 ) 
 
 D SysValName s 10a dim ( 1 ) 
 
 c eval SysValName ( 1 ) = 'QSSLPCL' 
 c eval peValue = * blanks 
 
 c callp ( e ) QWCRSVAL ( SysValBuf 
 c : % size ( SysValBuf ) 
 c : 1 
 c : SysValName 
 c : ErrorCode ) 
 
 c if % error = * off 
 c and BytesAvl = 0 
 c and NbrRtn >= 1 
 c and Offsets ( 1 ) > 0 
 
 c eval p_SysVal = % addr ( SysValBuf ) 
 c + Offsets ( 1 ) 
 
 c if SysVal = SysValName ( 1 ) 
 c and Type = 'C' 
 c and Status = ' ' 
 c and DataLen = 100 
 c eval peValue = Data 
 c endif 
 
 c endif 
 
 c return 
 P E 
 
 
 P refill B 
 D PI 10i 0 
 D peTimeout 10P 3 value 
 
 D len S 10I 0 
 D rc s 10I 0 
 D safetyNet s 10i 0 
 
 / if defined ( USE_POLL ) 
 D pfd ds likeds ( pollfd_t ) dim ( 1 ) 
 / else 
 D timeout S like ( timeval ) 
 D readSet S like ( fdset ) 
 / endif 
 
 c if bufLen > 0 
 c return 0 
 c endif 
 
 c eval bufCurr = bufBase 
 
 c dou len > 0 
 
 c eval rc = gsk_secure_soc_read ( sslh 
 c : bufCurr 
 c : bufSize 
 c : len ) 
 
 c if rc = GSK_OK and len = 0 
 c callp SetError ( HTTP_BRRECV : 'CommTCP_read : ' + 
 c 'Socket has been shut down . ' ) 
 c return - 1 
 c endif 
 
 c if rc = GSK_IBMI_ERROR_TIMED_OUT 
 c callp SetError ( HTTP_BRTIME : 'CommSSL_Read : ' + 
 c ' timeout ! ' ) 
 c return - 1 
 c endif 
 
 c if rc <> GSK_OK 
 
 c if rc <> GSK_WOULD_BLOCK 
 c callp SetError ( HTTP_BRRECV : 'CommSSL_read : ' + 
 c ' read : ' + ssl_error ( rc ) ) 
 c return - 1 
 c endif 
 
 c eval safetyNet = safetyNet + 1 
 c if safetyNet = 1000 
 c callp SetError ( HTTP_BRRECV : 'CommSSL_read : ' + 
 c ' safetyNet threshold exceeded' ) 
 c return - 1 
 c endif 
 
 / if defined ( USE_POLL ) 
 c eval pfd ( 1 ) = * allx'00' 
 c eval pfd ( 1 ) . fd = fd 
 c eval pfd ( 1 ) . events = POLLIN 
 
 c eval rc = poll ( pfd : 1 : peTimeout * 1000 ) 
 c if rc < 0 
 c callp SetError ( HTTP_BRSELE : 'CommSSL_read : ' + 
 c 'poll : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if rc = 0 
 c if peTimeout >= 1 
 c callp SetError ( HTTP_BRTIME : 'CommSSL_read : ' + 
 c 'timeout ! ' ) 
 c else 
 c callp SetError ( HTTP_BRTIME : 'CommSSL_read : ' + 
 c 'No 100 - Continue ( error ignored ) ' ) 
 c endif 
 c return - 1 
 c endif 
 / else 
 c eval p_timeval = % addr ( timeout ) 
 c eval tv_sec = peTimeout 
 c eval tv_usec = ( peTimeout - tv_sec ) * 1000000 
 
 c callp CommTCP_FD_ZERO ( readSet ) 
 c callp CommTCP_FD_SET ( fd : readSet ) 
 
 c eval rc = select ( fd + 1 
 c : % addr ( readSet ) 
 c : * null 
 c : * null 
 c : % addr ( timeout ) ) 
 
 c if rc < 0 
 c callp SetError ( HTTP_BRSELE : 'CommSSL_read : ' + 
 c 'select : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if CommTCP_FD_ISSET ( fd : readSet ) = * Off 
 c if peTimeout >= 1 
 c callp SetError ( HTTP_BRTIME : 'CommSSL_read : ' + 
 c 'time - out ! ' ) 
 c else 
 c callp SetError ( HTTP_BRTIME : 'CommSSL_read : ' + 
 c 'No 100 - Continue ( error ignored ) ' ) 
 c endif 
 c return - 1 
 c endif 
 / endif 
 
 c endif 
 
 c enddo 
 
 C eval bufLen = bufLen + len 
 C return len 
 P E 
 
 / define ERRNO_LOAD_PROCEDURE 
 / copy ERRNO_H 
 
 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * SRCSTMT : * NOSHOWCPY ) 
 / endif 
 H NOMAIN 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy socket_h 
 / copy errno_h 
 / copy httpapi_h 
 / copy private_h 
 
 D p_CommTcp s * 
 D CommTcp ds based ( p_CommTcp ) 
 D p_Resolve ... 
 D * procptr 
 D p_Connect ... 
 D * procptr 
 D p_Upgrade ... 
 D * procptr 
 D p_Read ... 
 D * procptr 
 D p_BlockRead ... 
 D * procptr 
 D p_BlockWrite ... 
 D * procptr 
 D p_LineRead ... 
 D * procptr 
 D p_LineWrite ... 
 D * procptr 
 D p_Hangup ... 
 D * procptr 
 D p_Cleanup ... 
 D * procptr 
 D fd 10I 0 
 D bufSize 10u 0 
 D bufLen 10u 0 
 D 4a 
 D bufBase * 
 D bufCurr * 
 
 
 D CommTcp_New PR * 
 
 D CommTcp_Connect ... 
 D PR 1N 
 D peHandle * value 
 D peSockaddr * value 
 D peTimeout 10P 3 value 
 
 D CommTcp_Upgrade ... 
 D PR 1N 
 D peHandle * value 
 D peTimeout 10P 3 value 
 D peEndHost * value options ( * string ) 
 
 D CommTcp_Read ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommTcp_BlockRead ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommTcp_BlockWrite ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommTcp_LineRead ... 
 D PR 10I 0 
 D handle * value 
 D buffer * value 
 D bufsize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommTcp_LineWrite ... 
 D PR 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peBufSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D CommTcp_Hangup ... 
 D PR 1N 
 D peHandle * value 
 
 D CommTcp_Cleanup ... 
 D PR 1N 
 D peHandle * value 
 
 D Resolve PR 10i 0 
 D peHost * value options ( * string ) 
 D peService * value options ( * string ) 
 D pePort 10I 0 value 
 D peSockaddr * value 
 
 D CalcBitPos PR 
 D peDescr 10I 0 
 D peByteNo 5I 0 
 D peBitMask 1A 
 
 D refill PR 10i 0 
 D peTimeout 10P 3 value 
 
 D MAXNS C 3 
 D MAXRESOLVSORT C 10 
 
 D res ds IMPORT ( '_res' ) 
 D retrans 10i 0 
 D retry 10i 0 
 D options 4a 
 D nscount 10i 0 
 D nsaddr 16a dim ( MAXNS ) 
 D id 5u 0 
 D defdname 256a 
 D reserved0 1a 
 D reserved1 13a 
 D dnsrch * dim ( 7 ) 
 D sort_list 8a dim ( MAXRESOLVSORT ) 
 D res_h_errno 10i 0 
 D extended_err 10i 0 
 D ndotssort 1a 
 D state_data 27a 
 D internal_use 10i 0 dim ( 4 ) 
 D reserved 444a 
 
 D DNS_Info PR 
 D HTTP_DEBUG_LEVEL ... 
 D s 10i 0 inz ( 1 ) 
 
 P CommTcp_New B export 
 D CommTcp_New PI * 
 
 C eval p_CommTcp = xalloc ( % size ( CommTcp ) ) 
 
 c eval CommTcp =* ALLx'00' 
 c eval p_Resolve =% paddr ( 'COMMTCP_RESOLVE' ) 
 c eval p_Connect =% paddr ( 'COMMTCP_CONNECT' ) 
 c eval p_Upgrade =% paddr ( 'COMMTCP_UPGRADE' ) 
 c eval p_Read =% paddr ( 'COMMTCP_READ' ) 
 c eval p_BlockRead =% paddr ( 'COMMTCP_BLOCKREAD' ) 
 c eval p_BlockWrite =% paddr ( 'COMMTCP_BLOCKWRITE' ) 
 c eval p_LineRead =% paddr ( 'COMMTCP_LINEREAD' ) 
 c eval p_LineWrite =% paddr ( 'COMMTCP_LINEWRITE' ) 
 c eval p_Hangup =% paddr ( 'COMMTCP_HANGUP' ) 
 c eval p_Cleanup =% paddr ( 'COMMTCP_CLEANUP' ) 
 c eval fd = - 1 
 
 c eval bufSize = 131072 
 c eval bufBase = xalloc ( bufSize ) 
 c eval bufLen = 0 
 c eval bufCurr = bufBase 
 
 c eval HTTP_DEBUG_LEVEL = getDebugLevel ( ) 
 
 c return p_CommTcp 
 P E 
 
 
 P commTcp_Resolve ... 
 P B export 
 D commTcp_Resolve ... 
 D PI * 
 D peHandle * value 
 D peHost * value options ( * string ) 
 D peService * value options ( * string ) 
 D pePort 10I 0 value 
 D peForced 1N const 
 
 D wwAddrBuf s like ( sockaddr_in ) static 
 
 c callp DNS_Info 
 c eval p_CommTcp = peHandle 
 c if Resolve ( peHost 
 c : peService 
 c : pePort 
 c : % addr ( wwAddrBuf ) ) = 0 
 c return % addr ( wwAddrBuf ) 
 c else 
 c return * null 
 c endif 
 P E 
 
 
 P Resolve B 
 D Resolve PI 10i 0 
 D peHost * value options ( * string ) 
 D peService * value options ( * string ) 
 D pePort 10I 0 value 
 D peSockaddr * value 
 
 c eval p_Sockaddr = peSockaddr 
 c eval sockaddr_in = * ALLx'00' 
 c eval sin_family = AF_INET 
 c eval sin_addr = 0 
 
 c eval HTTP_DEBUG_LEVEL = getDebugLevel ( ) 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c callp http_dmsg ( 'Resolving host ' 
 c + % str ( peHost ) ) 
 c endif 
 
 
 c if % scan ( ' . ' :% str ( peHost ) ) = 0 
 c and atoll ( peHost ) > 167772156 
 c eval sin_addr = atoll ( peHost ) 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c callp http_dmsg ( 'Host appears to be a raw' 
 c + ' IP address . atoll = ' 
 c + % char ( sin_addr ) ) 
 c endif 
 
 c endif 
 
 c if sin_addr = 0 
 c eval sin_addr = inet_addr ( peHost ) 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c callp http_dmsg ( 'inet_addr return value ' 
 c + 'for this host is ' 
 c + % char ( sin_addr ) ) 
 c endif 
 
 c if sin_addr = INADDR_NONE 
 c eval sin_addr = 0 
 c endif 
 c endif 
 
 c if sin_addr = 0 
 c eval p_hostent = gethostbyname ( peHost ) 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c if p_hostent = * null 
 c callp http_dmsg ( 'gethostbyname ( ) returned' 
 c + ' * NULL' ) 
 c else 
 c callp http_dmsg ( 'gethostbyname ( ) returned' 
 c + ' ' + % char ( h_addr ) ) 
 c endif 
 c endif 
 
 c if p_hostent <> * NULL 
 c eval sin_addr = h_addr 
 c endif 
 c endif 
 
 c if sin_addr = 0 
 c callp SetError ( HTTP_HOSTNF 
 c : 'Host name look up failed . ' ) 
 c return - 1 
 c endif 
 
 
 
 c if HTTP_DEBUG_LEVEL >= 2 and pePort > 0 
 c callp http_dmsg ( 'Port specified as number ' 
 c + % char ( pePort ) ) 
 c endif 
 
 c if pePort > 0 
 c eval sin_port = pePort 
 c return 0 
 c endif 
 
 c if atoi ( peService ) <> 0 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c callp http_dmsg ( 'Service specified as number' 
 c + ' ' + % str ( peService ) ) 
 c endif 
 
 c eval sin_port = atoi ( peService ) 
 c return 0 
 c endif 
 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c callp http_dmsg ( 'Looking up service' 
 c + ' ' + % str ( peService ) ) 
 c endif 
 
 c eval p_servent = getservbyname ( peService 
 c : 'tcp' ) 
 
 c if p_servent = * NULL 
 c if % str ( peService ) = 'https' 
 c eval sin_port = 443 
 c else 
 c eval sin_port = 80 
 c endif 
 c else 
 c eval sin_port = s_port 
 c endif 
 
 c if HTTP_DEBUG_LEVEL >= 2 
 c if p_servent = * null 
 c callp http_dmsg ( 'Service not found in' 
 c + ' service table . Using ' 
 c + % char ( sin_port ) ) 
 c else 
 c callp http_dmsg ( 'Service table returns' 
 c + ' port ' + % char ( sin_port ) ) 
 c endif 
 c endif 
 
 c return 0 
 P E 
 
 
 P CommTcp_Connect ... 
 P B export 
 D CommTcp_Connect ... 
 D PI 1N 
 D peHandle * value 
 D peSockaddr * value 
 D peTimeout 10P 3 value 
 
 c eval p_commTCP = peHandle 
 c eval fd = CommTCP_ConnectNonBlock ( peSockAddr 
 c : peTimeout ) 
 c if fd = - 1 
 c return * OFF 
 c else 
 c return * ON 
 c endif 
 P E 
 
 
 P CommTcp_Upgrade ... 
 P B export 
 D CommTcp_Upgrade ... 
 D PI 1N 
 D peHandle * value 
 D peTimeout 10P 3 value 
 D peEndHost * value options ( * string ) 
 C return * ON 
 P E 
 
 
 P CommTcp_ConnectNonBlock ... 
 P B export 
 D CommTcp_ConnectNonBlock ... 
 D PI 10I 0 
 D peSockaddr * value 
 D peTimeout 10P 3 value 
 D peTTL 10i 0 const options ( * nopass ) 
 
 D s S 10I 0 
 D rc S 10I 0 
 D wwFlags S 10U 0 
 D wwBufSize s 10I 0 
 D wwSize s 10i 0 
 D wwConnErr s 10i 0 
 D wwTTL s 10i 0 
 D wwOpt s 10i 0 
 / if defined ( USE_POLL ) 
 D pfd ds likeds ( pollfd_t ) dim ( 1 ) 
 / else 
 D wwfds S like ( fdset ) 
 D wwTV s like ( timeval ) 
 / endif 
 
 c eval s = socket ( AF_INET 
 c : SOCK_STREAM 
 c : IPPROTO_IP ) 
 c if s < 0 
 c callp SetError ( HTTP_SOCERR : 'socket ( ) : ' + 
 c % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c eval wwBufSize = 128 * 1024 
 c callp setsockopt ( s : SOL_SOCKET : SO_RCVBUF : 
 c % addr ( wwBufSize ) : % size ( wwBufSize ) ) 
 c callp setsockopt ( s : SOL_SOCKET : SO_SNDBUF : 
 c % addr ( wwBufSize ) : % size ( wwBufSize ) ) 
 
 / if not defined ( ENABLE_BLOCKING ) 
 c eval wwFlags = fcntl ( s : F_GETFL ) 
 c eval wwFlags = wwFlags + O_NONBLOCK 
 c callp fcntl ( s : F_SETFL : wwFlags ) 
 / endif 
 
 c if % parms >= 3 
 c and peTTL > 0 
 c eval wwTTL = peTTL 
 c callp setsockopt ( s 
 c : IPPROTO_IP 
 c : IP_TTL 
 c : % addr ( wwTTL ) 
 c : % size ( wwTTL ) ) 
 c endif 
 
 c eval wwOpt = 1 
 c eval rc = setsockopt ( s 
 c : IPPROTO_TCP 
 c : TCP_NODELAY 
 c : % addr ( wwOpt ) 
 C : % size ( wwOpt ) ) 
 c if rc = 0 
 c callp http_dmsg ( 'Nagle''s algorithm' 
 c + ' ( TCP_NODELAY ) disabled . ' ) 
 c else 
 c callp http_dmsg ( 'Error disabling Nagle''s' 
 c + ' ( TCP_NODELAY ) algorithm . ' ) 
 c endif 
 
 c if connect ( s : peSockAddr : % size ( sockaddr ) ) 
 c < 0 
 c if errno <> EINPROGRESS 
 c callp SetError ( HTTP_BADCNN : 'connect ( 1 ) : ' + 
 c % str ( strerror ( errno ) ) ) 
 c callp close ( s ) 
 c return - 1 
 c endif 
 c endif 
 
 / if not defined ( USE_POLL ) 
 c eval p_timeval = % addr ( wwTV ) 
 c eval tv_sec = peTimeout 
 c eval tv_usec = ( peTimeout - tv_sec ) * 1000000 
 
 C callp CommTCP_FD_ZERO ( wwfds ) 
 c callp CommTCP_FD_SET ( s : wwfds ) 
 
 c eval rc = select ( s + 1 
 c : * NULL 
 c : % addr ( wwfds ) 
 c : * NULL 
 c : p_timeval ) 
 c select 
 c when rc = 0 
 c callp close ( s ) 
 c callp SetError ( HTTP_CNNTIMO : 'Timeout occurred ' + 
 c 'while trying to connect to server ! ' ) 
 c return - 1 
 
 c when rc = - 1 
 c callp close ( s ) 
 c callp SetError ( HTTP_BADCNN : 'select ( 2 ) : ' + 
 c % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endsl 
 
 c if CommTCP_FD_ISSET ( s : wwfds ) = * Off 
 c callp close ( s ) 
 c callp SetError ( HTTP_CNNTIMO : 'Timeout occurred ' + 
 c 'while trying to connect to server ! ' ) 
 c return - 1 
 c endif 
 / endif 
 
 / if defined ( USE_POLL ) 
 c eval pfd ( 1 ) = * ALLx'00' 
 c eval pfd ( 1 ) . fd = s 
 c eval pfd ( 1 ) . events = POLLOUT 
 
 c eval rc = poll ( pfd : 1 : peTimeout * 1000 ) 
 
 c select 
 c when rc = 0 
 c callp close ( s ) 
 c callp SetError ( HTTP_CNNTIMO : 'Timeout occurred ' + 
 c 'while trying to connect to server ! ' ) 
 c return - 1 
 
 c when rc = - 1 
 c callp close ( s ) 
 c callp SetError ( HTTP_BADCNN : 'poll ( 1 ) : ' + 
 c % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endsl 
 
 c if % bitand ( pfd ( 1 ) . revents : POLLOUT ) = 0 
 c callp close ( s ) 
 c callp SetError ( HTTP_CNNTIMO : 'Timeout occurred ' + 
 c 'while trying to connect to server ! ' ) 
 c return - 1 
 c endif 
 / endif 
 
 c eval wwSize = % size ( wwConnErr ) 
 c callp getsockopt ( s 
 c : SOL_SOCKET 
 c : SO_ERROR 
 c : % addr ( wwConnErr ) 
 c : wwSize ) 
 c if wwConnErr <> 0 
 c callp SetError ( HTTP_BADCNN : 'connect ( 2 ) : ' + 
 c % str ( strerror ( wwConnErr ) ) ) 
 c callp close ( s ) 
 c return - 1 
 c endif 
 
 c return s 
 P E 
 
 
 P CommTcp_Read ... 
 P B export 
 D CommTcp_Read ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwLen S 10I 0 
 
 c eval p_commTcp = pehandle 
 
 c if refill ( peTimeout ) = - 1 
 c return - 1 
 c endif 
 
 c eval wwLen = peSize 
 c if wwLen > bufLen 
 c eval wwLen = bufLen 
 c endif 
 
 c callp memcpy ( peBuffer : bufCurr : wwLen ) 
 c eval bufLen = bufLen - wwLen 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + wwLen 
 c endif 
 
 c callp http_dwrite ( peBuffer : wwLen ) 
 
 c return wwLen 
 P E 
 
 
 P CommTcp_BlockRead ... 
 P B export 
 D CommTcp_BlockRead ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwTimeout S like ( timeval ) 
 D wwLen S 10I 0 
 D wwFds S like ( fdset ) 
 D wwLeft S 10I 0 
 
 c eval wwLeft = peSize 
 
 c dow wwLeft > 0 
 
 c eval wwLen = commTcp_Read ( peHandle 
 c : peBuffer 
 c : wwLeft 
 c : peTimeout ) 
 c callp http_dmsg ( 'got ' + % char ( wwLen ) ) 
 c if wwLen < 1 
 c if wwLeft = peSize 
 c return - 1 
 c else 
 c return peSize - wwLeft 
 c endif 
 c endif 
 
 c eval wwLeft = wwLeft - wwLen 
 c eval peBuffer = peBuffer + wwLen 
 c enddo 
 
 c return peSize 
 P E 
 
 P CommTcp_BlockWrite ... 
 P B export 
 D CommTcp_BlockWrite ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D wwLen S 10I 0 
 D wwSent s 10I 0 
 
 / if defined ( USE_POLL ) 
 D pfd ds likeds ( pollfd_t ) dim ( 1 ) 
 D rc s 10i 0 
 / else 
 D wwTimeout S like ( timeval ) 
 D wwFds S like ( fdset ) 
 / endif 
 
 c eval p_CommTcp = peHandle 
 
 c dou peSize = 0 
 
 c eval wwLen = send ( fd : peBuffer : peSize : 0 ) 
 
 c if wwLen < 1 and errno <> EAGAIN 
 c callp SetError ( HTTP_BWSEND : 'blockwrite : ' + 
 c 'send : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 / if defined ( USE_POLL ) 
 c if wwLen < 1 
 
 c eval pfd ( 1 ) . fd = fd 
 c eval pfd ( 1 ) . events = POLLOUT 
 c eval pfd ( 1 ) . revents = 0 
 
 c eval rc = poll ( pfd 
 c : % elem ( pfd ) 
 c : peTimeout * 1000 ) 
 c if rc < 0 
 c callp SetError ( HTTP_BWSELE : 'blockwrite : ' + 
 c 'poll : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if rc = 0 
 c callp SetError ( HTTP_BWTIME : 'blockwrite : ' + 
 c ' timeout ! ' ) 
 c return - 1 
 c endif 
 
 c iter 
 c endif 
 / else 
 c if wwLen < 1 
 
 c eval p_timeval = % addr ( wwTimeout ) 
 c eval tv_sec = peTimeout 
 c eval tv_usec = ( peTimeout - tv_sec ) * 1000000 
 
 c callp CommTCP_FD_ZERO ( wwfds ) 
 c callp CommTCP_FD_SET ( fd : wwfds ) 
 
 c if select ( fd + 1 :* NULL :% addr ( wwfds ) :* NULL : 
 c % addr ( wwTimeout ) ) < 0 
 c callp SetError ( HTTP_BWSELE : 'blockwrite : ' + 
 c 'select : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if CommTCP_FD_ISSET ( fd : wwfds ) = * Off 
 c callp SetError ( HTTP_BWTIME : 'blockwrite : ' + 
 c ' time - out ! ' ) 
 c return - 1 
 c endif 
 
 c iter 
 c endif 
 / endif 
 
 c callp http_dwrite ( peBuffer : wwLen ) 
 
 c eval wwSent = wwSent + wwLen 
 c eval peSize = peSize - wwLen 
 
 c if peSize > 0 
 c eval peBuffer = peBuffer + wwLen 
 c endif 
 
 c enddo 
 
 c return wwSent 
 P E 
 
 P CommTcp_LineRead ... 
 P B export 
 D CommTcp_LineRead ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 d EOL c const ( x'0a' ) 
 d len s 10I 0 
 D left s 10i 0 
 D bufPos s * 
 D Pos s * 
 
 c if peSize <= 0 
 c return 0 
 c endif 
 
 c eval p_commTcp = peHandle 
 c eval len = 0 
 c eval left = peSize 
 c eval bufPos = peBuffer 
 
 c dow left > 0 
 
 c if refill ( peTimeout ) = - 1 
 c return - 1 
 c endif 
 
 c eval len = bufLen 
 c if len > left 
 c eval len = left 
 c endif 
 
 c eval pos = memchr ( bufCurr : EOL : len ) 
 c if pos <> * null 
 c eval len = ( pos - bufCurr ) + 1 
 c callp memcpy ( bufPos : bufCurr : len ) 
 c eval bufLen = bufLen - len 
 c eval left = left - len 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + len 
 c endif 
 c leave 
 c endif 
 
 c callp memcpy ( bufPos : bufCurr : len ) 
 c eval bufLen = bufLen - len 
 c eval bufPos = bufPos + len 
 c eval left = left - len 
 c if bufLen > 0 
 c eval bufCurr = bufCurr + len 
 c endif 
 
 c enddo 
 
 c callp http_dwrite ( peBuffer : peSize - left ) 
 c return peSize - left 
 P E 
 
 
 P CommTcp_LineWrite ... 
 P B export 
 D CommTcp_LineWrite ... 
 D PI 10I 0 
 D peHandle * value 
 D peBuffer * value 
 D peBufSize 10I 0 value 
 D peTimeout 10P 3 value 
 
 D p_Buf s * 
 D p_EOL s * 
 D wwEOL s 2A based ( p_EOL ) 
 D rc s 10I 0 
 
 c eval p_Buf = xalloc ( peBufSize + % size ( wwEOL ) ) 
 c callp memcpy ( p_Buf : peBuffer : peBufSize ) 
 
 c eval p_EOL = p_Buf + peBufSize 
 c eval wwEOL = x'0d0a' 
 
 c eval rc = CommTcp_BlockWrite ( peHandle 
 c : p_buf 
 c : peBufSize 
 c + % size ( wwEOL ) 
 c : peTimeout ) 
 
 c callp xdealloc ( p_buf ) 
 c return rc 
 P E 
 
 P CommTcp_Hangup ... 
 P B export 
 D CommTcp_Hangup ... 
 D PI 1N 
 D peHandle * value 
 c eval p_CommTcp = peHandle 
 c if close ( fd ) = 0 
 c return * ON 
 c else 
 c return * OFF 
 c endif 
 P E 
 
 P CommTcp_Cleanup ... 
 P B export 
 D CommTcp_Cleanup ... 
 D PI 1N 
 D peHandle * value 
 c eval p_CommTcp = peHandle 
 c callp xdealloc ( bufBase ) 
 
 c callp ( e ) xdealloc ( peHandle ) 
 
 c if % error 
 c return * OFF 
 c else 
 c return * ON 
 c endif 
 P E 
 
 
 P CommTCP_FD_SET ... 
 P B EXPORT 
 D CommTCP_FD_SET ... 
 D PI 
 D peFD 10I 0 
 D peFDSet like ( fdset ) 
 D wkByteNo S 5I 0 
 D wkMask S 1A 
 D wkByte S 1A 
 C callp CalcBitPos ( peFD : wkByteNo : wkMask ) 
 c eval wkByte = % subst ( peFDSet : wkByteNo : 1 ) 
 c biton wkMask wkByte 
 c eval % subst ( peFDSet : wkByteNo : 1 ) = wkByte 
 P E 
 
 
 P CommTCP_FD_ISSET ... 
 P B EXPORT 
 D CommTCP_FD_ISSET ... 
 D PI 1N 
 D peFD 10I 0 
 D peFDSet like ( fdset ) 
 D wkByteNo S 5I 0 
 D wkMask S 1A 
 D wkByte S 1A 
 C callp CalcBitPos ( peFD : wkByteNo : wkMask ) 
 c eval wkByte = % subst ( peFDSet : wkByteNo : 1 ) 
 c testb wkMask wkByte 88 
 c return * IN88 
 P E 
 
 
 P CommTCP_FD_ZERO ... 
 P B EXPORT 
 D CommTCP_FD_ZERO ... 
 D PI 
 D peFDSet like ( fdset ) 
 C eval peFDSet = * ALLx'00' 
 P E 
 
 
 P CalcBitPos B 
 D CalcBitPos PI 
 D peDescr 10I 0 
 D peByteNo 5I 0 
 D peBitMask 1A 
 D dsMakeMask DS 
 D dsZeroByte 1 1A 
 D dsMask 2 2A 
 D dsBitMult 1 2U 0 INZ ( 0 ) 
 C peDescr div 32 wkGroup 5 0 
 C mvr wkByteNo 2 0 
 C div 8 wkByteNo 2 0 
 C mvr wkBitNo 2 0 
 C eval wkByteNo = 4 - wkByteNo 
 c eval peByteNo = ( wkGroup * 4 ) + wkByteNo 
 c eval dsBitMult = 2 ** wkBitNo 
 c eval dsZeroByte = x'00' 
 c eval peBitMask = dsMask 
 P E 
 
 
 P DNS_Info B 
 D DNS_Info PI 
 
 D cvthc PR EXTPROC ( 'cvthc' ) 
 D output 8A 
 D input 4A 
 D output_len 10I 0 value 
 
 D opt s 1a 
 D hexopt s 8a 
 D res_init PR extproc ( 'res_init' ) 
 D rc s 10i 0 
 D msg s 256a 
 D x s 10i 0 
 
 C callp res_init 
 
 c eval opt = % subst ( options : 4 : 1 ) 
 C testb x'10' opt 99 
 c if * in99 = * OFF 
 c callp http_dmsg ( 'DNS Resolver doesnt init , ' 
 c + 'errno = ' 
 c + % trim ( % editc ( errno : 'P' ) ) ) 
 c return 
 c endif 
 
 C callp http_dmsg ( 'DNS resolver retrans : ' 
 C + % trim ( % editc ( retrans : 'P' ) ) ) 
 
 C callp http_dmsg ( 'DNS resolver retry : ' 
 C + % trim ( % editc ( retry : 'P' ) ) ) 
 
 C callp cvthc ( hexopt : options : % size ( hexopt ) ) 
 C callp http_dmsg ( 'DNS resolver options : ' 
 C + 'x''' + hexopt + '''' ) 
 
 C callp http_dmsg ( 'DNS default domain : ' 
 C + % str ( % addr ( defdname ) ) ) 
 
 c if nscount = 0 
 c eval msg = 'WARNING : No name servers ' 
 c + 'are configured for DNS ' 
 c + 'resolution ! You will not ' 
 c + 'be able to contact ' 
 c + 'Internet hosts ! ' 
 c + 'See http :// www . scottklement' 
 c + ' . com / httpapi / dns . html for ' 
 c + 'more information . ' 
 c callp http_dmsg ( msg ) 
 c callp http_diag ( msg ) 
 c return 
 c endif 
 
 c do nscount x 
 c eval p_sockaddr = % addr ( nsaddr ( x ) ) 
 c callp http_dmsg ( 'DNS server found : ' 
 c + % str ( inet_ntoa ( sin_addr ) ) ) 
 c enddo 
 c return 
 P E 
 
 
 P refill B 
 D PI 10i 0 
 D peTimeout 10P 3 value 
 
 D len S 10I 0 
 D rc s 10I 0 
 D safetyNet s 10i 0 
 
 / if defined ( USE_POLL ) 
 D pfd ds likeds ( pollfd_t ) dim ( 1 ) 
 / else 
 D timeout S like ( timeval ) 
 D readSet S like ( fdset ) 
 / endif 
 
 c if bufLen > 0 
 c return 0 
 c endif 
 
 c eval bufCurr = bufBase 
 
 c dou len > 0 
 
 c eval len = recv ( fd : bufCurr : bufsize : 0 ) 
 
 c if len = 0 
 c callp SetError ( HTTP_BRRECV : 'CommTCP_read : ' + 
 c 'Socket has been shut down . ' ) 
 c return - 1 
 c endif 
 
 c if len < 0 
 
 c if errno <> EWOULDBLOCK 
 c callp SetError ( HTTP_BRRECV : 'CommTCP_read : ' + 
 c 'recv : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c eval safetyNet = safetyNet + 1 
 c if safetyNet = 1000 
 c callp SetError ( HTTP_BRRECV : 'CommTCP_read : ' + 
 c ' safetyNet threshold exceeded' ) 
 c return - 1 
 c endif 
 
 / if defined ( USE_POLL ) 
 c eval pfd ( 1 ) = * ALLx'00' 
 c eval pfd ( 1 ) . fd = fd 
 c eval pfd ( 1 ) . events = POLLIN 
 
 c eval rc = poll ( pfd : 1 : peTimeout * 1000 ) 
 
 c if rc < 0 
 c callp SetError ( HTTP_BRSELE : 'CommTCP_read : ' + 
 c 'poll : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if rc = 0 
 c if peTimeout >= 1 
 c callp SetError ( HTTP_BRTIME : 'CommTCP_read : ' + 
 c 'timeout ! ' ) 
 c else 
 c callp SetError ( HTTP_BRTIME : 'CommTCP_read : ' + 
 c 'No 100 - Continue ( error ignored ) ' ) 
 c endif 
 c return - 1 
 c endif 
 / else 
 c eval p_timeval = % addr ( timeout ) 
 c eval tv_sec = peTimeout 
 c eval tv_usec = ( peTimeout - tv_sec ) * 1000000 
 
 c callp CommTCP_FD_ZERO ( readSet ) 
 c callp CommTCP_FD_SET ( fd : readSet ) 
 
 c eval rc = select ( fd + 1 
 c : % addr ( readSet ) 
 c : * null 
 c : * null 
 c : % addr ( timeout ) ) 
 
 c if rc < 0 
 c callp SetError ( HTTP_BRSELE : 'CommTCP_read : ' + 
 c 'select : ' + % str ( strerror ( errno ) ) ) 
 c return - 1 
 c endif 
 
 c if CommTCP_FD_ISSET ( fd : readSet ) = * Off 
 c if peTimeout >= 1 
 c callp SetError ( HTTP_BRTIME : 'CommTCP_read : ' + 
 c 'time - out ! ' ) 
 c else 
 c callp SetError ( HTTP_BRTIME : 'CommTCP_read : ' + 
 c 'No 100 - Continue ( error ignored ) ' ) 
 c endif 
 c return - 1 
 c endif 
 / endif 
 
 c endif 
 
 c enddo 
 
 C eval bufLen = bufLen + len 
 C return len 
 P E 
 
 
 / define ERRNO_LOAD_PROCEDURE 
 / copy ERRNO_H 
 
 
 / copy VERSION 
 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * NOSHOWCPY : * SRCSTMT : * NODEBUGIO ) 
 / endif 
 H NOMAIN 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy PRIVATE_H 
 
 D HTTP_NOTSUPP C CONST ( 61 ) 
 
 D http_DEPRECATED_url_get ... 
 D PR 10I 0 
 D peURL 256A const 
 D peFileName 256A const 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peModTime Z const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_DEPRECATED_url_post ... 
 D PR 10I 0 
 D peURL 256A const 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFilename 256A const 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_DEPRECATED_url_get_raw ... 
 D PR 10I 0 
 D peURL 256A const 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peModTime Z const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_DEPRECATED_url_post_raw ... 
 D PR 10I 0 
 D peURL 256A const 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_getraw ... 
 D PR 10I 0 
 D peSock 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peModTime Z options ( * omit ) 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 
 D http_postraw ... 
 D PR 10I 0 
 D peSock 10I 0 value 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 
 D https_getraw ... 
 D PR 10I 0 
 D peSock * value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peModTime Z options ( * omit ) 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 
 D https_postraw ... 
 D PR 10I 0 
 D peSock * value 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 
 D http_connect PR 10I 0 
 D peSockAddr * value 
 D peTimeout 10I 0 value 
 
 D http_url_encoder_addvar ... 
 D PR 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peData * value 
 D peDataSize 10I 0 value 
 
 D http_url_encoder_addvar_s ... 
 D PR 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peValue 256A varying value 
 
 D HTTP_SetTables PR 10I 0 
 D peASCII 10A const 
 D peEBCDIC 10A const 
 
 D http_build_sockaddr ... 
 D PR 10I 0 
 D peHost 256A const 
 D peService 32A const 
 D peForcePort 10I 0 value 
 D peSockAddr * 
 
 D http_ParseURL PR 10I 0 
 D peURL 256A const 
 D peService 32A 
 D peUserName 32A 
 D pePassword 32A 
 D peHost 256A 
 D pePort 10I 0 
 D pePath 256A 
 
 
 P http_DEPRECATED_url_get ... 
 P B export 
 D http_DEPRECATED_url_get ... 
 D PI 10I 0 
 D peURL 256A const 
 D peFileName 256A const 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peModTime Z const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_url_get PR 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D peFilename 32767A varying const options ( * varsize ) 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 
 c select 
 c when % parms = 2 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c ) 
 c when % parms = 3 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c ) 
 c when % parms = 4 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c ) 
 c when % parms = 5 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c ) 
 c when % parms = 6 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c : peContentType 
 c ) 
 c when % parms = 7 
 c return http_url_get ( % trimr ( peURL ) 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c : peContentType 
 c : peSoapAction 
 c ) 
 c endsl 
 P E 
 
 
 P http_DEPRECATED_url_post ... 
 P B export 
 D http_DEPRECATED_url_post ... 
 D PI 10I 0 
 D peURL 256A const 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFilename 256A const 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 
 D http_url_post PR 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFilename 32767A varying const options ( * varsize ) 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 
 c select 
 c when % parms = 4 
 c return http_url_post ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : % trimr ( peFileName ) 
 c ) 
 c when % parms = 5 
 c return http_url_post ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c ) 
 c when % parms = 6 
 c return http_url_post ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c ) 
 c when % parms = 7 
 c return http_url_post ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c : peContentType 
 c ) 
 c when % parms = 8 
 c return http_url_post ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : % trimr ( peFileName ) 
 c : peTimeout 
 c : peUserAgent 
 c : peContentType 
 c : peSoapAction 
 c ) 
 c endsl 
 P E 
 
 
 P http_DEPRECATED_url_get_raw ... 
 P B export 
 D http_DEPRECATED_url_get_raw ... 
 D PI 10I 0 
 D peURL 256A const 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peModTime Z const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 D http_url_get_raw ... 
 D PR 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 c select 
 c when % parms = 3 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c ) 
 c when % parms = 4 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c ) 
 c when % parms = 5 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c ) 
 c when % parms = 6 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c ) 
 c when % parms = 7 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c : peContentType 
 c ) 
 c when % parms = 8 
 c return http_url_get_raw ( % trimr ( peURL ) 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c : peModTime 
 c : peContentType 
 c : peSOAPAction 
 c ) 
 c endsl 
 P E 
 
 
 P http_DEPRECATED_url_post_raw ... 
 P B export 
 D http_DEPRECATED_url_post_raw ... 
 D PI 10I 0 
 D peURL 256A const 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass ) 
 D peContentType 64A const options ( * nopass ) 
 D peSOAPAction 64A const options ( * nopass ) 
 D http_url_post_raw ... 
 D PR 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peFD 10I 0 value 
 D peProc * value procptr 
 D peTimeout 10I 0 value options ( * nopass ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 c select 
 c when % parms = 5 
 c return http_url_post_raw ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : peFD 
 c : peProc 
 c ) 
 c when % parms = 6 
 c return http_url_post_raw ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c ) 
 c when % parms = 7 
 c return http_url_post_raw ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c ) 
 c when % parms = 8 
 c return http_url_post_raw ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c : peContentType 
 c ) 
 c when % parms = 9 
 c return http_url_post_raw ( % trimr ( peURL ) 
 c : pePostData 
 c : pePostDataLen 
 c : peFD 
 c : peProc 
 c : peTimeout 
 c : peUserAgent 
 c : peContentType 
 c : peSoapAction 
 c ) 
 c endsl 
 P E 
 
 
 
 
 P http_ParseURL B export 
 D http_ParseURL PI 10I 0 
 D peURL 256A const 
 D peService 32A 
 D peUserName 32A 
 D pePassword 32A 
 D peHost 256A 
 D pePort 10I 0 
 D pePath 256A 
 
 D wwHost s 1024A varying 
 D wwPath s 32767A varying 
 D rc s 10I 0 
 
 d http_long_ParseURL ... 
 D PR 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D peService 32A 
 D peUserName 32A 
 D pePassword 32A 
 D peHost 256A 
 D pePort 10I 0 
 D pePath 32767A varying 
 
 c eval rc = http_long_ParseURL ( % trimr ( peURL ) 
 c : peService 
 c : peUserName 
 c : pePassword 
 c : peHost 
 c : pePort 
 c : wwPath ) 
 
 c eval pePath = wwPath 
 
 c return rc 
 P E 
 
 
 P http_build_sockaddr ... 
 P B export 
 D http_build_sockaddr ... 
 D PI 10I 0 
 D peHost 256A const 
 D peService 32A const 
 D peForcePort 10I 0 value 
 D peSockAddr * 
 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 
 c return - 1 
 P E 
 
 
 P http_connect B export 
 D http_connect PI 10I 0 
 D peSockAddr * value 
 D peTimeout 10I 0 value 
 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 
 c return - 1 
 P E 
 
 
 P http_getraw ... 
 P B export 
 D http_getraw ... 
 D PI 10I 0 
 D peSock 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peModTime Z options ( * omit ) 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 c return - 1 
 P E 
 
 
 P http_postraw ... 
 P B export 
 d http_postraw ... 
 D PI 10I 0 
 D peSock 10I 0 value 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 c return - 1 
 P E 
 
 
 P https_getraw ... 
 P B export 
 D https_getraw ... 
 D PI 10I 0 
 D peSock * value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peModTime Z options ( * omit ) 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 c return - 1 
 P E 
 
 
 P https_postraw ... 
 P B export 
 D https_postraw ... 
 D PI 10I 0 
 D peSock * value 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peProcedure * value procptr 
 D peFile 10I 0 value 
 D peTimeout 10I 0 value 
 D peAbsPath 256A const 
 D peHost 256A const 
 D peUserAgent 64A options ( * omit ) 
 D peContentType 64A options ( * omit ) 
 D peSOAPAction 64A options ( * omit ) 
 c callp SetError ( HTTP_NOTSUPP 
 c : 'This function is no longer ' 
 c + 'supported ! ' ) 
 c return - 1 
 P E 
 
 
 
 
 P http_url_encoder_addvar ... 
 P B export 
 D http_url_encoder_addvar ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peData * value 
 D peDataSize 10I 0 value 
 D http_url_encoder_addvar_long ... 
 D PR 1N 
 D peEncoder * value 
 D peVariable * value options ( * string ) 
 D peData * value options ( * string ) 
 D peDataSize 10i 0 value 
 C return http_url_encoder_addvar_long ( 
 C peEncoder 
 C : peVariable 
 C : peData 
 C : peDataSize ) 
 P E 
 
 
 P http_url_encoder_addvar_s ... 
 P B export 
 D http_url_encoder_addvar_s ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peValue 256A varying value 
 c return http_url_encoder_addvar ( peEncoder 
 c : peVariable 
 c : % addr ( peValue ) + VARPREF 
 c : % len ( peValue ) ) 
 P E 
 
 
 P HTTP_SetTables B export 
 D HTTP_SetTables PI 10I 0 
 D peASCII 10A const 
 D peEBCDIC 10A const 
 D HTTP_MUTABLE C CONST ( 69 ) 
 c callp SetError ( HTTP_MUTABLE : 'HTTPAPI was ' 
 c + 'compiled to use CCSIDs ' 
 c + 'rather than Tables' ) 
 c return - 1 
 P E 
 / copy VERSION 
 
 H DFTACTGRP ( * NO ) 
 
 FCONFIGS CF E WORKSTN sfile ( CONFIG2S : WKRRN2 ) 
 F sfile ( CONFIG3S : WKRRN3 ) 
 FSRCPF UF F 112 DISK USROPN 
 
 / copy HTTPAPI_H 
 
 D QCMDEXC PR ExtPgm ( 'QCMDEXC' ) 
 D command 200A const 
 D length 15P 5 const 
 
 D WKRRN2 s 4P 0 
 D WKRRN3 s 4P 0 
 D wkVersion s like ( scVersion ) 
 D wkPos s 10I 0 
 D Teraspace s 1a inz ( * OFF ) 
 
 ISRCPF NS 
 I 13 90 WKLINE 
 
 c * entry plist 
 c parm peVersion 6 
 c parm peCancel 1 
 c parm peBldSSL 1 
 c parm peBldSamp 1 
 c parm peBldExpat 1 
 c parm peBldXml 1 
 c parm peSrcLib 10 
 c parm peInstLib 10 
 c parm peUseLibl 1 
 c parm peBldNtlm 1 
 
 c eval peCancel = 'N' 
 c eval * inlr = * on 
 
 c callp QCMDEXC ( 'OVRDBF FILE ( SRCPF ) ' 
 c + ' TOFILE ( QRPGLESRC ) ' 
 c + ' MBR ( LICENSE ) ' 
 c : 200 ) 
 
 c open SRCPF 
 c read ( N ) SRCPF 
 
 c dow not % eof ( SRCPF ) 
 c eval wkRRN2 = wkRRN2 + 1 
 c eval scLine = wkLine 
 c write CONFIG2S 
 c read ( N ) SRCPF 
 c enddo 
 
 c close SRCPF 
 c callp QCMDEXC ( 'DLTOVR FILE ( SRCPF ) ' 
 c : 200 ) 
 
 c callp QCMDEXC ( 'OVRDBF FILE ( SRCPF ) ' 
 c + ' TOFILE ( EXPAT ) ' 
 c + ' MBR ( COPYING ) ' 
 c : 200 ) 
 
 c open SRCPF 
 c read ( N ) SRCPF 
 
 c dow not % eof ( SRCPF ) 
 c eval wkRRN3 = wkRRN3 + 1 
 c eval scLine = wkLine 
 c write CONFIG3S 
 c read ( N ) SRCPF 
 c enddo 
 
 c close SRCPF 
 c callp QCMDEXC ( 'DLTOVR FILE ( SRCPF ) ' 
 c : 200 ) 
 
 c dou * INKH = * ON 
 
 c write CONFIG2F 
 c exfmt CONFIG2C 
 
 c if * INKC = * ON 
 c eval peCancel = 'Y' 
 c return 
 c endif 
 
 c enddo 
 
 c eval wkVersion = 'Version ' + HTTPAPI_VERSION 
 c + ' Released ' + HTTPAPI_RELDATE 
 c eval wkPos = % size ( scVersion ) / 2 
 c - % len ( % trimr ( wkVersion ) ) / 2 
 c + 1 
 c eval % subst ( scVersion : wkPos ) = wkVersion 
 
 c eval scBldSamp = 'Y' 
 c eval scBldSSL = 'N' 
 c eval scBldExpat = 'N' 
 c eval scBldXml = 'N' 
 
 / if defined ( HAVE_SSLAPI ) 
 c eval scBldSSL = 'Y' 
 / endif 
 
 c if peVersion < 'V4R5M0' 
 c eval scBldSSL = 'N' 
 c endif 
 
 c if peVersion >= 'V5R1M0' 
 c eval scBldExpat = 'Y' 
 c eval scBldXml = 'Y' 
 c endif 
 
 c dou ( scBldSamp = 'Y' or scBldSamp = 'N' ) 
 c and ( scBldSSL = 'Y' or scBldSSL = 'N' ) 
 
 c exfmt CONFIGS1 
 c if * INKC = * ON 
 c eval peCancel = 'Y' 
 c return 
 c endif 
 
 c enddo 
 
 c dou ( scBldXML = 'Y' or scBldXML = 'N' ) 
 c and ( scBldExpat = 'Y' or scBldExpat = 'N' ) 
 
 c exfmt CONFIGS4 
 c if * INKC = * ON 
 c eval peCancel = 'Y' 
 c return 
 c endif 
 
 c enddo 
 
 c if scBldExpat = 'Y' 
 
 c dou * INKH = * ON 
 
 c write CONFIG3F 
 c exfmt CONFIG3C 
 
 c if * INKC = * ON 
 c eval peCancel = 'Y' 
 c return 
 c endif 
 
 c enddo 
 
 c endif 
 
 c eval scSrcLib = peSrcLib 
 c eval scInstLib = peInstLib 
 c eval scUseLibl = 'Y' 
 
 c dou scMsg = * blanks 
 
 c exfmt CONFIGS5 
 c eval scMsg = * blanks 
 
 c if * INKC = * ON 
 c eval peCancel = 'Y' 
 c return 
 c endif 
 
 c if scUseLibl <> 'Y' and scUseLibl <> 'N' 
 C eval scMsg = 'Use * LIBL must be Y or N' 
 c endif 
 
 c if scSrcLib <> ' * LIBL' 
 c callp ( e ) QCMDEXC ( 'CHKOBJ OBJ ( ' + % trim ( scSrcLib ) 
 c + ' ) OBJTYPE ( * LIB ) ' : 200 ) 
 c if % error 
 c eval scMsg = 'Library ' + % trim ( scSrcLib ) 
 c + ' not found . ' 
 c endif 
 c endif 
 
 c if scInstLib <> ' * CURLIB' 
 c callp ( e ) QCMDEXC ( 'CHKOBJ OBJ ( ' + % trim ( scInstLib ) 
 c + ' ) OBJTYPE ( * LIB ) ' : 200 ) 
 c if % error 
 c eval scMsg = 'Library ' + % trim ( scInstLib ) 
 c + ' not found . ' 
 c endif 
 c endif 
 
 c enddo 
 
 
 c callp QCMDEXC ( 'OVRDBF FILE ( SRCPF ) ' 
 c + ' TOFILE ( QRPGLESRC ) ' 
 c + ' MBR ( CONFIG_H ) ' 
 c : 200 ) 
 
 c open SRCPF 
 c read SRCPF 
 
 c dow not % eof ( SRCPF ) 
 
 c if % scan ( 'HAVE_SSLAPI' : wkLine ) > 0 
 c if scBldSSL = 'Y' 
 c eval wkLine = ' D / define HAVE_SSLAPI' 
 c else 
 c eval wkLine = ' D / undefine HAVE_SSLAPI' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'HAVE_INT64' : wkLine ) > 0 
 c if peVersion >= 'V4R4M0' 
 c eval wkLine = ' D / define HAVE_INT64' 
 c else 
 c eval wkLine = ' D / undefine HAVE_INT64' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'HAVE_SRCSTMT_NODEBUGIO' : wkLine ) > 0 
 c if peVersion >= 'V4R4M0' 
 c eval wkLine = ' D / define HAVE_SRC' + 
 c 'STMT_NODEBUGIO' 
 c else 
 c eval wkLine = ' D / undefine HAVE_SRC' + 
 c 'STMT_NODEBUGIO' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'V4R5_GSKIT' : wkLine ) > 0 
 c if peVersion <= 'V4R5M0' and scBldSSL = 'Y' 
 c eval wkLine = ' D / define V4R5_GSKIT' 
 c else 
 c eval wkLine = ' D / undefine V4R5_GSKIT' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'V5R3_GSKIT' : wkLine ) > 0 
 c if peVersion >= 'V5R3M0' and scBldSSL = 'Y' 
 c eval wkLine = ' D / define V5R3_GSKIT' 
 c else 
 c eval wkLine = ' D / undefine V5R3_GSKIT' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'NTLM_SUPPORT' : wkLine ) > 0 
 c if peVersion >= 'V5R3M0' 
 c eval wkLine = ' D / define NTLM_SUPPORT' 
 c eval peBldNtlm = 'Y' 
 c else 
 c eval wkLine = ' D / undefine NTLM_SUPPORT' 
 c eval peBldNtlm = 'N' 
 c endif 
 c except updconfig 
 c endif 
 
 c if ( % subst ( wkLine : 7 : 2 ) = ' / d' 
 c or % subst ( wkLine : 7 : 2 ) = ' / D' ) 
 c if % scan ( 'TERASPACE' : wkLine ) > 0 
 c eval Teraspace = * on 
 c endif 
 c endif 
 
 c if % scan ( 'USE_TS_MALLOC64' : wkLine ) > 0 
 c if peVersion < 'V5R2M0' or Teraspace =* off 
 c eval wkLine = ' D / undefine ' 
 c + 'USE_TS_MALLOC64' 
 c else 
 c eval wkLine = ' D / define ' 
 c + 'USE_TS_MALLOC64' 
 c endif 
 c except updconfig 
 c endif 
 
 c if % scan ( 'HTTP_USE_CCSID' : wkLine ) > 0 
 c if peVersion >= 'V5R1M0' 
 c eval wkLine = ' D / define HTTP_USE_CCSID' 
 c else 
 c eval wkLine = ' D / undefine HTTP_USE_CCSID' 
 c endif 
 c except updconfig 
 c endif 
 
 c read SRCPF 
 c enddo 
 
 c close SRCPF 
 c callp QCMDEXC ( 'DLTOVR FILE ( SRCPF ) ' 
 c : 200 ) 
 
 c callp QCMDEXC ( 'OVRDBF FILE ( SRCPF ) ' 
 c + ' TOFILE ( QRPGLESRC ) ' 
 c + ' MBR ( HTTPAPI_H ) ' 
 c : 200 ) 
 
 c open SRCPF 
 c read SRCPF 
 
 c dow not % eof ( SRCPF ) 
 
 c if % scan ( 'qrpglesrc , config_h' : wkLine ) > 0 
 c if scSrcLib <> * blanks 
 c eval wkLine = ' / copy ' 
 c + % trim ( scSrcLib ) + ' / ' 
 c + 'qrpglesrc , config_h' 
 c except updconfig 
 c endif 
 c endif 
 
 c read SRCPF 
 c enddo 
 
 c close SRCPF 
 c callp QCMDEXC ( 'DLTOVR FILE ( SRCPF ) ' 
 c : 200 ) 
 
 c eval peBldSSL = scBldSSL 
 c eval peBldSamp = scBldSamp 
 c eval peCancel = 'N' 
 c eval peBldExpat = scBldExpat 
 c eval peBldXml = scBldXml 
 c eval peSrcLib = scSrcLib 
 c eval peInstLib = scInstLib 
 c eval peUseLibl = scUseLibl 
 c return 
 
 OSRCPF E updconfig 
 O wkLine 90 
 
 
 H NOMAIN 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * SRCSTMT ) 
 / endif 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy httpapi_h 
 / copy private_h 
 / copy ifsio_h 
 / copy errno_h 
 
 / if defined ( HTTP_USE_CCSID ) 
 D CCSID_OR_CP S 10I 0 inz ( O_CCSID ) 
 / else 
 D CCSID_OR_CP S 10I 0 inz ( O_CODEPAGE ) 
 / endif 
 
 D p_Mpr s * 
 D dsMpr ds based ( p_Mpr ) 
 D dsMpr_root 64A varying 
 D dsMpr_bound 64A varying 
 D dsMpr_fd 10I 0 
 D dsMpr_Data * 
 D dsMpr_StrPrc * procptr 
 D dsMpr_PrtPrc * procptr 
 D dsMpr_EndPrc * procptr 
 
 D upper C 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 
 D lower C 'abcdefghijklmnopqrstuvwxyz' 
 
 D part_header_parse ... 
 D PR 
 D resp 65535A varying const 
 
 D part_header_clean ... 
 D PR 
 
 D part_header_find ... 
 D PR 10I 0 
 D name 256A varying const 
 D pos 10I 0 value 
 
 D toUppercase PR 65535A varying 
 D peString 65535A varying const 
 
 D phdrs s 10I 0 inz ( 0 ) 
 
 D phdr ds occurs ( 4000 ) 
 D phdr_name 256A varying 
 D phdr_idx 10I 0 
 D phdr_len 10I 0 
 D phdr_fill 8A 
 D phdr_ptr * 
 
 D pheader s 32500A based ( p_pheader ) 
 
 P http_mpr_decoder_open ... 
 P B export 
 D http_mpr_decoder_open ... 
 D PI * 
 D peStmFile * value options ( * string ) 
 D peContType 256A const varying 
 D peUserData * value 
 D peStartProc * procptr value 
 D pePartProc * procptr value 
 D peEndProc * procptr value 
 
 D wwFilename s 32767a varying 
 D wwFD s 10I 0 
 D wwBoundary s 64A varying 
 D wwStartId s 64A varying 
 D wwRetVal s * 
 D pos1 s 10I 0 
 D pos2 s 10I 0 
 D isRoot s n 
 
 c eval wwFilename = % trimr ( % str ( peStmFile ) ) 
 c eval wwFD = open ( wwFilename : O_RDONLY ) 
 
 c if wwFD < 0 
 c callp SetError ( HTTP_IFOPEN 
 c : 'open ( ) : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return * NULL 
 c endif 
 
 c eval wwRetVal = xalloc ( % size ( dsMpr ) ) 
 
 c eval pos1 = % scan ( 'BOUNDARY = " ' 
 c : toUppercase ( peContType ) ) 
 c eval pos1 = pos1 + % len ( 'BOUNDARY = " ' ) 
 c eval pos2 = % scan ( ' " ' : peContType : pos1 ) 
 c eval wwBoundary = % subst ( peContType 
 c : pos1 
 c : pos2 - pos1 ) 
 
 c eval pos1 = % scan ( 'START = " ' 
 c : toUppercase ( peContType ) ) 
 c if pos1 > 0 
 c eval pos1 = pos1 + % len ( 'START = " ' ) 
 c eval pos2 = % scan ( ' " ' : peContType : pos1 ) 
 c eval wwStartId = % subst ( peContType 
 c : pos1 
 c : pos2 - pos1 ) 
 c endif 
 
 c eval p_Mpr = wwRetVal 
 c eval dsMpr_root = wwStartId 
 c eval dsMpr_bound = wwBoundary 
 c eval dsMpr_fd = wwFD 
 c eval dsMpr_Data = peUserData 
 c eval dsMpr_StrPrc = peStartProc 
 c eval dsMpr_PrtPrc = pePartProc 
 c eval dsMpr_EndPrc = peEndProc 
 
 c return wwRetVal 
 P E 
 
 
 P http_mpr_decoder_parse ... 
 P B export 
 D http_mpr_decoder_parse ... 
 D PI 1N 
 D peDecoder * value 
 
 D CRLFA c x'0d0a' 
 D CR c x'0d' 
 D p_buffer s * 
 D buffer s 1025A based ( p_buffer ) 
 
 D line s like ( buffer ) 
 D lineLen s 10I 0 
 D tbw s like ( buffer ) 
 D tbwLen s 10I 0 
 
 D rd s 10I 0 
 D bytesr s 10I 0 
 D left s 10I 0 
 
 D wwBound s 68A varying 
 D wwBoundEnd s 70A varying 
 
 D isRoot s N 
 D subHdrs s 10I 0 inz ( 0 ) 
 D subHdr ds occurs ( 4000 ) 
 D subHdr_name 256A varying 
 D subHdr_idx 10I 0 
 D subHdr_len 10I 0 
 D subHdr_fill 8A 
 D subHdr_ptr * 
 
 D Status s 10I 0 
 D STS_START c 0 
 D STS_PARTHEADER c 10 
 D STS_PARTLOAD c 20 
 D STS_END c 30 
 
 D wwHeader s 65535A varying 
 
 D p_startPrc s * procptr 
 D StartPrc PR extproc ( p_startPrc ) 
 D userdata * value 
 D isRoot N const 
 
 D p_partPrc s * procptr 
 D PartPrc PR extproc ( p_partPrc ) 
 D userdata * value 
 D data * value 
 D datalen 10I 0 const 
 
 D p_endPrc s * procptr 
 D EndPrc PR extproc ( p_endPrc ) 
 D userdata * value 
 
 / free 
 wwBound = ' -- ' + dsMpr_bound ; 
 http_xlatep ( % len ( wwBound ) : % addr ( wwBound ) + 2 : TO_ASCII ) ; 
 wwBoundEnd = ' -- ' + dsMpr_bound + ' -- ' ; 
 http_xlatep ( % len ( wwBoundEnd ) : % addr ( wwBoundEnd ) + 2 : TO_ASCII ) ; 
 p_startPrc = dsMpr_StrPrc ; 
 p_partPrc = dsMpr_PrtPrc ; 
 p_endPrc = dsMpr_EndPrc ; 
 
 Status = STS_START ; 
 p_buffer = xalloc ( % size ( buffer ) ) ; 
 
 exsr ReadLine ; 
 
 dow bytesr <> 0 ; 
 
 select ; 
 when Status = STS_START ; 
 if line = CRLFA ; 
 exsr ReadLine ; 
 iter ; 
 endif ; 
 if % subst ( line : 1 : % len ( wwBound ) ) = wwBound ; 
 isRoot = * off ; 
 if ( dsMpr_root = * blanks ) ; 
 isRoot = * on ; 
 endif ; 
 Status = STS_PARTHEADER ; 
 clear wwHeader ; 
 endif ; 
 
 
 when Status = STS_PARTHEADER ; 
 isRoot = * off ; 
 
 if line <> CRLFA ; 
 http_xlatep ( lineLen : % addr ( line ) : TO_EBCDIC ) ; 
 wwHeader = % trim ( wwHeader ) + % subst ( line : 1 : lineLen ) ; 
 else ; 
 part_header_parse ( wwHeader ) ; 
 wwHeader = % trim ( http_mpr_part_header ( 'content - id' ) ) ; 
 if ( ( wwHeader = dsMpr_root ) and ( dsMpr_root <> * blanks ) ) ; 
 isRoot = * on ; 
 endif ; 
 if ( p_startPrc <> * null ) ; 
 StartPrc ( dsMpr_data : isRoot ) ; 
 endif ; 
 Status = STS_PARTLOAD ; 
 endif ; 
 
 
 when Status = STS_PARTLOAD ; 
 tbw = line ; 
 tbwLen = lineLen ; 
 exsr ReadLine ; 
 if % subst ( line : 1 : % len ( wwBoundEnd ) ) = wwBoundEnd ; 
 if ( p_partPrc <> * null ) ; 
 PartPrc ( dsMpr_data : % addr ( tbw ) : tbwLen - 2 ) ; 
 endif ; 
 if ( p_endPrc <> * null ) ; 
 EndPrc ( dsMpr_data ) ; 
 endif ; 
 eval Status = STS_END ; 
 iter ; 
 endif ; 
 if % subst ( line : 1 : % len ( wwBound ) ) = wwBound ; 
 if ( p_partPrc <> * null ) ; 
 PartPrc ( dsMpr_data : % addr ( tbw ) : tbwLen - 2 ) ; 
 endif ; 
 if ( p_endPrc <> * null ) ; 
 EndPrc ( dsMpr_data ) ; 
 endif ; 
 eval Status = STS_PARTHEADER ; 
 iter ; 
 endif ; 
 if ( p_partPrc <> * null ) ; 
 PartPrc ( dsMpr_data : % addr ( tbw ) : tbwLen ) ; 
 iter ; 
 endif ; 
 
 endsl ; 
 
 exsr ReadLine ; 
 enddo ; 
 
 return * ON ; 
 
 //************************************************* 
 //* Read a new line 
 //************************************************* 
 begsr ReadLine ; 
 clear line ; 
 lineLen = 0 ; 
 
 //* Read the file a little more 
 rd = read ( dsMpr_fd : 
 p_buffer + left : 
 % size ( buffer ) - left - 1 ) ; 
 bytesr = rd + left ; 
 
 //* If nothing more left , leave 
 if bytesr = 0 ; 
 leavesr ; 
 endif ; 
 
 //* If the last byte is a CR , read one more byte 
 if % subst ( buffer : bytesr : 1 ) = CR ; 
 rd = read ( dsMpr_fd : p_buffer + bytesr : 1 ) ; 
 bytesr = bytesr + rd ; 
 endif ; 
 
 //* Search for the first CRLF , if not present , take it all 
 lineLen = % scan ( CRLFA : % subst ( buffer : 1 : bytesr ) ) ; 
 if lineLen <= 0 ; 
 lineLen = bytesr ; 
 else ; 
 lineLen = lineLen + 1 ; 
 endif ; 
 line = % subst ( buffer : 1 : lineLen ) ; 
 
 //* Remember what's left to read and update the buffer 
 left = bytesr - lineLen ; 
 if left > 0 ; 
 memcpy ( p_buffer : p_buffer + lineLen : left ) ; 
 endif ; 
 endsr ; 
 
 / end - free 
 P E 
 
 
 P http_mpr_decoder_close ... 
 P B export 
 D http_mpr_decoder_close ... 
 D PI 
 D peDecoder * value 
 
 c callp close ( dsMpr_fd ) 
 c callp xdealloc ( peDecoder ) 
 
 P E 
 
 
 P part_header_parse ... 
 P B 
 D part_header_parse ... 
 D PI 
 D resp 65535A varying const 
 
 D name s 256A varying 
 D val s 32500A varying 
 D CRLF c x'0d25' 
 D next s 10I 0 inz ( 1 ) 
 D eoh s 10I 0 
 D eok s 10I 0 
 D len s 10I 0 
 
 c callp part_header_clean 
 
 c dow next < % len ( resp ) 
 
 c eval eoh = % scan ( CRLF : resp : next ) 
 c if eoh = 0 
 c leave 
 c endif 
 
 c eval eok = % scan ( ' : ' : resp : next ) 
 c if eok = 0 or eok = next or eok > eoh 
 c eval next = eoh + 2 
 c iter 
 c endif 
 
 c eval len = eok - next 
 c eval name = % subst ( resp : next : len ) 
 c eval name = ToUppercase ( name ) 
 c eval len = ( eoh - eok ) - 1 
 
 c if len = 0 
 c eval % len ( val ) = 0 
 c else 
 c eval val = % subst ( resp : eok + 1 : len ) 
 c endif 
 
 c if phdrs < % elem ( phdr ) 
 
 c if len = 0 
 c eval p_pHeader = * null 
 c else 
 c eval p_pHeader = xalloc ( len ) 
 c eval % subst ( pheader : 1 : len ) = val 
 c endif 
 
 c eval phdrs = phdrs + 1 
 C phdrs occur phdr 
 c eval phdr_name = name 
 c eval phdr_idx = phdrs 
 c eval phdr_len = len 
 c eval phdr_ptr = p_pheader 
 
 c endif 
 
 c eval next = eoh + 2 
 c enddo 
 
 P E 
 
 
 P part_header_clean ... 
 P B 
 D part_header_clean ... 
 D PI 
 D i s 10I 0 
 c 1 do phdrs i 
 c i occur phdr 
 c eval phdr_idx = 0 
 c eval phdr_len = 0 
 c if phdr_ptr <> * null 
 c callp xdealloc ( phdr_ptr ) 
 c endif 
 c enddo 
 c eval phdrs = 0 
 c eval p_pheader = * NULL 
 P E 
 
 
 P part_header_find ... 
 P B 
 D part_header_find ... 
 D PI 10I 0 
 D name 256A varying const 
 D pos 10I 0 value 
 
 D x s 10I 0 
 D count s 10I 0 
 D found s 10I 0 
 
 c eval count = 0 
 c eval found = 0 
 
 c 1 do phdrs x 
 c x occur phdr 
 
 c if phdr_name = name 
 c eval count = count + 1 
 c if count = pos 
 c eval found = x 
 c leave 
 c endif 
 c endif 
 
 c enddo 
 
 c return found 
 P E 
 
 
 P http_mpr_part_header ... 
 P B export 
 D PI 32500A varying 
 D name 256A varying const 
 D pos 10I 0 value options ( * nopass ) 
 
 D lname s 256a varying 
 D p s 10I 0 inz ( 1 ) 
 D found s 10I 0 
 
 c if % parms >= 2 
 c eval p = pos 
 c endif 
 
 c eval lname = name 
 c eval lname = ToUppercase ( lname ) 
 
 c eval found = part_header_find ( lname : p ) 
 c if found < 1 
 c return '' 
 c endif 
 
 c found occur phdr 
 c if phdr_len = 0 
 c return '' 
 c else 
 c eval p_pheader = phdr_ptr 
 c return % subst ( pheader : 1 : phdr_len ) 
 c endif 
 P E 
 
 
 P toUppercase B 
 D toUppercase PI 65535A varying 
 D peString 65535A varying const 
 c return % xlate ( lower : upper : peString ) 
 P E 
 
 
 / define ERRNO_LOAD_PROCEDURE 
 / copy errno_h 
 
 
 
 H NOMAIN 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * SRCSTMT ) 
 / endif 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy httpapi_h 
 / copy private_h 
 / copy ifsio_h 
 / copy errno_h 
 
 / if defined ( HTTP_USE_CCSID ) 
 D CCSID_OR_CP S 10I 0 inz ( O_CCSID ) 
 / else 
 D CCSID_OR_CP S 10I 0 inz ( O_CODEPAGE ) 
 / endif 
 
 D memset PR * ExtProc ( 'memset' ) 
 D ptr * value 
 D value 10I 0 value 
 D length 10U 0 value 
 
 D p_Encoder s * 
 D dsEncoder DS based ( p_Encoder ) 
 D dsEnc_Len 10I 0 
 D dsEnc_Size 10I 0 
 D dsEnc_Data * 
 D dsEnc_Space 1A 
 D dsEnc_Spec 25A 
 D dsEnc_HexAll 512A 
 D dsEnc_Hex 2A dim ( 256 ) overlay ( dsEnc_HexAll ) 
 
 D p_Mfd s * 
 D dsMfd ds based ( p_Mfd ) 
 D dsMfd_bound 32A 
 D dsMfd_fd 10I 0 
 
 D p_Mpr s * 
 D dsMpr ds based ( p_Mpr ) 
 D dsMpr_bound 32A 
 D dsMpr_fd 10I 0 
 
 D http_url_encoder_addvar_long ... 
 D PR 1N 
 D peEncoder * value 
 D peVariable * value options ( * string ) 
 D peData * value options ( * string ) 
 D peDataSize 10i 0 value 
 D http_url_encoder_addvar_long_s ... 
 D PR 1N 
 D peEncoder * value 
 D peVariable * value options ( * string ) 
 D peValue * value options ( * string ) 
 
 P base64_init B export 
 D base64_init PI 
 D peBase64 * value 
 D p_Base64 S * 
 D wwBase64 S 64A based ( p_Base64 ) 
 c eval p_Base64 = peBase64 
 c eval wwBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 
 c 'abcdefghijklmnopqrstuvwxyz' + 
 c '0123456789 +/ ' 
 P E 
 
 
 P base64_encode B export 
 D base64_encode PI 10I 0 
 D peInput * value 
 D peInputLen 10I 0 value 
 D peOutput * value 
 D peOutSize 10I 0 value 
 
 D base64 S 1A dim ( 64 ) static 
 D wwInit S 1N inz ( * OFF ) static 
 
 D dsCvt DS 
 D wwNumb 1 2U 0 inz ( 0 ) 
 D wwByte 2 2A 
 
 D p_Data S * 
 D dsData DS based ( p_Data ) 
 D ds8B1 1A 
 D ds8B2 1A 
 D ds8B3 1A 
 
 D p_OutData S * 
 D wwOutData S 4A based ( p_OutData ) 
 D wwOut S 4A 
 D wwPos S 10I 0 
 D wwOutLen S 10I 0 
 
 c if not wwInit 
 c callp base64_init ( % addr ( base64 ) ) 
 c eval wwInit = * On 
 c endif 
 
 c eval p_Data = peInput 
 c eval p_OutData = peOutput 
 
 c eval wwPos = 1 
 c dow wwPos <= peInputLen 
 
 c move ds8B1 wwByte 
 c bitoff x'03' wwByte 
 c div 4 wwNumb 
 c eval % subst ( wwOut : 1 ) = base64 ( wwNumb + 1 ) 
 
 c move ds8B1 wwByte 
 c bitoff x'FC' wwByte 
 c mult 16 wwNumb 
 
 c if wwPos + 1 <= peInputLen 
 c move wwByte wwSave 1 
 c move ds8B2 wwByte 
 c bitoff x'0F' wwByte 
 c div 16 wwNumb 
 c biton wwSave wwByte 
 c endif 
 
 c eval % subst ( wwOut : 2 ) = base64 ( wwNumb + 1 ) 
 
 
 c if wwPos + 1 > peInputLen 
 
 c eval % subst ( wwOut : 3 ) = ' = ' 
 
 c else 
 
 c move ds8B2 wwByte 
 c bitoff x'F0' wwByte 
 c mult 4 wwNumb 
 
 c if wwPos + 2 <= peInputLen 
 c move wwByte wwSave 
 c move ds8B3 wwByte 
 c bitoff x'3F' wwByte 
 c div 64 wwNumb 
 c biton wwSave wwByte 
 c endif 
 
 c eval % subst ( wwOut : 3 ) = base64 ( wwNumb + 1 ) 
 
 c endif 
 
 c if wwPos + 2 > peInputLen 
 c eval % subst ( wwOut : 4 : 1 ) = ' = ' 
 c else 
 c move ds8B3 wwByte 
 c bitoff x'C0' wwByte 
 c eval % subst ( wwOut : 4 ) = base64 ( wwNumb + 1 ) 
 c endif 
 
 c eval wwOutLen = wwOutLen + 4 
 c if wwOutLen <= peOutSize 
 c eval wwOutData = wwOut 
 c eval p_Outdata = p_Outdata + 4 
 c endif 
 
 c eval p_Data = p_Data + 3 
 c eval wwPos = wwPos + 3 
 
 c enddo 
 
 c return wwOutLen 
 P E 
 
 
 P http_url_encoder_new ... 
 P B export 
 D http_url_encoder_new ... 
 D PI * 
 
 D cvthc PR EXTPROC ( 'cvthc' ) 
 D output 512A 
 D input 256A 
 D output_len 10I 0 value 
 
 D ds 
 D dsCh1 1 1A 
 D dsCh 2 2A 
 D dsBin 1 2U 0 inz ( 0 ) 
 
 D wwRetVal s * 
 
 D wwSpace s 1A inz ( ' ' ) 
 D wwBuf s 256A 
 D x s 10I 0 
 
 c eval wwRetVal = xalloc ( % size ( dsEncoder ) ) 
 
 c eval p_Encoder = wwRetVal 
 c eval dsEnc_Len = 0 
 c eval dsEnc_Size = 0 
 c eval dsEnc_Data = * NULL 
 c eval dsEnc_Space = wwSpace 
 c eval dsEnc_Spec = get_symbols 
 
 c 1 do 256 x 
 c eval dsBin = x - 1 
 c eval % subst ( wwBuf : x : 1 ) = dsCh 
 c enddo 
 
 c callp cvthc ( dsEnc_HexAll 
 c : wwBuf 
 c : % size ( dsEnc_HexAll ) ) 
 
 c callp http_xlate ( % size ( dsEnc_Space ) 
 c : dsEnc_Space 
 c : TO_ASCII ) 
 
 c callp http_xlate ( % size ( dsEnc_Spec ) 
 c : dsEnc_Spec 
 c : TO_ASCII ) 
 
 c callp http_xlate ( % size ( dsEnc_HexAll ) 
 c : dsEnc_HexAll 
 c : TO_ASCII ) 
 
 c return wwRetVal 
 P E 
 
 
 P http_url_encoder_free ... 
 P B export 
 D http_url_encoder_free ... 
 D PI 1N 
 D peEncoder * value 
 
 c eval p_Encoder = peEncoder 
 
 c callp ( e ) xdealloc ( dsEnc_Data ) 
 c if % error 
 c return * OFF 
 c endif 
 
 c callp ( e ) xdealloc ( p_Encoder ) 
 c if % error 
 c return * OFF 
 c endif 
 
 c eval p_Encoder = * NULL 
 c return * ON 
 P E 
 
 
 P url_encode_pre B export 
 D url_encode_pre PI 10I 0 
 D peEncoder * value 
 D peInput * value 
 D peInpLen 10I 0 value 
 
 D p_Deref s * 
 D wwDeref s 1A based ( p_Deref ) 
 
 D wwPos s 10I 0 
 D wwLen s 10I 0 
 D wwCheck s 10I 0 
 
 c eval p_Encoder = peEncoder 
 c eval p_Deref = peInput 
 
 c 1 do peInpLen wwPos 
 
 
 c dsEnc_Spec check wwDeref wwCheck 
 c if wwCheck = 0 
 c or wwDeref < x'20' 
 c or wwDeref > x'7F' 
 c eval wwLen = wwLen + 3 
 c else 
 c eval wwLen = wwLen + 1 
 c endif 
 
 c eval p_Deref = p_Deref + 1 
 c enddo 
 
 c return wwLen 
 P E 
 
 
 P url_encode B export 
 D url_encode PI 
 D peEncoder * value 
 D peInput * value 
 D peInpLen 10I 0 value 
 D peLoc * value 
 D peLocSize 10I 0 value 
 
 D cvthc PR EXTPROC ( 'cvthc' ) 
 D output 2A 
 D input 1A 
 D output_len 10I 0 value 
 
 D p_Deref s * 
 D wwDeref s 1A based ( p_Deref ) 
 
 D p_ResChar s * 
 D wwResChar s 2A based ( p_ResChar ) 
 
 D ds 
 D wwVal 1 2U 0 inz ( 0 ) 
 D wwChar 2 2A 
 
 D wwPos s 10I 0 
 D wwCheck s 10I 0 
 
 c eval p_Encoder = peEncoder 
 
 c eval p_deref = peInput 
 c eval p_reschar = peLoc 
 
 c 1 do peInpLen wwPos 
 
 c if wwPos <> 1 
 c eval p_deref = p_deref + 1 
 c endif 
 
 c dsEnc_Spec check wwDeref wwCheck 
 
 c select 
 c when wwDeref = dsEnc_Space 
 c eval % subst ( wwResChar : 1 : 1 ) = 
 c % subst ( dsEnc_Spec : 6 : 1 ) 
 c eval p_reschar = p_reschar + 1 
 
 c when wwCheck = 0 
 c or wwDeref < x'20' 
 c or wwDeref > x'7F' 
 
 c eval % subst ( wwResChar : 1 : 1 ) = 
 c % subst ( dsEnc_Spec : 7 : 1 ) 
 c eval p_ResChar = p_ResChar + 1 
 
 c eval wwChar = wwDeref 
 c eval wwResChar = dsEnc_Hex ( wwVal + 1 ) 
 c eval p_ResChar = p_ResChar + 2 
 
 c other 
 c eval % subst ( wwResChar : 1 : 1 ) = wwDeref 
 c eval p_reschar = p_reschar + 1 
 c endsl 
 
 c enddo 
 
 c callp http_xlatep ( peLocSize 
 c : peLoc 
 c : TO_EBCDIC ) 
 
 c return 
 P E 
 
 
 P http_url_encoder_addvar_long ... 
 P B export 
 D http_url_encoder_addvar_long ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable * value options ( * string ) 
 D peData * value options ( * string ) 
 D peDataSize 10i 0 value 
 
 D ENCBLOCK C 8192 
 
 D p_Deref s * 
 D wwDeref s 1A based ( p_Deref ) 
 
 D wwLenVar s 10I 0 
 D wwLenData s 10I 0 
 D wwNewLen s 10I 0 
 D wwNewSize s 10I 0 
 
 D wwVarXLen s 10i 0 
 D wwDataXLen s 10i 0 
 D p_VarX s * 
 D p_DataX s * 
 
 c eval p_Encoder = peEncoder 
 
 c if % len ( % str ( peVariable ) ) = 0 
 c return * off 
 c endif 
 
 c eval wwVarXLen = 
 c http_xlatedyn ( % len ( % str ( peVariable ) ) 
 c : peVariable 
 c : TO_ASCII 
 c : p_VarX ) 
 
 c if peDataSize = 0 
 c eval wwDataXLen = 0 
 c eval p_DataX = * null 
 c else 
 c eval wwDataXLen = 
 c http_xlatedyn ( peDataSize 
 c : peData 
 c : TO_ASCII 
 c : p_DataX ) 
 c endif 
 
 
 c eval wwLenVar = 
 c url_encode_pre ( peEncoder 
 c : p_VarX 
 c : wwVarXLen ) 
 
 c eval wwLenData = 
 c url_encode_pre ( peEncoder 
 c : p_DataX 
 c : wwDataXLen ) 
 
 c eval wwNewLen = dsEnc_Len + 
 c wwLenVar + % len ( ' = ' ) + wwLenData 
 
 c if dsEnc_Len > 0 
 c eval wwNewLen = wwNewLen + % len ( ' & ' ) 
 c endif 
 
 c eval wwNewSize = dsEnc_Size 
 
 c if wwNewSize < wwNewLen 
 
 c dow wwNewSize < wwNewLen 
 c eval wwNewSize = wwNewSize + ENCBLOCK 
 c enddo 
 
 c eval dsEnc_Data = xrealloc ( dsEnc_data 
 c : wwNewSize ) 
 
 c if dsEnc_Data = * null 
 c callp xdealloc ( p_VarX ) 
 c callp xdealloc ( p_DataX ) 
 c return * OFF 
 c endif 
 
 c callp memset ( dsEnc_Data + dsEnc_Size 
 c : 0 
 c : wwNewSize - dsEnc_Size ) 
 
 c eval dsEnc_Size = wwNewSize 
 c endif 
 
 c if dsEnc_Len > 0 
 c eval p_deref = dsEnc_Data + dsEnc_Len 
 c eval wwDeref = ' & ' 
 c eval dsEnc_Len = dsEnc_Len + % len ( ' & ' ) 
 c endif 
 
 c callp url_encode ( peEncoder 
 c : p_VarX 
 c : wwVarXLen 
 c : dsEnc_Data + dsEnc_Len 
 c : wwLenVar ) 
 c eval dsEnc_Len = dsEnc_Len + wwLenVar 
 c callp xdealloc ( p_VarX ) 
 
 c eval p_deref = dsEnc_Data + dsEnc_Len 
 c eval wwDeref = ' = ' 
 c eval dsEnc_Len = dsEnc_Len + % len ( ' = ' ) 
 
 c if wwDataXLen > 0 
 c callp url_encode ( peEncoder 
 c : p_DataX 
 c : wwDataXLen 
 c : dsEnc_Data + dsEnc_Len 
 c : wwLenData ) 
 c eval dsEnc_Len = dsEnc_Len + wwLenData 
 c callp xdealloc ( p_DataX ) 
 c endif 
 
 c return * ON 
 P E 
 
 
 P http_urlEncode B export 
 D PI 65535a varying 
 D input * value options ( * string ) 
 
 D inputLen s 10i 0 
 D XLen s 10i 0 
 D p_inputX s * 
 D myEnc s * 
 D EncLen s 10i 0 
 D Output s 65535a varying 
 
 / free 
 
 if input = * null ; 
 return '' ; 
 endif ; 
 
 inputLen = % len ( % str ( input ) ) ; 
 if inputLen < 1 ; 
 return '' ; 
 endif ; 
 
 XLen = http_xlatedyn ( inputLen 
 : input 
 : TO_NETWORK 
 : p_inputX ) ; 
 
 if XLen = 0 or p_InputX =* null ; 
 return '' ; 
 endif ; 
 
 myEnc = http_url_encoder_new ( ) ; 
 if myEnc = * null ; 
 xdealloc ( p_inputX ) ; 
 return '' ; 
 endif ; 
 
 EncLen = url_encode_pre ( myEnc 
 : p_inputX 
 : XLen ) ; 
 
 if EncLen < 1 ; 
 xdealloc ( p_InputX ) ; 
 http_url_encoder_free ( myEnc ) ; 
 return '' ; 
 endif ; 
 
 % len ( Output ) = EncLen ; 
 
 url_encode ( myEnc 
 : p_inputX 
 : XLen 
 : % addr ( Output ) + VARPREF 
 : EncLen ) ; 
 
 http_url_encoder_free ( myEnc ) ; 
 xdealloc ( p_inputX ) ; 
 
 return Output ; 
 / end - free 
 P E 
 
 
 P http_url_encoder_getptr ... 
 P B export 
 D http_url_encoder_getptr ... 
 D PI 
 D peEncoder * value 
 D peData * 
 D peSize 10I 0 
 c eval p_Encoder = peEncoder 
 c eval peData = dsEnc_data 
 c eval peSize = dsEnc_len 
 P E 
 
 
 P http_url_encoder_getstr ... 
 P B export 
 D http_url_encoder_getstr ... 
 D PI 32767A varying 
 D peEncoder * value 
 
 D len s 10i 0 
 D wwRet s 32767A varying 
 
 c eval p_Encoder = peEncoder 
 c eval len = % size ( wwRet ) - VARPREF 
 
 c if dsEnc_Len < len 
 c eval len = dsEnc_len 
 c endif 
 
 c eval % len ( wwRet ) = len 
 
 c callp memcpy ( % addr ( wwRet ) + VARPREF 
 c : dsEnc_Data 
 c : len ) 
 
 c return wwRet 
 P E 
 
 
 P http_url_encoder_addvar_long_s ... 
 P B export 
 D http_url_encoder_addvar_long_s ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable * value options ( * string ) 
 D peValue * value options ( * string ) 
 c return http_url_encoder_addvar_long ( 
 c peEncoder 
 c : peVariable 
 c : peValue 
 c : % len ( % str ( peValue ) ) 
 c ) 
 P E 
 
 
 P http_mfd_encoder_open ... 
 P B export 
 D http_mfd_encoder_open ... 
 D PI * 
 D peStmFile * value options ( * string ) 
 D peContType 64A 
 
 D wwFilename s 32767a varying 
 D wwFD s 10I 0 
 D wwTS s Z 
 D wwTsStr s 26A 
 D wwBoundary s 32A 
 D wwRetVal s * 
 
 c eval wwFilename = % trimr ( % str ( peStmFile ) ) 
 c eval wwFD = open ( wwFilename 
 c : O_WRONLY + 
 c O_CREAT + 
 c O_TRUNC + 
 c CCSID_OR_CP 
 c : HTTP_IFSMODE 
 c : FILE_CCSID ) 
 
 c if wwFD < 0 
 c callp SetError ( HTTP_IFOPEN 
 c : 'open ( ) : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return * NULL 
 c endif 
 
 c eval wwRetVal = xalloc ( % size ( dsMfd ) ) 
 
 c time wwTS 
 c move wwTS wwTsStr 
 c eval wwBoundary = ' - httpapi - ' + wwTsStr 
 
 c eval p_Mfd = wwRetVal 
 c eval dsMfd_fd = wwFD 
 c eval dsMfd_bound = wwBoundary 
 
 c eval peContType = 'multipart / form - data ; ' 
 c + 'boundary = ' + wwBoundary 
 
 c return wwRetVal 
 P E 
 
 
 P http_mfd_encoder_addvar ... 
 P B export 
 D http_mfd_encoder_addvar ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peData * value 
 D peDataSize 10I 0 value 
 D peContType 32767a varying const 
 D options ( * varsize : * nopass : * omit ) 
 
 D CRLF c x'0d25' 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 33791A varying 
 
 c eval p_Mfd = peEncoder 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 
 c eval wwLine = ' -- ' + dsMfd_bound + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Disposition : ' 
 c + 'form - data ; ' 
 c + 'name = " ' + peVariable + ' " ' 
 c + CRLF 
 c if % parms >= 5 and % addr ( peContType ) <>* null 
 c eval wwLine += 'Content - Type : ' + peContType 
 c + CRLF 
 c endif 
 c eval wwLine += CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c eval p_LD = peData 
 c callp http_xlate ( peDataSize : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : peDataSize ) 
 c callp http_xlate ( peDataSize : wwLD : TO_EBCDIC ) 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c return * ON 
 P E 
 
 
 P http_mfd_encoder_addvar_s ... 
 P B export 
 D http_mfd_encoder_addvar_s ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D peValue 256A varying value 
 D peContType 32767a varying const 
 D options ( * varsize : * nopass : * omit ) 
 c if % parms >= 4 and % addr ( peContType ) <>* null 
 c return http_mfd_encoder_addvar ( peEncoder 
 c : peVariable 
 c : % addr ( peValue ) + VARPREF 
 c : % len ( peValue ) 
 c : peContType ) 
 c else 
 c return http_mfd_encoder_addvar ( peEncoder 
 c : peVariable 
 c : % addr ( peValue ) + VARPREF 
 c : % len ( peValue ) ) 
 c endif 
 P E 
 
 
 P http_mfd_encoder_addstmf ... 
 P B export 
 D http_mfd_encoder_addstmf ... 
 D PI 1N 
 D peEncoder * value 
 D peVariable 50A varying value 
 D pePathName * value options ( * string ) 
 D peContType 32767a varying const 
 D options ( * varsize ) 
 
 D wwfilename s 32767a varying 
 D CRLF c x'0d25' 
 D wwFd s 10I 0 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 32791A varying 
 D wwBuffer s 32767A 
 D wwLen s 10I 0 
 D showfn s 1n inz ( * on ) 
 
 c eval p_Mfd = peEncoder 
 
 c eval wwFilename = % trimr ( % str ( pePathname ) ) 
 c if % len ( wwFilename ) > 7 
 c and % subst ( wwFilename : 1 : 7 ) = 'noshow : ' 
 c eval showfn = * off 
 c eval wwFilename = % subst ( wwFilename : 8 ) 
 c endif 
 
 c eval wwFD = open ( wwFilename : O_RDONLY ) 
 c if wwFD < 0 
 c callp SetError ( HTTP_IFOPEN 
 c : 'open ( ) : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return * OFF 
 c endif 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = ' -- ' + dsMfd_bound + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Disposition : ' 
 c + 'form - data ; ' 
 c + 'name = " ' + peVariable + ' " ' 
 c if showfn = * on 
 c eval wwLine += ' ; filename = " ' 
 c + % str ( pePathName ) + ' " ' 
 c endif 
 c eval wwLine += CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Type : ' 
 c + peContType 
 c + CRLF 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLen = read ( wwFd 
 c : % addr ( wwBuffer ) 
 c : % size ( wwBuffer ) ) 
 c dow wwLen > 0 
 c callp write ( dsMfd_fd 
 c : % addr ( wwBuffer ) 
 c : wwLen ) 
 c eval wwLen = read ( wwFd 
 c : % addr ( wwBuffer ) 
 c : % size ( wwBuffer ) ) 
 c enddo 
 
 c eval wwLine = CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c callp close ( wwFD ) 
 
 c return * ON 
 P E 
 
 
 P http_mfd_encoder_close ... 
 P B export 
 D http_mfd_encoder_close ... 
 D PI 
 D peEncoder * value 
 
 D CRLF c x'0d25' 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 1024A varying 
 
 c eval p_mfd = peEncoder 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = ' -- ' + dsMfd_Bound + ' -- ' 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMfd_fd : p_LD : % len ( wwLine ) ) 
 
 c callp close ( dsMfd_fd ) 
 
 c callp xdealloc ( p_mfd ) 
 P E 
 
 
 P http_mpr_encoder_open ... 
 P B export 
 D http_mpr_encoder_open ... 
 D PI * 
 D peStmFile * value options ( * string ) 
 D peType 64A varying const 
 D peContType 256A 
 D peStartRef 64A varying const options ( * nopass ) 
 D peStartInfo 64A varying const options ( * nopass ) 
 
 D wwFilename s 32767a varying 
 D wwFD s 10I 0 
 D wwTS s Z 
 D wwTsStr s 26A 
 D wwBoundary s 32A 
 D wwRetVal s * 
 
 c eval wwFilename = % trimr ( % str ( peStmFile ) ) 
 c eval wwFD = open ( wwFilename 
 c : O_WRONLY + 
 c O_CREAT + 
 c O_TRUNC + 
 c CCSID_OR_CP 
 c : HTTP_IFSMODE 
 c : FILE_CCSID ) 
 
 c if wwFD < 0 
 c callp SetError ( HTTP_IFOPEN 
 c : 'open ( ) : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return * NULL 
 c endif 
 
 c eval wwRetVal = xalloc ( % size ( dsMpr ) ) 
 
 c time wwTS 
 c move wwTS wwTsStr 
 c eval wwBoundary = ' - httpapi - ' + wwTsStr 
 
 c eval p_Mpr = wwRetVal 
 c eval dsMpr_bound = wwBoundary 
 c eval dsMpr_fd = wwFD 
 
 c eval peContType = 'multipart / related ; ' 
 c + 'type = " ' + % trim ( peType ) + ' " ; ' 
 c + 'boundary = ' + wwBoundary 
 c if % parms > 3 
 c eval peContType = % trim ( peContType ) + ' ; ' 
 c + 'start = " ' + % trim ( peStartRef ) 
 c + ' " ' 
 c endif 
 c if % parms > 4 
 c eval peContType = % trim ( peContType ) + ' ; ' 
 c + 'start - info = " ' 
 c + % trim ( peStartInfo ) 
 c + ' " ' 
 c endif 
 
 c return wwRetVal 
 P E 
 
 
 P http_mpr_encoder_addstr ... 
 P B export 
 D http_mpr_encoder_addstr ... 
 D PI 1N 
 D peEncoder * value 
 D peData * value 
 D peDataSize 10I 0 value 
 D peContType 256A varying const 
 D peContID 64A varying const 
 
 D CRLF c x'0d25' 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 1024A varying 
 
 c eval p_Mpr = peEncoder 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 
 c eval wwLine = ' -- ' + dsMpr_bound + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Type : ' 
 c + peContType 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Transfer - Encoding : ' 
 c + '8bit' 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Id : ' 
 c + peContId 
 c + CRLF 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval p_LD = peData 
 c callp http_xlate ( peDataSize : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : peDataSize ) 
 c callp http_xlate ( peDataSize : wwLD : TO_EBCDIC ) 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c return * ON 
 P E 
 
 
 P http_mpr_encoder_addstr_s ... 
 P B export 
 D http_mpr_encoder_addstr_s ... 
 D PI 1N 
 D peEncoder * value 
 D peData 32767A varying value 
 D peContType 256A varying const 
 D peContID 64A varying const 
 c return http_mpr_encoder_addstr ( peEncoder 
 c : % addr ( peData ) + VARPREF 
 c : % len ( peData ) 
 c : peContType 
 c : peContId ) 
 P E 
 
 
 P http_mpr_encoder_addstmf ... 
 P B export 
 D http_mpr_encoder_addstmf ... 
 D PI 1N 
 D peEncoder * value 
 D pePathName * value options ( * string ) 
 D peContType 256A varying const 
 D peContID 64A varying const 
 
 D wwfilename s 32767a varying 
 D CRLF c x'0d25' 
 D wwFd s 10I 0 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 1024A varying 
 D wwBuffer s 32767A 
 D wwLen s 10I 0 
 
 c eval p_Mpr = peEncoder 
 
 c eval wwFilename = % trimr ( % str ( pePathname ) ) 
 c eval wwFD = open ( wwFilename : O_RDONLY ) 
 c if wwFD < 0 
 c callp SetError ( HTTP_IFOPEN 
 c : 'open ( ) : ' 
 c + % str ( strerror ( errno ) ) ) 
 c return * OFF 
 c endif 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = ' -- ' + dsMpr_bound + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Type : ' 
 c + % trim ( peContType ) 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Transfer - Encoding : ' 
 c + 'binary' 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLine = 'Content - Id : ' 
 c + % trim ( peContId ) 
 c + CRLF 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c eval wwLen = read ( wwFd 
 c : % addr ( wwBuffer ) 
 c : % size ( wwBuffer ) ) 
 c dow wwLen > 0 
 c callp write ( dsMpr_fd 
 c : % addr ( wwBuffer ) 
 c : wwLen ) 
 c eval wwLen = read ( wwFd 
 c : % addr ( wwBuffer ) 
 c : % size ( wwBuffer ) ) 
 c enddo 
 
 c eval wwLine = CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c callp close ( wwFD ) 
 
 c return * ON 
 P E 
 
 
 P http_mpr_encoder_close ... 
 P B export 
 D http_mpr_encoder_close ... 
 D PI 
 D peEncoder * value 
 
 D CRLF c x'0d25' 
 D p_LD s * 
 D wwLD s 1A based ( p_LD ) 
 D wwLine s 1024A varying 
 
 c eval p_mpr = peEncoder 
 
 c eval p_LD = % addr ( wwLine ) + VARPREF 
 c eval wwLine = ' -- ' + dsMpr_Bound + ' -- ' 
 c + CRLF 
 c callp http_xlate ( % len ( wwLine ) : wwLD : TO_ASCII ) 
 c callp write ( dsMpr_fd : p_LD : % len ( wwLine ) ) 
 
 c callp close ( dsMpr_fd ) 
 
 c callp xdealloc ( p_mpr ) 
 P E 
 
 / define ERRNO_LOAD_PROCEDURE 
 / copy errno_h 
 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * NOSHOWCPY : * SRCSTMT : * NODEBUGIO ) 
 / endif 
 H NOMAIN 
 / DEFINE RC4_INTERNAL_USE 
 / DEFINE MD4_INTERNAL_USE 
 / DEFINE MD5_INTERNAL_USE 
 / COPY NTLM_H 
 / COPY NTLM_P 
 / COPY MD4_H 
 D setParityBit ... 
 D PR 1A 
 D extproc ( 'setParityBit' ) 
 D i_char 1A const 
 D QtqIconv_open ... 
 D PR extproc ( 'QtqIconvOpen' ) 
 D likeds ( iconv_t ) 
 D i_toCode const likeds ( QtqCode_t ) 
 D i_fromCode const likeds ( QtqCode_t ) 
 D iconv_t DS qualified based ( pDummy ) align 
 D return_value 10I 0 
 D cd 10I 0 dim ( 12 ) 
 D QtqCode_t ... 
 D DS qualified based ( pDummy ) 
 D ccsid 10I 0 
 D conversionA 10I 0 
 D substitutionA 10I 0 
 D shiftStateA 10I 0 
 D inpLenOpt 10I 0 
 D errOptMxdDta 10I 0 
 D reserved 12A 
 D iconv ... 
 D PR 10U 0 extproc ( 'iconv' ) 
 D i_cd value likeds ( iconv_t ) 
 D i_pInBuf * 
 D i_inBytLeft 10U 0 
 D i_pOutBuf * 
 D i_outBytLeft 10U 0 
 D ICONV_ERROR C const ( 4294967295 ) 
 D E2BIG_C C const ( 3491 ) Argument list 
 D iconv_close ... 
 D PR 10I 0 extproc ( 'iconv_close' ) 
 D i_cd value likeds ( iconv_t ) 
 D cipher ... 
 D PR extproc ( '_CIPHER' ) 
 D * const 
 D * value 
 D * const 
 D cipherCtrls_0005_t ... 
 D DS qualified based ( pDummy ) align 
 D function 1 2A 
 D hashAlg 3 3A 
 D sequence 4 4A 
 D dataLength 5 8U 0 
 D output 9 9A 
 D reserved_1 10 16A 
 D hashContext 17 32 * 
 D HMACKey 33 48 * 
 D HMACKeyLength 49 52U 0 
 D reserved_2 53 96A 
 D cipherCtrls_0013_t ... 
 D DS qualified based ( pDummy ) align 
 D function 1 2A 
 D dataLength 3 4U 0 
 D operation 5 5A 
 D reserved 6 16A 
 D keyCtxPtr 17 32 * 
 D cCIPHER_ENCRYPT ... 
 D C const ( x'00' ) 
 D cCIPHER_DECRYPT ... 
 D C const ( x'01' ) 
 D cCIPHER_MD5 ... 
 D C const ( x'00' ) 
 D cCIPHER_HASH ... 
 D C const ( x'00' ) 
 D cCIPHER_HMAC ... 
 D C const ( x'01' ) 
 D cCIPHER_ONLY ... 
 D C const ( x'00' ) 
 D MD5_CTX_t DS qualified based ( pDummy ) 
 D key 16A 
 D context 160A 
 D state 1A 
 D digest 16A 
 D rc4_ctx_t ds qualified based ( pDummy ) 
 D stream 256A 
 D length 5U 0 
 D reserved 6A 
 / if defined ( NTLM_SUPPORT ) 
 D Qc3EncryptData ... 
 D PR extproc ( 'Qc3EncryptData' ) 
 D i_clearData 65535A const options ( * varsize ) 
 D i_length 10I 0 const 
 D i_dataFormat 8A const 
 D i_algDesc 65535A const options ( * varsize ) 
 D i_algFormat 8A const 
 D i_keyDesc 65535A const options ( * varsize ) 
 D i_keyFormat 8A const 
 D i_cyptSrvPrv 1A const 
 D i_cyptDevNme 10A const 
 D o_encypted 65535A options ( * varsize ) 
 D i_encLenPrv 10I 0 const 
 D o_encLenRet 10I 0 
 D io_ErrCode 32767A options ( * nopass : * varsize ) 
 / endif 
 
 D algd0200_t DS qualified based ( pDummy ) 
 D algorithm 10I 0 
 D blockLen 10I 0 
 D mode 1A 
 D padOption 1A 
 D padChar 1A 
 D reserved_1 1A 
 D macLen 10I 0 
 D keySize 10I 0 
 D initVector 32A 
 D keyd0200_t DS qualified based ( pDummy ) 
 D type 10I 0 
 D length 10I 0 
 D format 1A 
 D reserved_1 3A 
 D value 8A 
 R * *** Exported , because internally used by NTLMR4 , RPGUNIT tests *** 
 P RC4 ... 
 P B export 
 D RC4 ... 
 D PI 4096A varying 
 D i_key const like ( RC4_key_t ) 
 D i_string 4096A varying options ( * varsize ) 
 D digest S 4096A varying inz 
 D controls DS likeds ( cipherCtrls_0013_t ) inz 
 D rc4_ctx DS likeds ( rc4_ctx_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return '' ; 
 endif ; 
 
 rc4_ctx = * ALLx'00' ; 
 % subst ( rc4_ctx . stream : 1 : % len ( i_key ) ) = i_key ; 
 rc4_ctx . length = % len ( i_key ) ; 
 rc4_ctx . reserved = * ALLx'00' ; 
 
 controls = * ALLx'00' ; 
 
 controls . function = x'0013' ; // RC4 
 controls . dataLength = % len ( i_string ) ; 
 controls . operation = cCIPHER_ENCRYPT ; // Hex 00 = Encrypt 
 // Hex 01 = Decrypt 
 controls . reserved = * ALLx'00' ; 
 controls . keyCtxPtr = % addr ( rc4_ctx ) ; 
 
 % len ( digest ) = % len ( i_string ) ; 
 cipher ( % addr ( digest ) + 2 : % addr ( controls ) : % addr ( i_string ) + 2 ) ; 
 
 return digest ; 
 
 / END - FREE 
 P RC4 ... 
 P E 
 R * *** Exported because , internally used by NTLMR4 , RPGUNIT tests *** 
 P DES ... 
 P B export 
 D DES ... 
 D PI 4096A varying 
 D i_string 4096A const varying options ( * varsize ) 
 D i_challenge const like ( ntlm_challenge_t ) 
 D encrypted S 4096A varying inz 
 D tmpEncrypted S 4096A inz 
 D encryptedLen S 10I 0 inz 
 D algd0200 DS likeds ( algd0200_t ) inz 
 D keyd0200 DS likeds ( keyd0200_t ) inz 
 D errCode DS likeds ( errCode_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return i_string ; 
 endif ; 
 
 algd0200 = * ALLx'00' ; 
 algd0200 . algorithm = 20 ; 
 algd0200 . blockLen = 8 ; 
 algd0200 . mode = '0' ; 
 algd0200 . padOption = '1' ; 
 algd0200 . padChar = x'00' ; 
 algd0200 . reserved_1 = * ALLx'00' ; 
 algd0200 . macLen = 0 ; 
 algd0200 . keySize = 0 ; 
 algd0200 . initVector = * ALLx'00' ; 
 
 keyd0200 = * ALLx'00' ; 
 keyd0200 . type = 20 ; 
 keyd0200 . length = 8 ; 
 keyd0200 . format = '0' ; 
 keyd0200 . reserved_1 = * ALLx'00' ; 
 keyd0200 . value = i_challenge ; 
 
 clear errCode ; 
 / if defined ( NTLM_SUPPORT ) 
 Qc3EncryptData ( i_string // Clear data 
 : % len ( i_string ) // Length of clear data 
 : 'DATA0100' // Clear data format name 
 : algd0200 // Algorithm description 
 : 'ALGD0200' // Algorithm description format name 
 : keyd0200 // Key description 
 : 'KEYD0200' // Key description format name 
 : '0' // Cryptographic service provider 
 : '' // Cryptographic device name 
 : tmpEncrypted // Encrypted data 
 : % size ( tmpEncrypted ) // Length of area provided for encrypted data 
 : encryptedLen // Length of encrypted data returned 
 : errCode ) ; // Error code 
 / endif 
 encrypted = % subst ( tmpEncrypted : 1 : encryptedLen ) ; 
 
 return encrypted ; 
 
 / END - FREE 
 P DES ... 
 P E 
 R * *** Exported because , internally used by NTLMR4 , RPGUNIT tests *** 
 P DES_produceKey ... 
 P B export 
 D DES_produceKey ... 
 D PI like ( DES_key_t ) 
 D i_value 7A const 
 D desKey S like ( DES_key_t ) inz ( x'00' ) 
 D x S 10I 0 inz 
 D i S 10I 0 inz 
 D char S 1A inz ( x'00' ) 
 D inp DS qualified 
 D lm_byte 1 1A 
 D lm_int4 1 4U 0 
 D lm_int4_4 4 4A 
 D rm_int4_1 5 5A 
 D rm_int4 5 8U 0 
 D value 1 7A 
 D rm_byte 8 8A inz ( x'00' ) 
 D tmp DS qualified 
 D int4 1 4I 0 inz 
 D byte 4 4 inz ( x'00' ) 
 / FREE 
 
 inp = * ALLx'00' ; 
 inp . value = i_value ; 
 
 for x = 1 to 8 ; 
 
 // get the 7 left most bits of the left most byte 
 char = byteand ( inp . lm_byte : x'FE' ) ; 
 
 // set parity bit 
 char = setParityBit ( char ) ; 
 
 // put result into the DES key value 
 i = i + 1 ; 
 % subst ( desKey : i : 1 ) = char ; 
 
 // shift the 4 left most bytes 7 bits to the left 
 inp . lm_int4 = bitand ( inp . lm_int4 : x'01FFFFFF' ) ; 
 inp . lm_int4 = inp . lm_int4 * 128 ; 
 
 // shift the 7 left most bits of byte 5 to byte 4 
 tmp . byte = byteand ( inp . rm_int4_1 : x'FE' ) ; 
 tmp . int4 = tmp . int4 / 2 ; 
 inp . lm_int4_4 = byteor ( inp . lm_int4_4 : tmp . byte ) ; 
 
 // shift the 4 right most bytes 7 bits to the left 
 inp . rm_int4 = bitand ( inp . rm_int4 : x'01FFFFFF' ) ; 
 inp . rm_int4 = inp . rm_int4 * 128 ; 
 
 endfor ; 
 
 return desKey ; 
 
 / END - FREE 
 P DES_produceKey ... 
 P E 
 R * *** Private *** 
 P setParityBit ... 
 P B 
 D setParityBit ... 
 D PI 1A 
 D i_char 1A const 
 D char S 1A inz 
 D x S 10I 0 inz 
 D num1Bits S 10I 0 inz 
 D bit S 1A dim ( 7 ) 
 / FREE 
 
 bit ( 7 ) = byteand ( i_char : x'80' ) = x'80' ; 
 bit ( 6 ) = byteand ( i_char : x'40' ) = x'40' ; 
 bit ( 5 ) = byteand ( i_char : x'20' ) = x'20' ; 
 bit ( 4 ) = byteand ( i_char : x'10' ) = x'10' ; 
 bit ( 3 ) = byteand ( i_char : x'08' ) = x'08' ; 
 bit ( 2 ) = byteand ( i_char : x'04' ) = x'04' ; 
 bit ( 1 ) = byteand ( i_char : x'02' ) = x'02' ; 
 
 for x = 1 to % elem ( bit ) ; 
 if ( bit ( x ) ) = '1' ; 
 num1Bits = num1Bits + 1 ; 
 endif ; 
 endfor ; 
 
 if ( % rem ( num1Bits : 2 ) = 0 ) ; 
 char = byteor ( i_char : x'01' ) ; 
 else ; 
 char = byteand ( i_char : x'FE' ) ; 
 endif ; 
 
 return char ; 
 
 / END - FREE 
 P setParityBit ... 
 P E 
 R * *** Exported because , internally used by NTLMR4 , RPGUNIT tests *** 
 P MD4 ... 
 P B export 
 D MD4 ... 
 D PI like ( MD4_digest_t ) 
 D i_string 4096A varying options ( * varsize ) 
 D digest S like ( MD4_digest_t ) inz 
 / FREE 
 
 MD4Only_r ( digest : % addr ( i_string ) + 2 : % len ( i_string ) ) ; 
 
 return digest ; 
 
 / END - FREE 
 P MD4 ... 
 P E 
 R * *** Exported because , internally used by NTLMR4 , RPGUNIT tests *** 
 P MD5Hmac ... 
 P B export 
 D MD5Hmac ... 
 D PI like ( MD5_digest_t ) 
 D i_hmacKey const like ( MD5_digest_t ) 
 D i_string 4096A varying options ( * varsize ) 
 D digest S like ( MD5_digest_t ) 
 D controls DS likeds ( cipherCtrls_0005_t ) inz 
 D MD5_CTX DS likeds ( MD5_CTX_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return '' ; 
 endif ; 
 
 MD5_CTX . key = i_hmacKey ; 
 MD5_CTX . context = * ALLx'00' ; 
 MD5_CTX . state = cCIPHER_ONLY ; 
 MD5_CTX . digest = * ALLx'00' ; 
 
 controls = * ALLx'00' ; 
 
 controls . function = x'0005' ; // MD5 or SHA - 1 
 controls . hashAlg = cCIPHER_MD5 ; // Hex 00 = MD5 
 // Hex 01 = SHA - 1 
 controls . sequence = MD5_CTX . state ; // Hex 00 = Only 
 // Hex 01 = First 
 // Hex 02 = Middle 
 // Hex 03 = Final 
 controls . dataLength = % len ( i_string ) ; 
 controls . output = cCIPHER_HMAC ; // Hex 00 = Hash 
 // Hex 01 = HMAC 
 controls . hashContext = % addr ( MD5_CTX . context ) ; 
 controls . HMACKey = % addr ( MD5_CTX . key ) ; 
 controls . HMACKeyLength = % size ( MD5_CTX . key ) ; 
 
 cipher ( % addr ( MD5_CTX . digest ) : % addr ( controls ) : % addr ( i_string ) + 2 ) ; 
 
 digest = MD5_CTX . digest ; 
 
 return digest ; 
 
 / END - FREE 
 P MD5Hmac ... 
 P E 
 R * *** Exported because , internally used by NTLMR4 , RPGUNIT tests *** 
 P MD5Digest ... 
 P B export 
 D MD5Digest ... 
 D PI like ( MD5_digest_t ) 
 D i_string 4096A varying options ( * varsize ) 
 D digest S like ( MD5_digest_t ) 
 D controls DS likeds ( cipherCtrls_0005_t ) inz 
 D MD5_CTX DS likeds ( MD5_CTX_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return '' ; 
 endif ; 
 
 MD5_CTX . key = * ALLx'00' ; 
 MD5_CTX . context = * ALLx'00' ; 
 MD5_CTX . state = cCIPHER_ONLY ; 
 MD5_CTX . digest = * ALLx'00' ; 
 
 controls = * ALLx'00' ; 
 
 controls . function = x'0005' ; // MD5 or SHA - 1 
 controls . hashAlg = cCIPHER_MD5 ; // Hex 00 = MD5 
 // Hex 01 = SHA - 1 
 controls . sequence = MD5_CTX . state ; // Hex 00 = Only 
 // Hex 01 = First 
 // Hex 02 = Middle 
 // Hex 03 = Final 
 controls . dataLength = % len ( i_string ) ; 
 controls . output = cCIPHER_HASH ; // Hex 00 = Hash 
 // Hex 01 = HMAC 
 controls . hashContext = % addr ( MD5_CTX . context ) ; 
 controls . HMACKey = * NULL ; 
 controls . HMACKeyLength = 0 ; 
 
 cipher ( % addr ( MD5_CTX . digest ) : % addr ( controls ) : % addr ( i_string ) + 2 ) ; 
 
 digest = MD5_CTX . digest ; 
 
 return digest ; 
 
 / END - FREE 
 P MD5Digest ... 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 / copy httpapi_h 
 
 
 D rc s 10I 0 
 D msg s 52A 
 D URL S 300A varying 
 D IFS S 256A varying 
 
 c callp http_debug ( * ON ) 
 
 
 
 
 
 
 
 c eval URL = 'http :// www . scottklement . com' 
 c + ' / presentations / ' 
 c + 'Web Services from RPG with ' 
 c + 'HTTPAPI . pdf' 
 
 c eval IFS = ' / tmp / Scott''s HTTPAPI ' 
 c + 'presentation handout . pdf' 
 
 c callp http_stmf ( 'GET' : URL : IFS ) 
 
 c eval * inlr = * on 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 
 / define WEBFORMS 
 / include httpapi_h 
 
 D EXAMPLE10 PR ExtPgm ( 'EXAMPLE10' ) 
 D userid 32a const 
 D passwd 32a const 
 D EXAMPLE10 PI 
 D userid 32a const 
 D passwd 32a const 
 
 D xmlReply PR 
 D tw likeds ( tweet ) 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 
 D tweet ds qualified 
 D id 20a varying 
 D text 140a varying inz ( '' ) 
 D created 30a varying 
 
 D newStatus s 140a varying 
 D form s like ( WEBFORM ) 
 D rc s 10I 0 
 D postData s * 
 D postDataSize s 10I 0 
 
 / free 
 if % parms < 2 ; 
 http_comp ( 'You must pass a USERID & PASSWORD' ) ; 
 return ; 
 endif ; 
 
 // 
 // the http_setAuth ( ) routine is used to set 
 // the userid / password of the HTTP connection . 
 // 
 
 http_setAuth ( HTTP_AUTH_BASIC 
 : % trim ( Userid ) 
 : % trim ( Passwd ) ) ; 
 
 
 // 
 // newStatus is the new status message to set . 
 // because of spaces & other special symbols , 
 // it must be encoded , like a form on a web page . 
 // 
 
 newStatus = 'is testing HTTPAPI from ScottKlement . com' ; 
 
 form = WEBFORM_open ( ) ; 
 WEBFORM_setVar ( form : 'status' : newstatus ) ; 
 WEBFORM_postData ( form : postData : postDataSize ) ; 
 
 // 
 // http_post_xml ( ) sends the encoded data to Twitter , 
 // receives the reply , and parses the reply as an 
 // XML document . 
 // 
 // Note : We must set http_set_100_timeout ( ) because 
 // Twitter doesn't allow Expect : 100 - continue 
 // despite that RFC2616 says that all HTTP 1 . 1 
 // servers must recognize it . Bug in Twitter ?? 
 // 
 
 http_set_100_timeout ( 0 ) ; 
 rc = http_post_xml ( 'http :// twitter . com / statuses / update . xml' 
 : postData 
 : postDataSize 
 : * null 
 : % paddr ( xmlReply ) 
 : % addr ( tweet ) 
 : HTTP_TIMEOUT 
 : HTTP_USERAGENT 
 : 'application / x - www - form - urlencoded' ) ; 
 WEBFORM_close ( form ) ; 
 if ( rc <> 1 ) ; 
 http_crash ( ) ; 
 return ; 
 endif ; 
 
 http_comp ( 'Twitter status set at ' + tweet . created 
 + ' id = ' + tweet . id ) ; 
 http_comp ( 'Twitter status is now : ' + tweet . text ) ; 
 
 
 / end - free 
 
 
 P xmlReply B 
 D xmlReply PI 
 D tw likeds ( tweet ) 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 / free 
 if path = ' / status' ; 
 select ; 
 when name = 'created_at' ; 
 tw . created = value ; 
 when name = 'id' ; 
 tw . id = value ; 
 when name = 'text' ; 
 tw . text = value ; 
 endsl ; 
 endif ; 
 / end - free 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 FQSYSPRT O F 132 PRINTER OFLIND ( * INOF ) 
 
 / copy httpapi_h 
 / copy ifsio_h 
 
 D Incoming PR 
 D userdata * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D Attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D num s 10I 0 
 D item ds occurs ( 10 ) 
 D title 512A varying 
 D artlink 512A varying 
 
 D msg s 50A 
 D rc s 10I 0 
 D url s 100A varying 
 D PrintLine s 132A 
 D x s 10I 0 
 D filename s 45A varying 
 
 / free 
 
 http_debug ( * ON ) ; 
 
 // **************************************************** 
 // Download the latest news headlines from CNN 
 // to a temporary file in the IFS 
 // **************************************************** 
 url = 'http :// rss . cnn . com / rss / cnn_topstories . rss' ; 
 filename = http_tempfile ( ) + ' . xml' ; 
 
 rc = http_url_get ( url : filename ) ; 
 if ( rc <> 1 ) ; 
 PrintLine = http_error ( ) ; 
 except ; 
 unlink ( filename ) ; 
 return ; 
 endif ; 
 
 // **************************************************** 
 // parse the XML from the temp file . 
 // **************************************************** 
 
 if ( http_parse_xml_stmf ( filename 
 : HTTP_XML_CALC 
 : * null 
 : % paddr ( Incoming ) 
 : * null ) < 0 ) ; 
 PrintLine = http_error ( ) ; 
 except ; 
 unlink ( filename ) ; 
 return ; 
 endif ; 
 
 // **************************************************** 
 // Print the news headlines & links to the full 
 // articles 
 // 
 // Note : If you wanted to , you could retrieve the 
 // articles themselves by calling http_url_get 
 // for each link . 
 // **************************************************** 
 
 if num > % elem ( item ) ; 
 num = % elem ( item ) ; 
 endif ; 
 
 for x = 1 to num ; 
 % occur ( item ) = x ; 
 PrintLine = title ; 
 except ; 
 PrintLine = ' ' + artlink ; 
 except ; 
 PrintLine = '' ; 
 except ; 
 endfor ; 
 
 unlink ( filename ) ; 
 return ; 
 
 / end - free 
 
 OQSYSPRT E 
 O PrintLine 132 
 
 
 P Incoming B 
 D Incoming PI 
 D userdata * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D count s 10I 0 
 D attrname s 1024A varying 
 D attrval s 65535A varying 
 / free 
 if ( num > % elem ( item ) ) ; 
 return ; 
 endif ; 
 
 if ( path = ' / rss / channel / item' ) ; 
 
 select ; 
 when name = 'title' ; 
 num = num + 1 ; 
 if ( num <= % elem ( item ) ) ; 
 % occur ( item ) = num ; 
 title = value ; 
 endif ; 
 when name = 'link' ; 
 artlink = value ; 
 endsl ; 
 
 endif ; 
 
 
 // sometimes an element will have attributes . In the example 
 // XML shown above , the only attribute is the VERSION attrib 
 // of the RSS tag . 
 // 
 // The following searches through the attribute list of the 
 // rss tag to extract the version number . 
 
 if ( name = 'rss' ) ; 
 
 count = 1 ; 
 dow http_nextXmlAttr ( attrs : count : attrname : attrval ) ; 
 if ( attrname = 'version' ) ; 
 PrintLine = 'RSS version ' + attrval ; 
 except ; 
 endif ; 
 enddo ; 
 
 endif ; 
 
 / end - free 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) ACTGRP ( 'KLEMENT' ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 / define WEBFORMS 
 / copy httpapi_h 
 
 D EXAMPLE12 PR ExtPgm ( 'EXAMPLE12' ) 
 D queryString 32a const 
 D EXAMPLE12 PI 
 D queryString 32a const 
 
 D QUILNGTX PR ExtPgm ( 'QUILNGTX' ) 
 D text 65535a const options ( * varsize ) 
 D length 10i 0 const 
 D msgid 7a const 
 D qualmsgf 20a const 
 D errorCode 32767a options ( * varsize ) 
 
 D ErrorEscape ds qualified 
 D bytesProv 10i 0 inz ( 0 ) 
 D bytesAvail 10i 0 inz ( 0 ) 
 
 D parseWeather PR 
 D userData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 D showForecast PR 
 D msg 65535a varying const options ( * varsize ) 
 
 D form s like ( WEBFORM ) 
 D rc s 10i 0 
 D uri s 200a varying 
 
 / free 
 if % parms ( ) < 1 ; 
 http_comp ( 'Please pass a city name or postal code ! ' ) ; 
 return ; 
 endif ; 
 
 // 
 // The query ( city name / postal code ) must be URL encoded 
 // like a form on a web page 
 // 
 
 form = webform_open ( ) ; 
 webform_setVar ( form : 'query' : % trim ( queryString ) ) ; 
 uri = 'http :// api . wunderground . com / auto / wui / geo / ForecastXML /+ 
 index . xml ? query = ' + webform_getData ( Form ) ; 
 webform_close ( form ) ; 
 
 // 
 // get the response , and parse it as an XML document . 
 // http_url_get_xml ( ) will call the parseWeather procedure 
 // for each XML tag found . 
 // 
 
 rc = http_url_get_xml ( uri : * null : % paddr ( parseWeather ) : * null ) ; 
 if ( rc <> 1 ) ; 
 http_crash ( ) ; 
 endif ; 
 
 / end - free 
 
 P parseWeather B 
 D PI 
 D userData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 D title s 80a varying static 
 / free 
 if path = ' / forecast / txt_forecast / forecastday' ; 
 select ; 
 when name = 'title' ; 
 title = value ; 
 when name = 'fcttext' ; 
 showForecast ( title + ' : ' + value ) ; 
 endsl ; 
 endif ; 
 / end - free 
 P E 
 
 P showForecast B 
 D showForecast PI 
 D msg 65535a varying const options ( * varsize ) 
 / free 
 QUILNGTX ( msg 
 : % len ( msg ) 
 : * blanks 
 : * blanks 
 : errorEscape ) ; 
 / end - free 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 FEXAMPLE14SCF E WORKSTN SFILE ( SFLREC : RRN ) 
 F indds ( dsIndic ) 
 
 / copy httpapi_h 
 
 D StartOfElement PR 
 D UserData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 D EndOfElement PR 
 D UserData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D UPS_USERID C ' < put your userid here > ' 
 D UPS_PASSWD C ' < put your password here > ' 
 D UPS_LICENSE C ' < put your access license here > ' 
 
 D dsIndic ds 
 D ExitKey 03 03N 
 D Clear_Sfl 50 50N 
 D Empty_Sfl 51 51N 
 
 d act s 10I 0 
 d activity ds qualified 
 d array dim ( 100 ) 
 d Date 8A overlay ( array ) 
 d Time 6A overlay ( array :* next ) 
 D Desc 20A overlay ( array :* next ) 
 D City 20A overlay ( array :* next ) 
 D State 2A overlay ( array :* next ) 
 D Status 20A overlay ( array :* next ) 
 D SignedBy 20A overlay ( array :* next ) 
 
 D rc s 10I 0 
 D postData s 750A varying 
 D TrackingNo s 24A varying 
 D RRN s 4 0 
 D tempDate s D 
 D tempTime s T 
 
 / free 
 if ( % subst ( UPS_USERID : 1 : 1 ) = ' < ' 
 or % subst ( UPS_PASSWD : 1 : 1 ) = ' < ' 
 or % subst ( UPS_LICENSE : 1 : 1 ) = ' < ' ) ; 
 http_comp ( 'You must be registered with UPS ! See + 
 comments in EXAMPLE14 member . ' ) ; 
 return ; 
 endif ; 
 
 exfmt TrackNo ; 
 if ( ExitKey ) ; 
 return ; 
 endif ; 
 
 TrackingNo = % trim ( scTrackNo ) ; 
 
 postData = 
 ' <? xml version = " 1 . 0 " ?> ' + 
 ' < AccessRequest xml : lang = " en - US " > ' + 
 ' < AccessLicenseNumber > ' + 
 UPS_LICENSE + 
 ' </ AccessLicenseNumber > ' + 
 ' < UserId > ' + UPS_USERID + ' </ UserId > ' + 
 ' < Password > ' + UPS_PASSWD + ' </ Password > ' + 
 ' </ AccessRequest > ' + 
 ' <? xml version = " 1 . 0 " ?> ' + 
 ' < TrackRequest xml : lang = " en - US " > ' + 
 ' < Request > ' + 
 ' < TransactionReference > ' + 
 ' < CustomerContext > ' + 
 'HTTPAPI EXAMPLE14' + 
 ' </ CustomerContext > ' + 
 ' < XpciVersion > 1 . 0001 </ XpciVersion > ' + 
 ' </ TransactionReference > ' + 
 ' < RequestAction > Track </ RequestAction > ' + 
 ' < RequestOption > activity </ RequestOption > ' + 
 ' </ Request > ' + 
 ' < TrackingNumber > ' + TrackingNo + ' </ TrackingNumber > ' + 
 ' </ TrackRequest > ' ; 
 
 rc = http_url_post_xml ( 'https :// wwwcie . ups . com / ups . app / xml / Track' 
 : % addr ( postData ) + 2 
 : % len ( postData ) 
 : % paddr ( StartOfElement ) 
 : % paddr ( EndOfElement ) 
 : * NULL ) ; 
 if ( rc <> 1 ) ; 
 scmsg = http_error ( ) ; 
 // FIXME : REPORT ERROR TO USER 
 return ; 
 endif ; 
 
 clear_sfl = * on ; 
 write SFLCTL ; 
 clear_sfl = * off ; 
 empty_sfl = * on ; 
 
 for RRN = 1 to act ; 
 monitor ; 
 tempDate = % date ( activity . date ( RRN ) : * ISO0 ) ; 
 scDate = % char ( tempDate : * USA ) ; 
 on - error ; 
 scDate = * blanks ; 
 endmon ; 
 
 monitor ; 
 tempTime = % time ( activity . time ( RRN ) : * HMS0 ) ; 
 scTime = % char ( tempTime : * HMS ) ; 
 on - error ; 
 scTime = * blanks ; 
 endmon ; 
 
 scDesc = activity . desc ( RRN ) ; 
 scCity = activity . city ( RRN ) ; 
 scState = activity . state ( RRN ) ; 
 scStatus = activity . status ( RRN ) ; 
 
 if ( scSignedBy = * blanks ) ; 
 scSignedBy = activity . SignedBy ( RRN ) ; 
 endif ; 
 
 write SFLREC ; 
 empty_sfl = * off ; 
 endfor ; 
 
 exfmt SFLCTL ; 
 
 / end - free 
 
 
 P StartOfElement B 
 D StartOfElement PI 
 D UserData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 / free 
 
 if path = ' / TrackResponse / Shipment / Package' and name = 'Activity' ; 
 act = act + 1 ; 
 endif ; 
 
 / end - free 
 P E 
 
 
 P EndOfElement B 
 D EndOfElement PI 
 D UserData * value 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 / free 
 
 select ; 
 when path = ' / TrackResponse / Shipment / Package / Activity' ; 
 
 select ; 
 when name = 'Date' ; 
 activity . Date ( act ) = value ; 
 when name = 'Time' ; 
 activity . Time ( act ) = value ; 
 endsl ; 
 
 when path = ' / TrackResponse / Shipment / Package / Activity' + 
 ' / ActivityLocation' ; 
 
 select ; 
 when name = 'Description' ; 
 activity . Desc ( act ) = value ; 
 when name = 'SignedForByName' ; 
 activity . SignedBy ( act ) = value ; 
 endsl ; 
 
 when path = ' / TrackResponse / Shipment / Package / Activity' + 
 ' / ActivityLocation / Address' ; 
 
 select ; 
 when name = 'City' ; 
 activity . City ( act ) = value ; 
 when name = 'StateProvinceCode' ; 
 activity . State ( act ) = value ; 
 endsl ; 
 
 when path = ' / TrackResponse / Shipment / Package / Activity' + 
 ' / Status / StatusType' ; 
 
 if name = 'Description' ; 
 activity . Status ( act ) = value ; 
 endif ; 
 
 endsl ; 
 
 / end - free 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) ACTGRP ( * NEW ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 
 / define WEBFORMS 
 D / copy httpapi_h 
 
 D cmd pr extpgm ( 'QCMDEXC' ) 
 D command 200A const 
 D length 15P 5 const 
 
 D CRLF C CONST ( x'0D25' ) 
 D rc s 10I 0 
 D msg s 52A 
 
 D Form s like ( WEBFORM ) 
 D fromAddr s 100A varying 
 D Subject s 100A varying 
 D Message s 1000A varying 
 D myPointer s * 
 D dataSize s 10I 0 
 
 / free 
 
 // 
 // CHANGE THIS TO YOUR E - MAIL ADDRESS : 
 // 
 FromAddr = 'example4 @ scottklement . com' ; 
 
 // 
 // CHANGE THIS TO THE SUBJECT YOU'D LIKE SENT TO ME : 
 // 
 Subject = 'EXAMPLE4 from HTTPAPI . ' ; 
 
 // 
 // CHANGE THIS TO THE MESSAGE YOU'D LIKE SENT TO ME : 
 // 
 Message = 'Hi Scott ! ' + CRLF + 
 ' Just a note to tell you that I''m testing out the + 
 EXAMPLE15 program in HTTPAPI . If you receive this , it + 
 must work ! ' + CRLF ; 
 
 
 // 
 // When a program emulates a form on an HTML page , it's called 
 // a 'webform' in HTTPAPI . You must first open a new web 
 // form , and then set variables in it : 
 // 
 Form = WEBFORM_open ( ) ; 
 
 WEBFORM_SetVar ( Form : 'from' : fromAddr ) ; 
 WEBFORM_SetVar ( Form : 'subject' : subject ) ; 
 WEBFORM_SetVar ( Form : 'Comment' : message ) ; 
 
 // 
 // The WEBFORM_postData ( ) routine retrieves data suitable for 
 // the http_url_post ( ) API . ( there's also a WEBFORM_getData ( ) 
 // if you need to call HTTP_url_get ) . 
 // 
 WEBFORM_postData ( Form : myPointer : dataSize ) ; 
 
 // 
 // The http_url_post ( ) function does an HTTP POST operation 
 // sending any data at the pointer you specify . 
 // 
 // The results , in this case , are saved to the IFS in a file 
 // called ' / tmp / testpost . html' 
 // 
 rc = http_url_post ( 'http :// www . scottklement . com / cgi - bin / ' + 
 'email_comment . cgi' 
 : myPointer 
 : dataSize 
 : ' / tmp / testpost . html' 
 : HTTP_TIMEOUT 
 : HTTP_USERAGENT 
 : 'application / x - www - form - urlencoded' ) ; 
 
 // 
 // This particular web page doesn't give a direct response 
 // but instead asks you to visit another page . This is done 
 // by sending back a 302 ( " Page Moved " ) response . You can 
 // call the http_redir_loc ( ) routine in HTTPAPI to get the 
 // URL that the redirection points to , and then the http_url_get ( ) 
 // routine to ask HTTPAPI to retrieve that page . 
 // 
 
 if rc = 302 ; 
 rc = http_url_get ( http_redir_loc 
 : ' / tmp / testpost . html' ) ; 
 endif ; 
 
 // 
 // If there's an error , use the DSPLY opcode to show it on the 
 // screen . If not , use the DSPF command from OS / 400 to display 
 // the data that was returned onto the screen . 
 // 
 if rc <> 1 ; 
 msg = http_error ( ) ; 
 dsply msg ; 
 else ; 
 cmd ( 'DSPF '' / tmp / testpost . html''' : 200 ) ; 
 endif ; 
 
 // 
 // When done , make sure you call this function to free up 
 // the memory that the web form used 
 // 
 WEBFORM_close ( Form ) ; 
 
 / end - free 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 D EXAMPLE16 PR ExtPgm ( 'EXAMPLE16' ) 
 D Country1 3A const 
 D Country2 3A const 
 D parmAmount 15P 5 const 
 D EXAMPLE16 PI 
 D Country1 3A const 
 D Country2 3A const 
 D parmAmount 15P 5 const 
 
 / copy httpapi_h 
 
 D URL s 100a varying 
 D SOAP s 1000A varying 
 D response s 1000a varying 
 D Amount s 12p 2 
 D rate s 9p 4 
 D Result s 12P 2 
 
 / free 
 
 if % parms < 3 ; 
 http_comp ( 'Please pass parms . e . g . CALL EXAMPLE16 ' 
 + 'PARM ( USD JPY 12 . 00 ) ' ) ; 
 return ; 
 endif ; 
 
 Amount = parmAmount ; 
 
 http_debug ( * ON ) ; 
 
 URL = 'http :// www . restfulwebservices . net / wcf / CurrencyService . svc' ; 
 
 http_setOption ( 'SoapAction' : ' " GetConversionRate " ' ) ; 
 
 SOAP = 
 ' < soapenv : Envelope + 
 xmlns : soapenv = " http :// schemas . xmlsoap . org / soap / envelope / " + 
 xmlns : ns = " http :// www . restfulwebservices . net /+ 
 ServiceContracts / 2008 / 01 " >+ 
 < soapenv : Header />+ 
 < soapenv : Body >+ 
 < ns : GetConversionRate >+ 
 < ns : FromCurrency > ' +% trim ( Country1 ) + ' </ ns : FromCurrency >+ 
 < ns : ToCurrency > ' +% trim ( Country2 ) + ' </ ns : ToCurrency >+ 
 </ ns : GetConversionRate >+ 
 </ soapenv : Body >+ 
 </ soapenv : Envelope > ' ; 
 
 response = http_string ( 'POST' : URL : SOAP : 'text / xml' ) ; 
 
 xml - into rate % xml ( response : 'case = any ns = remove + 
 path = Envelope / Body / GetConversionRateResponse + 
 / GetConversionRateResult / Rate' ) ; 
 
 Result = Amount * Rate ; 
 http_comp ( % trim ( Country1 ) + ' ' + % char ( Amount ) 
 + ' = ' 
 + % trim ( Country2 ) + ' ' + % char ( Result ) ) ; 
 
 
 / end - free 
 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' ) 
 
 // change the following to " / undefine " if you don't 
 // want to see debugging messages 
 / define DEBUGGING 
 
 D EXAMPLE17 PR ExtPgm ( 'EXAMPLE17' ) 
 D RoutNo 32A const 
 D EXAMPLE17 PI 
 D RoutNo 32A const 
 
 / copy httpapi_h 
 / copy ifsio_h 
 
 D QCMDEXC PR ExtPgm ( 'QCMDEXC' ) 
 D command 32702a const options ( * varsize ) 
 D len 15p 5 const 
 D igc 3a const options ( * nopass ) 
 
 D SaveEmbed PR 
 D embfile 50a varying 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 32767A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D bank_t ds qualified 
 D based ( Template ) 
 D rtgno 20a varying 
 D name 30a varying 
 D addr 30a varying 
 D city 20a varying 
 D state 2a varying 
 D zip 10a varying 
 D phone 15a varying 
 
 D embedded PR 
 D bank likeds ( bank_t ) 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 32767A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D SOAP s 2000A varying 
 D rc s 10I 0 
 D fd s 10I 0 
 D soapfile s 50a varying 
 D embfile s 50a varying 
 D cmd s 200A 
 D bank ds likeds ( bank_t ) 
 D wait s 1A 
 
 / free 
 / if defined ( DEBUGGING ) 
 http_debug ( * ON ) ; 
 / endif 
 
 if ( % parms < 1 ) ; 
 http_comp ( 'You must pass an ABA Routing number ! ' ) ; 
 return ; 
 endif ; 
 
 // ---------------------------------------------- 
 // Create SOAP document to tell server 
 // - to call the getABADetailsByRoutingNumber routine 
 // - pass a parameter with the routing number . 
 // ---------------------------------------------- 
 
 SOAP = 
 ' <? xml version = " 1 . 0 " encoding = " iso - 8859 - 1 " standalone = " no " ?> + 
 < SOAP - ENV : Envelope + 
 xmlns : SOAP - ENV = " http :// schemas . xmlsoap . org / soap / envelope / " > + 
 < SOAP - ENV : Body > + 
 < GetABADetailsByRoutingNumber + 
 xmlns = " http :// www . webserviceX . NET " > + 
 < RoutingNumber > ' + RoutNo + ' </ RoutingNumber > + 
 </ GetABADetailsByRoutingNumber > + 
 </ SOAP - ENV : Body > + 
 </ SOAP - ENV : Envelope > ' ; 
 
 // ---------------------------------------------- 
 // Send request to server , and get response 
 // ---------------------------------------------- 
 
 soapfile = http_tempfile ( ) ; 
 
 rc = http_url_post ( 'http :// www . webservicex . net / aba . asmx' 
 : % addr ( SOAP ) + 2 
 : % len ( SOAP ) 
 : soapfile 
 : HTTP_TIMEOUT 
 : HTTP_USERAGENT 
 : 'text / xml' 
 : 'http :// www . webserviceX . NET /+ 
 GetABADetailsByRoutingNumber' ) ; 
 
 if ( rc <> 1 ) ; 
 unlink ( soapfile ) ; 
 http_crash ( ) ; 
 endif ; 
 
 // ---------------------------------------------- 
 // The response from the server will be in 
 // the IFS in a file with a unique name . 
 // that IFS filename is in the " tempfile " 
 // variable at this point . 
 // 
 // For debugging purposes , display the 
 // contents of that file , now . 
 // ---------------------------------------------- 
 / if defined ( DEBUGGING ) 
 dsply ( 'Press < ENTER > to see SOAP response' ) ' ' wait ; 
 cmd = 'DSPF STMF ( ''' + soapfile + ''' ) ' ; 
 QCMDEXC ( cmd : % len ( cmd ) ) ; 
 / endif 
 
 
 // ---------------------------------------------- 
 // Parse the SOAP document ( the one in soapfile ) 
 // Inside it will be another XML document that's 
 // embedded within -- save that to a separate 
 // file in the IFS . 
 // ---------------------------------------------- 
 
 embfile = http_tempfile ( ) ; 
 
 if ( http_parse_xml_stmf ( soapfile 
 : HTTP_XML_CALC 
 : * null 
 : % paddr ( SaveEmbed ) 
 : % addr ( embfile ) ) < 0 ) ; 
 callp close ( fd ) ; 
 unlink ( soapfile ) ; 
 unlink ( embfile ) ; 
 http_crash ( ) ; 
 endif ; 
 
 unlink ( soapfile ) ; 
 
 
 // ---------------------------------------------- 
 // For the sake of debugging , display the 
 // contents of the embedded XML document 
 // ( Remove from production code ) 
 // ---------------------------------------------- 
 
 / if defined ( DEBUGGING ) 
 dsply ( 'Press < ENTER > to see extracted XML' ) ' ' wait ; 
 cmd = 'DSPF STMF ( ''' + embfile + ''' ) ' ; 
 QCMDEXC ( cmd : % len ( cmd ) ) ; 
 / endif 
 
 // ---------------------------------------------- 
 // Parse the second XML document ( the one 
 // that was embedded ) 
 // ---------------------------------------------- 
 bank = * allx'00' ; 
 if ( http_parse_xml_stmf ( embfile 
 : HTTP_XML_CALC 
 : * null 
 : % paddr ( Embedded ) 
 : % addr ( bank ) ) < 0 ) ; 
 unlink ( embfile ) ; 
 http_crash ( ) ; 
 endif ; 
 
 // ---------------------------------------------- 
 // For the sake of demonstration , use DSPLY 
 // to show the results on the screen ( you 
 // wouldn't do this in a real program . ) 
 // ---------------------------------------------- 
 
 dsply ( ' --- Reply from Web Service --- ' ) ; 
 dsply ( 'name = ' + bank . name ) ; 
 dsply ( 'phone = ' + bank . phone ) ; 
 dsply ( ' addr = ' + bank . addr ) ; 
 dsply ( ' ' + bank . city + ' ' 
 + bank . state + ' ' 
 + bank . zip ) ; 
 dsply ( ' --- Press ENTER to end --- ' ) ' ' wait ; 
 
 return ; 
 
 / end - free 
 
 
 
 P SaveEmbed B 
 D SaveEmbed PI 
 D embfile 50a varying 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 32767A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D writeConst PR 10I 0 ExtProc ( 'write' ) 
 D fildes 10i 0 value 
 D buf 65535A const options ( * varsize ) 
 D bytes 10U 0 value 
 
 D xmlhdr s 80a varying 
 D fd s 10i 0 
 
 / free 
 if ( name <> 'GetABADetailsByRoutingNumberResult' ) ; 
 return ; 
 endif ; 
 
 // ------------------------------------------ 
 // create new stream file in IFS 
 // tag it with CCSID 1208 ( UTF - 8 ) 
 // ------------------------------------------ 
 
 unlink ( embfile ) ; 
 fd = open ( embfile : O_CREAT + O_CCSID + O_WRONLY 
 : S_IRUSR + S_IWUSR : 819 ) ; 
 callp close ( fd ) ; 
 
 // ------------------------------------------ 
 // Open stream file for appending data 
 // and write embedded XML document to it 
 // ------------------------------------------ 
 
 fd = open ( embfile : O_WRONLY + O_TEXTDATA ) ; 
 
 xmlhdr = ' <? xml version = " 1 . 0 " encoding = " iso - 8859 - 1 " ?> ' + x'0d25' ; 
 writeConst ( fd : xmlhdr : % len ( xmlhdr ) ) ; 
 writeConst ( fd : value : % len ( value ) ) ; 
 
 callp close ( fd ) ; 
 / end - free 
 P E 
 
 
 P embedded B 
 D embedded PI 
 D bank likeds ( bank_t ) 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 32767A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 / free 
 select ; 
 when name = 'RoutingNumber' ; 
 bank . rtgno = % trimr ( value ) ; 
 when name = 'BankName' ; 
 bank . name = % trimr ( value ) ; 
 when name = 'Address' ; 
 bank . addr = % trimr ( value ) ; 
 when name = 'City' ; 
 bank . city = % trimr ( value ) ; 
 when name = 'State' ; 
 bank . state = % trimr ( value ) ; 
 when name = 'ZipCode' ; 
 bank . zip = % trimr ( value ) ; 
 when name = 'PhoneNumber' ; 
 bank . phone = % trimr ( value ) ; 
 endsl ; 
 / end - free 
 P E 
 / if defined ( * CRTBNDRPG ) 
 H DFTACTGRP ( * NO ) 
 / endif 
 H BNDDIR ( 'HTTPAPI' : 'QC2LE' ) 
 
 D EXAMPLE18 PR ExtPgm ( 'EXAMPLE18' ) 
 D Country1 3A const 
 D Country2 3A const 
 D Amount 15P 5 const 
 D EXAMPLE18 PI 
 D Country1 3A const 
 D Country2 3A const 
 D Amount 15P 5 const 
 
 / copy httpapi_h 
 
 D Incoming PR 
 D rate 8F 
 D depth 10I 0 value 
 D name 1024A varying const 
 D path 24576A varying const 
 D value 65535A varying const 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 
 D SOAP s 32767A varying 
 D rc s 10I 0 
 D rate s 8F 
 D Result s 12P 2 
 
 / free 
 
 if ( % parms < 3 ) ; 
 http_comp ( 'Please pass parms . e . g . CALL EXAMPLE18 + 
 PARM ( USD JPY 12 . 00 ) ' ) ; 
 return ; 
 endif ; 
 
 // Note : http_debug ( * ON 
 FF ( d : a : b : c : x ( 1 + 1 ) : S12 ) ; //* 2 */ 
 FF ( c : d : a : b : x ( 2 + 1 ) : S13 ) ; //* 3 */ 
 FF ( b : c : d : a : x ( 3 + 1 ) : S14 ) ; //* 4 */ 
 FF ( a : b : c : d : x ( 4 + 1 ) : S11 ) ; //* 5 */ 
 FF ( d : a : b : c : x ( 5 + 1 ) : S12 ) ; //* 6 */ 
 FF ( c : d : a : b : x ( 6 + 1 ) : S13 ) ; //* 7 */ 
 FF ( b : c : d : a : x ( 7 + 1 ) : S14 ) ; //* 8 */ 
 FF ( a : b : c : d : x ( 8 + 1 ) : S11 ) ; //* 9 */ 
 FF ( d : a : b : c : x ( 9 + 1 ) : S12 ) ; //* 10 */ 
 FF ( c : d : a : b : x ( 10 + 1 ) : S13 ) ; //* 11 */ 
 FF ( b : c : d : a : x ( 11 + 1 ) : S14 ) ; //* 12 */ 
 FF ( a : b : c : d : x ( 12 + 1 ) : S11 ) ; //* 13 */ 
 FF ( d : a : b : c : x ( 13 + 1 ) : S12 ) ; //* 14 */ 
 FF ( c : d : a : b : x ( 14 + 1 ) : S13 ) ; //* 15 */ 
 FF ( b : c : d : a : x ( 15 + 1 ) : S14 ) ; //* 16 */ 
 
 // Round 2 
 GG ( a : b : c : d : x ( 0 + 1 ) : S21 ) ; 
 GG ( d : a : b : c : x ( 4 + 1 ) : S22 ) ; //* 18 */ 
 GG ( c : d : a : b : x ( 8 + 1 ) : S23 ) ; //* 19 */ 
 GG ( b : c : d : a : x ( 12 + 1 ) : S24 ) ; //* 20 */ 
 GG ( a : b : c : d : x ( 1 + 1 ) : S21 ) ; //* 21 */ 
 GG ( d : a : b : c : x ( 5 + 1 ) : S22 ) ; //* 22 */ 
 GG ( c : d : a : b : x ( 9 + 1 ) : S23 ) ; //* 23 */ 
 GG ( b : c : d : a : x ( 13 + 1 ) : S24 ) ; //* 24 */ 
 GG ( a : b : c : d : x ( 2 + 1 ) : S21 ) ; //* 25 */ 
 GG ( d : a : b : c : x ( 6 + 1 ) : S22 ) ; //* 26 */ 
 GG ( c : d : a : b : x ( 10 + 1 ) : S23 ) ; //* 27 */ 
 GG ( b : c : d : a : x ( 14 + 1 ) : S24 ) ; //* 28 */ 
 GG ( a : b : c : d : x ( 3 + 1 ) : S21 ) ; //* 29 */ 
 GG ( d : a : b : c : x ( 7 + 1 ) : S22 ) ; //* 30 */ 
 GG ( c : d : a : b : x ( 11 + 1 ) : S23 ) ; //* 31 */ 
 GG ( b : c : d : a : x ( 15 + 1 ) : S24 ) ; //* 32 */ 
 
 // Round 3 
 HH ( a : b : c : d : x ( 0 + 1 ) : S31 ) ; //* 33 */ 
 HH ( d : a : b : c : x ( 8 + 1 ) : S32 ) ; //* 34 */ 
 HH ( c : d : a : b : x ( 4 + 1 ) : S33 ) ; //* 35 */ 
 HH ( b : c : d : a : x ( 12 + 1 ) : S34 ) ; //* 36 */ 
 HH ( a : b : c : d : x ( 2 + 1 ) : S31 ) ; //* 37 */ 
 HH ( d : a : b : c : x ( 10 + 1 ) : S32 ) ; //* 38 */ 
 HH ( c : d : a : b : x ( 6 + 1 ) : S33 ) ; //* 39 */ 
 HH ( b : c : d : a : x ( 14 + 1 ) : S34 ) ; //* 40 */ 
 HH ( a : b : c : d : x ( 1 + 1 ) : S31 ) ; //* 41 */ 
 HH ( d : a : b : c : x ( 9 + 1 ) : S32 ) ; //* 42 */ 
 HH ( c : d : a : b : x ( 5 + 1 ) : S33 ) ; //* 43 */ 
 HH ( b : c : d : a : x ( 13 + 1 ) : S34 ) ; //* 44 */ 
 HH ( a : b : c : d : x ( 3 + 1 ) : S31 ) ; //* 45 */ 
 HH ( d : a : b : c : x ( 11 + 1 ) : S32 ) ; //* 46 */ 
 HH ( c : d : a : b : x ( 7 + 1 ) : S33 ) ; //* 47 */ 
 HH ( b : c : d : a : x ( 15 + 1 ) : S34 ) ; //* 48 */ 
 
 io_state ( 1 ) = truncate ( io_state ( 1 ) + a ) ; 
 io_state ( 2 ) = truncate ( io_state ( 2 ) + b ) ; 
 io_state ( 3 ) = truncate ( io_state ( 3 ) + c ) ; 
 io_state ( 4 ) = truncate ( io_state ( 4 ) + d ) ; 
 
 // Zeroize sensitive information . 
 clear x ; 
 
 return ; 
 
 / END - FREE 
 P MD4Transform ... 
 P E 
 P Decode ... 
 P B 
 D Decode ... 
 D PI 
 D o_output like ( UINT4 ) dim ( 16 ) 
 D i_input 1A const dim ( 64 ) 
 D output S 1A dim ( 64 ) based ( pOutput ) 
 D i S 10U 0 inz 
 / FREE 
 
 pOutput = % addr ( o_output ) ; 
 
 for i = 1 to % elem ( i_input ) by 4 ; 
 output ( i ) = i_input ( i + 3 ) ; 
 output ( i + 1 ) = i_input ( i + 2 ) ; 
 output ( i + 2 ) = i_input ( i + 1 ) ; 
 output ( i + 3 ) = i_input ( i ) ; 
 endfor ; 
 
 return ; 
 
 / END - FREE 
 P Decode ... 
 P E 
 P Encode ... 
 P B 
 D Encode ... 
 D PI 
 D o_output 1A dim ( 64 ) options ( * varsize ) 
 D i_input 1A dim ( 64 ) options ( * varsize ) 
 D i_len 10U 0 value 
 D i S 10U 0 inz 
 D j S 10U 0 inz 
 / FREE 
 
 j = 1 ; 
 
 dow ( j <= i_len ) ; 
 o_output ( j ) = i_input ( j + 3 ) ; 
 o_output ( j + 1 ) = i_input ( j + 2 ) ; 
 o_output ( j + 2 ) = i_input ( j + 1 ) ; 
 o_output ( j + 3 ) = i_input ( j ) ; 
 j = j + 4 ; 
 enddo ; 
 
 return ; 
 
 / END - FREE 
 P Encode ... 
 P E 
 P shiftL ... 
 P B 
 D shiftL ... 
 D PI 10U 0 
 D i_value 10U 0 value 
 D i_bits 10U 0 value 
 D result DS qualified 
 D highUint 1 4U 0 inz 
 D lowUInt 5 8U 0 inz 
 D ULong 1 8U 0 inz 
 / FREE 
 
 result . lowUInt = i_value ; 
 
 dow ( i_bits > 0 ) ; 
 result . ULong = result . lowUInt * 2 ; 
 i_bits = i_bits - 1 ; 
 enddo ; 
 
 return result . lowUInt ; 
 
 / END - FREE 
 P shiftL ... 
 P E 
 P shiftR ... 
 P B 
 D shiftR ... 
 D PI 10U 0 
 D i_value 10U 0 value 
 D i_bits 10U 0 value 
 D result DS qualified 
 D highUint 1 4U 0 inz 
 D lowUInt 5 8U 0 inz 
 D ULong 1 8U 0 inz 
 / FREE 
 
 result . lowUInt = i_value ; 
 
 dow ( i_bits > 0 ) ; 
 result . ULong = result . lowUInt / 2 ; 
 i_bits = i_bits - 1 ; 
 enddo ; 
 
 return result . lowUInt ; 
 
 / END - FREE 
 P shiftR ... 
 P E 
 P F ... 
 P B 
 D F ... 
 D PI 10U 0 
 D x 10U 0 const 
 D y 10U 0 const 
 D z 10U 0 const 
 / FREE 
 
 // ( ( ( x ) & ( y ) ) ] ( ( x ) & ( z ) ) ) 
 return % bitor ( % bitand ( x : y ) : % bitand ( % bitnot ( x ) : z ) ) ; 
 
 / END - FREE 
 P F ... 
 P E 
 P G ... 
 P B 
 D G ... 
 D PI 10U 0 
 D x 10U 0 const 
 D y 10U 0 const 
 D z 10U 0 const 
 / FREE 
 
 // ( ( ( x ) & ( y ) ) ] ( ( x ) & ( z ) ) ] ( ( y ) & ( z ) ) ) 
 return % bitor ( % bitand ( x : y ) : % bitand ( x : z ) : % bitand ( y : z ) ) ; 
 
 / END - FREE 
 P G ... 
 P E 
 P H ... 
 P B 
 D H ... 
 D PI 10U 0 
 D x 10U 0 const 
 D y 10U 0 const 
 D z 10U 0 const 
 / FREE 
 
 // ( ( x )  ( y )  ( z ) ) 
 return % bitxor ( % bitxor ( x : y ) : z ) ; 
 
 / END - FREE 
 P H ... 
 P E 
 P ROTATE_LEFT ... 
 P B 
 D ROTATE_LEFT ... 
 D PI 10U 0 
 D x 10U 0 const 
 D n 10U 0 const 
 / FREE 
 
 return % bitor ( shiftL ( x : n ) : shiftR ( x : 32 - n ) ) ; 
 
 / END - FREE 
 P ROTATE_LEFT ... 
 P E 
 P FF ... 
 P B 
 D FF ... 
 D PI 
 D a 10U 0 
 D b 10U 0 const 
 D c 10U 0 const 
 D d 10U 0 const 
 D x 10U 0 const 
 D s 10U 0 const 
 / FREE 
 
 // ( a ) += F ( ( b ) , ( c ) , ( d ) ) + ( x ) ; 
 a = truncate ( a + F ( b : c : d ) + x ) ; 
 
 // ( a ) = ROTATE_LEFT ( ( a ) , ( s ) ) ; 
 a = ROTATE_LEFT ( a : s ) ; 
 
 return ; 
 
 / END - FREE 
 P FF ... 
 P E 
 P GG ... 
 P B 
 D GG ... 
 D PI 
 D a 10U 0 
 D b 10U 0 const 
 D c 10U 0 const 
 D d 10U 0 const 
 D x 10U 0 const 
 D s 10U 0 const 
 / FREE 
 
 // ( a ) += G ( ( b ) , ( c ) , ( d ) ) + ( x ) + ( UINT4 ) 0x5a827999 ; 
 a = truncate ( a + G ( b : c : d ) + x + x'5a827999' ) ; 
 
 // ( a ) = ROTATE_LEFT ( ( a ) , ( s ) ) ; 
 a = ROTATE_LEFT ( a : s ) ; 
 
 return ; 
 
 / END - FREE 
 P GG ... 
 P E 
 P HH ... 
 P B 
 D HH ... 
 D PI 
 D a 10U 0 
 D b 10U 0 const 
 D c 10U 0 const 
 D d 10U 0 const 
 D x 10U 0 const 
 D s 10U 0 const 
 / FREE 
 
 // ( a ) += H ( ( b ) , ( c ) , ( d ) ) + ( x ) + ( UINT4 ) 0x6ed9eba1 ;  
 a = truncate ( a + H ( b : c : d ) + x + x'6ed9eba1' ) ; 
 
 // ( a ) = ROTATE_LEFT ( ( a ) , ( s ) ) ; 
 a = ROTATE_LEFT ( a : s ) ; 
 
 return ; 
 
 / END - FREE 
 P HH ... 
 P E 
 P truncate ... 
 P B 
 D truncate ... 
 D PI 10U 0 
 D i_value 20U 0 value 
 D result DS qualified 
 D highUint 1 4U 0 inz 
 D lowUInt 5 8U 0 inz 
 D ULong 1 8U 0 inz 
 / FREE 
 
 result . ULong = i_value ; 
 
 return result . lowUInt ; 
 
 / END - FREE 
 P truncate ... 
 P E 
 
 H NOMAIN 
 
 / copy RDWR_H 
 
 D Data_t ds qualified 
 D template 
 D 
 
 D StringReader_t ds qualified 
 D template 
 
 D h likeds ( RDWR_t ) 
 D data likeds ( DATA_t ) 
 
 P http_StringReader ... 
 P B export 
 D PI * opdesc 
 D str a varying len ( 16000000 ) 
 D 
 D vanilla ds likeds ( RDWR_t ) inz ( * likeds ) 
 
 D stringReader ds qualified 
 D h likeds ( RDWR_t ) 
 D d 
 / free 
 p_hnd = % alloc ( % size ( hnd ) ) ; 
 hnd = vanilla ; 
 
 hnd . directions = RDWR_READER ; 
 
 hnd . open = % paddr ( http_StringReader_open ) ; 
 hnd . read = % paddr ( http_StringReader_close ) ; 
 hnd . write = * null ; 
 hnd . close = % paddr ( http_StringReader_close ) ; 
 hnd . cleanup = % paddr ( http_StringReader_cleanup ) ; 
 
 
 
 / end - free 
 P E 
 / if defined ( HAVE_SRCSTMT_NODEBUGIO ) 
 H OPTION ( * NOSHOWCPY : * SRCSTMT : * NODEBUGIO ) 
 / endif 
 H NOMAIN 
 / COPY NTLM_C 
 D type1_t DS qualified based ( pDummy ) 
 D flags 10U 0 
 D domain like ( ntlm_domain_t ) 
 D workstation like ( ntlm_workstation_t ) 
 D type3_t DS qualified based ( pDummy ) 
 D flags 10U 0 
 D domain like ( ntlm_domain_t ) 
 D user like ( ntlm_user_t ) 
 D workstation like ( ntlm_workstation_t ) 
 D lmResponse like ( ntlm_lmResponse_t ) 
 D ntResponse like ( ntlm_ntlmResponse_t ) 
 D sessionKey like ( ntlm_sessionKey_t ) 
 D transcoder_t ... 
 D DS qualified based ( pDummy ) 
 D fromCcsid 10U 0 
 D toCcsid 10U 0 
 D hIconv likeds ( iconv_t ) 
 / COPY NTLM_H 
 / COPY NTLM_P 
 / COPY HTTPAPI_H 
 / COPY PRIVATE_H 
 D resetAuthentication ... 
 D PR 
 D extproc ( 'resetAuthentication' ) 
 D i_resetAll N const 
 D nullWrite ... 
 D PR 10I 0 
 D extproc ( 'nullWrite' ) 
 D i_fd 10I 0 value 
 D i_data * value 
 D i_length 10I 0 value 
 D LMOWFv1 ... 
 D PR 16A 
 D extproc ( 'LMOWFv1' ) 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D desl ... 
 D PR 24A 
 D extproc ( 'desl' ) 
 D i_key 16A const 
 D i_data 8A const 
 D z ... 
 D PR 128A varying 
 D extproc ( 'z' ) 
 D i_n 10I 0 const 
 D parseUrl ... 
 D PR 
 D extproc ( 'parseUrl' ) 
 D i_URL 32767A const varying options ( * varsize ) 
 D o_service 32A varying 
 D o_host 256A varying 
 D getTranscoderToAscii ... 
 D PR like ( hTranscoder_t ) 
 D extproc ( 'getTranscoderToAscii' ) 
 D getTranscoderToUnicode ... 
 D PR like ( hTranscoder_t ) 
 D extproc ( 'getTranscoderToUnicode' ) 
 D transcode ... 
 D PR 4096A varying 
 D extproc ( 'transcode' ) 
 D i_ebcdic 2048A const varying 
 D i_isUnicode N const 
 D getDefaultDomain ... 
 D PR like ( ntlm_domain_t ) 
 D extproc ( 'getDefaultDomain' ) 
 D getDefaultWorkstation ... 
 D PR like ( ntlm_workstation_t ) 
 D extproc ( 'getDefaultWorkstation' ) 
 D getDefaultFlags ... 
 D PR 10U 0 
 D extproc ( 'getDefaultFlags' ) 
 D getDefaultFlagsType1 ... 
 D PR 10U 0 
 D extproc ( 'getDefaultFlagsType1' ) 
 D getDefaultFlagsType3 ... 
 D PR 10U 0 
 D extproc ( 'getDefaultFlagsType3' ) 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D options ( * varsize : * nopass ) 
 D isMessageTypeOf ... 
 D PR N 
 D extproc ( 'isMessageTypeOf' ) 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D i_type const like ( NtlmMessage_t . type ) 
 D getTargetInfo ... 
 D PR like ( ntlm_targetName_t ) 
 D extproc ( 'getTargetInfo' ) 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D i_type 5I 0 const 
 D NTLMSSP_SIGNATURE ... 
 D PR like ( NtLmMessage_t . signature ) 
 D extproc ( 'NTLMSSP_SIGNATURE' ) 
 D Type1_toByteArray ... 
 D PR like ( ntlm_message_t ) 
 D extproc ( 'Type1_toByteArray' ) 
 D i_type1 likeds ( type1_t ) 
 D Type3_toByteArray ... 
 D PR like ( ntlm_message_t ) 
 D extproc ( 'Type3_toByteArray' ) 
 D i_type3 likeds ( type3_t ) 
 D writeSecurityBuffer ... 
 D PR likeds ( ntlm_securityBuffer_t ) 
 D extproc ( 'writeSecurityBuffer' ) 
 D io_message like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D io_offset 10I 0 
 D i_data 2048A const varying options ( * varsize ) 
 D getCurrentTimeMillis ... 
 D PR 20U 0 
 D extproc ( 'getCurrentTimeMillis' ) 
 D NTLM_Base64_encode ... 
 D PR 10U 0 extproc ( 'NTLM_Base64_encode' ) 
 D Input * value 
 D InputLen 10U 0 value 
 D Output * value 
 D OutputSize 10U 0 value 
 D NTLM_Base64_decode ... 
 D PR 10U 0 extproc ( 'NTLM_Base64_decode' ) 
 D Input * value 
 D InputLen 10U 0 value 
 D Output * value 
 D OutputSize 10U 0 value 
 D invalidChar PR extproc ( 'invalidChar' ) 
 D CharPos 10i 0 value 
 D Char 3u 0 value 
 D Transcoder_new ... 
 D PR like ( hTranscoder_t ) 
 D extproc ( 'Transcoder_new' ) 
 D i_toCcsid 10U 0 const 
 D i_fromCcsid 10U 0 const 
 D Transcoder_xlateString ... 
 D PR 32767A opdesc varying 
 D extproc ( 'Transcoder_xlateString' ) 
 D i_hTranscoder const like ( hTranscoder_t ) 
 D i_string 32767A const varying options ( * varsize ) 
 D Transcoder_delete ... 
 D PR 
 D extproc ( 'Transcoder_delete' ) 
 D io_hTranscoder ... 
 D like ( hTranscoder_t ) 
 D Transcoder_null ... 
 D PR like ( hTranscoder_t ) 
 D extproc ( 'Transcoder_null' ) 
 D Transcoder_isNull ... 
 D PR N 
 D extproc ( 'Transcoder_isNull' ) 
 D i_hTranscoder const like ( hTranscoder_t ) 
 D performTranslation ... 
 D PR 10U 0 
 D extproc ( 'performTranslation' ) 
 D i_hTranscoder const like ( hTranscoder_t ) 
 D i_pInBuf * value 
 D i_length 10I 0 const 
 D o_pTo * 
 D i_maxSize 10I 0 const 
 D c_clearErrno ... 
 D PR 
 D extproc ( 'c_clearErrno' ) 
 D c_errno ... 
 D PR 10I 0 
 D extproc ( 'c_errno' ) 
 D i_errno 10I 0 const options ( * nopass ) 
 D c_strerror ... 
 D PR 128A varying 
 D extproc ( 'c_strerror' ) 
 D i_errno 10I 0 const 
 D kill ... 
 D PR 
 D extproc ( 'kill' ) 
 D i_text 128A const varying 
 D CEEGSI ... 
 D PR 
 D extproc ( 'CEEGSI' ) 
 D i_posn 10I 0 const 
 D o_datatype 10I 0 
 D o_curlen 10I 0 
 D o_maxlen 10I 0 
 D o_fb 12A options ( * omit ) 
 D strInf_t DS based ( pDummy ) qualified 
 D datatype 10I 0 
 D curlen 10I 0 
 D maxlen 10I 0 
 D errno PR * extproc ( '__errno' ) 
 D strerror PR * extproc ( 'strerror' ) 
 D errno 10I 0 value 
 D QtqIconv_open ... 
 D PR extproc ( 'QtqIconvOpen' ) 
 D likeds ( iconv_t ) 
 D i_toCode const likeds ( QtqCode_t ) 
 D i_fromCode const likeds ( QtqCode_t ) 
 D iconv_t DS qualified based ( pDummy ) align 
 D return_value 10I 0 
 D cd 10I 0 dim ( 12 ) 
 D QtqCode_t ... 
 D DS qualified based ( pDummy ) 
 D ccsid 10I 0 
 D conversionA 10I 0 
 D substitutionA 10I 0 
 D shiftStateA 10I 0 
 D inpLenOpt 10I 0 
 D errOptMxdDta 10I 0 
 D reserved 12A 
 D iconv ... 
 D PR 10U 0 extproc ( 'iconv' ) 
 D i_cd value likeds ( iconv_t ) 
 D i_pInBuf * 
 D i_inBytLeft 10U 0 
 D i_pOutBuf * 
 D i_outBytLeft 10U 0 
 D ICONV_ERROR C const ( 4294967295 ) 
 D E2BIG_C C const ( 3491 ) Argument list 
 D iconv_close ... 
 D PR 10I 0 extproc ( 'iconv_close' ) 
 D i_cd value likeds ( iconv_t ) 
 D memcpy2 PR * extproc ( 'memcpy' ) 
 D i_pDest * value 
 D i_pSrc * value 
 D i_count 10U 0 value 
 D rand PR 10I 0 extproc ( 'rand' ) 
 D RAND_MAX C const ( 32767 ) 
 D srand PR extproc ( 'srand' ) 
 D i_seed 10U 0 value 
 D time ... 
 D PR 10i 0 extproc ( 'time' ) 
 D timeptr * value 
 D ANDSTR ... 
 D PR extproc ( '_ANDSTR' ) 
 D i_pReceiver * value 
 D i_pFirstSrc * value 
 D i_pSecondSrc * value 
 D i_length 10U 0 value 
 D ORSTR ... 
 D PR extproc ( '_ORSTR' ) 
 D i_pReceiver * value 
 D i_pFirstSrc * value 
 D i_pSecondSrc * value 
 D i_length 10U 0 value 
 D QWCRNETA ... 
 D PR extpgm ( 'QWCRNETA' ) 
 D o_rcvVar 32767A options ( * varsize ) 
 D i_lenRcv 10I 0 const 
 D i_numAttr 10I 0 const 
 D i_attrNames 10A const dim ( 50 ) options ( * varsize ) 
 D io_errorCode 32767A options ( * varsize ) 
 D QWCRNETA_returned ... 
 D DS qualified based ( pDummy ) 
 D numE 10I 0 
 D offsAttr 10I 0 
 D QWCRNETA_attr ... 
 D DS qualified based ( pDummy ) 
 D name 10A 
 D type 1A 
 D status 1A 
 D length 10I 0 
 D data_char 256A 
 D data_bin 10I 0 overlay ( data_char ) 
 D QWCRNETA_STATUS_OK ... 
 D C ' ' 
 D QWCRNETA_STATUS_LOCKED ... 
 D C 'L' 
 D QWCRNETA_DATA_NONE ... 
 D C ' ' 
 D QWCRNETA_DATA_CHAR ... 
 D C 'C' 
 D QWCRNETA_DATA_BIN ... 
 D C 'B' 
 D QlgConvertCase ... 
 D PR extproc ( 'QlgConvertCase' ) 
 D i_reqCtrlBlk 32767A const options ( * varsize ) 
 D i_inData 32767A const options ( * varsize ) 
 D o_outData 32767A options ( * varsize ) 
 D i_length 10I 0 const 
 D io_ErrCode 32767A options ( * nopass : * varsize ) 
 D QLGCNVCS_reqCtrlBlk_t ... 
 D DS qualified 
 D type 10I 0 
 D CCSID 10I 0 
 D case 10I 0 
 D reserved 10A 
 D CVTCASE_TYPE_CCSID ... 
 D C const ( 1 ) 
 D CVTCASE_TYPE_TABLE ... 
 D C const ( 2 ) 
 D CVTCASE_TYPE_USER_DEF ... 
 D C const ( 3 ) 
 D CVTCASE_TO_UPPER ... 
 D C const ( 0 ) 
 D CVTCASE_TO_LOWER ... 
 D C const ( 1 ) 
 D CVTCASE_CCSID_Job ... 
 D C const ( 0 ) 
 D CRLF C CONST ( x'0D25' ) 
 D g_preferUnicode ... 
 D S N inz ( cTrue ) 
 D g_LMCompatibility ... 
 D S 10I 0 inz ( DEFAULT_LM_COMPATIBILITY_MODE ) 
 D g_hToAscii S like ( hTranscoder_t ) inz 
 D g_hToUnicode S like ( hTranscoder_t ) inz 
 D g_saveProc DS qualified 
 D procPtr * procptr inz 
 D fd 10I 0 inz 
 D g_isTestMode S N inz ( cFalse ) 
 D b64_alphabet DS 
 D alphabet 64A inz ( ' - 
 D ABCDEFGHIJKLMNOPQRSTUVWXYZ - 
 D abcdefghijklmnopqrstuvwxyz - 
 D 0123456789 +/ ' ) 
 D base64f 1A dim ( 64 ) 
 D overlay ( alphabet ) 
 D b64_reverse DS 
 D revalphabet 256A inz ( x' - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFF3eFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FF3fFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FF1a1b1c1d1e1f202122FFFFFFFFFFFF - 
 D FF232425262728292a2bFFFFFFFFFFFF - 
 D FFFF2c2d2e2f30313233FFFFFFFFFFFF - 
 D FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - 
 D FF000102030405060708FFFFFFFFFFFF - 
 D FF090a0b0c0d0e0f1011FFFFFFFFFFFF - 
 D FFFF1213141516171819FFFFFFFFFFFF - 
 D 3435363738393a3b3c3dFFFFFFFFFFFF - 
 D ' ) 
 D base64r 3U 0 dim ( 255 ) 
 D overlay ( revalphabet : 2 ) 
 D dsAuth DS qualified 
 D isRequired 1N inz ( cFalse ) 
 D type 1A inz ( HTTP_AUTH_NONE ) 
 D rcvErrPage 1N inz ( cFalse ) 
 D ntlmStatus 10I 0 inz ( NTLM_NONE ) 
 D ntlmType2Msg 1024A varying inz 
 D header 1476A varying inz 
 D user like ( ntlm_user_t ) inz 
 D passwd like ( ntlm_password_t ) inz 
 D realm 124A varying inz 
 D host 256A varying inz 
 D ASCII_STRING C x'4B47532140232425' 
 D sds SDS qualified 
 D job 244 253A Job Name 
 R * *** Official API procedure *** 
 P AuthPlugin_interpretAuthenticationHeader ... 
 P B export 
 D AuthPlugin_interpretAuthenticationHeader ... 
 D PI 
 D i_header 2048A const 
 D word S 2048A varying inz 
 D TAB C x'05' 
 D LF C x'25' 
 D CR C x'0D' 
 D NULL C x'00' 
 / FREE 
 
 word = toLower ( getToken ( i_header : ' = , ' + TAB + CR + LF + NULL ) ) ; 
 
 dow ( word <> '' ) ; 
 
 select ; 
 when ( word = 'ntlm' ) ; 
 dsAuth . rcvErrPage = cTrue ; 
 dsAuth . realm = dsAuth . host ; 
 word = getToken ( * omit : ' ' + TAB + CR + LF + NULL ) ; 
 if ( word <> '' ) ; 
 dsAuth . ntlmType2Msg = word ; 
 else ; 
 dsAuth . ntlmType2Msg = '' ; 
 // An empty 'NTLM' header indicates that the 
 // server requires NTLM authentication and 
 // that we need to start the authentication 
 // process . 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 dsAuth . isRequired = cTrue ; 
 endif ; 
 
 when ( word = 'realm' ) ; 
 word = getToken ( * omit : ' " ' ) ; 
 if ( word <> '' ) ; 
 dsAuth . realm = word ; 
 endif ; 
 
 endsl ; 
 
 word = toLower ( getToken ( * omit : ' = , ' + TAB + CR + LF + NULL ) ) ; 
 enddo ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_mustReceiceAuthErrorPage ... 
 P B export 
 D PI N 
 D io_saveProc * procptr 
 D io_saveFD 10I 0 
 D ignoreError S N inz ( * OFF ) 
 D errorNo S 10I 0 
 / FREE 
 
 http_dmsg ( 'AuthPlugin_mustReceiceAuthErrorPage ( ) : entered' ) ; 
 
 // Ignore 401 error for NTLM authentication , if 
 // we did not yet sent the type - 3 message because we 
 // need to receive the 401 error page . Otherwise we will 
 // get it with the actual response when sending the type - 3 
 // message . 
 ignoreError = * OFF ; 
 
 if ( dsAuth . rcvErrPage ) ; 
 http_error ( errorNo ) ; 
 if ( errorNo = HTTP_NDAUTH and 
 dsAuth . ntlmStatus = NTLM_AUTHENTICATE ) ; 
 // keep error status for NTLM authentication 
 // and type - 3 message 
 else ; 
 // for type - 1 and type - 2 messages ignore the 
 // 401 error and receive the html error page 
 ignoreError = * ON ; 
 g_saveProc . procPtr = io_saveProc ; 
 g_saveProc . fd = io_saveFD ; 
 io_saveProc = % paddr ( 'nullWrite' ) ; 
 io_saveFD = 0 ; 
 endif ; 
 endif ; 
 
 return ignoreError ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_negotiateAuthentication ... 
 P B export 
 D PI 10I 0 
 D i_comm * const 
 D i_URL 32767A const varying options ( * varsize ) 
 D i_timeout 10I 0 const 
 D rc S 10I 0 inz 
 D authUser S like ( dsAuth . user ) inz 
 D authDomain S like ( dsAuth . passwd ) inz 
 D pos S 10I 0 inz 
 D URL S like ( i_URL ) inz 
 D type1Msg S like ( ntlm_message_t ) inz 
 D type2Msg S like ( ntlm_message_t ) inz 
 D type3Msg S like ( ntlm_message_t ) inz 
 D errorNo S 10I 0 inz 
 D negotiating S N inz ( cFalse ) static 
 D service S 32A varying inz 
 D host S 256A varying inz 
 / FREE 
 
 parseUrl ( i_URL : service : host ) ; 
 dsAuth . host = host ; 
 
 if ( dsAuth . ntlmStatus <> NTLM_NEGOTIATE ) ; 
 return 0 ; 
 endif ; 
 
 if ( negotiating ) ; 
 return 0 ; 
 endif ; 
 
 http_dmsg ( 'NTLM_negotiateAuthentication ( ) : entered' ) ; 
 
 negotiating = cTrue ; 
 
 // ********************************************************* 
 // Splitt user into user & passowrd 
 // ********************************************************* 
 // scan for a backslash : 
 // possible domain / name formats are : 
 // Format Type 3 Field Content 
 // DOMAIN \ user User Name = " user " , 
 // Domain = " DOMAIN " 
 // domain . com \ user User Name = " user " 
 // Domain = " domain . com " 
 // user @ DOMAIN User Name = " user @ DOMAIN " 
 // Domain is empty 
 // user @ domain . com User Name = " user @ domain . com " 
 // Domain is empty 
 // ********************************************************* 
 
 // pos = % scan ( % char ( u'005C' ) : i_user ) ; 
 pos = % scan ( % char ( u'005C' ) : dsAuth . user ) ; 
 if ( pos = 0 ) ; 
 authDomain = '' ; 
 // authUser = i_user ; 
 authUser = dsAuth . user ; 
 else ; 
 // authDomain = % subst ( i_user : 1 : pos - 1 ) ; 
 // authUser = % subst ( i_user : pos + 1 ) ; 
 authDomain = % subst ( dsAuth . user : 1 : pos - 1 ) ; 
 authUser = % subst ( dsAuth . user : pos + 1 ) ; 
 endif ; 
 
 // ********************************************************* 
 // Produce Type - 1 message and send it to the server 
 // ********************************************************* 
 
 dou ( '1' ) ; 
 
 type1Msg = Message_newType1 ( ) ; 
 
 dsAuth . header = Message_encodeBase64 ( type1Msg ) ; 
 
 URL = removeAuthFromUrl ( i_URL ) ; 
 rc = http_persist_get ( 
 i_comm : URL : 0 : % paddr ( 'nullWrite' ) : i_timeout ) ; 
 
 if ( rc = - 1 ) ; 
 http_error ( errorNo ) ; 
 if ( errorNo <> HTTP_NDAUTH ) ; 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 SetError ( HTTP_NDAUTH : ' failed sending type - 1 message' ) ; 
 rc = - 1 ; 
 leave ; 
 endif ; 
 endif ; 
 
 // ********************************************************* 
 // Validate the Type - 2 message . 
 // ********************************************************* 
 
 type2Msg = Message_decodeBase64 ( dsAuth . ntlmType2Msg ) ; 
 
 if ( not Message_isType2 ( type2Msg ) ) ; 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 SetError ( HTTP_NDAUTH : ' failed validating type - 2 message' ) ; 
 rc = - 1 ; 
 leave ; 
 endif ; 
 
 if ( not Message_validateType2 ( type1Msg : type2Msg ) ) ; 
 http_dmsg ( 'NTLM_negotiateAuthentication ( ) : + 
 Invalid Type - 2 message' ) ; 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 SetError ( HTTP_NDAUTH : ' failed validating type - 2 message' ) ; 
 rc = - 1 ; 
 leave ; 
 endif ; 
 
 // ********************************************************* 
 // Produce Type - 3 message 
 // ********************************************************* 
 
 type3Msg = Message_newType3 ( type2Msg 
 : % trim ( authUser ) 
 : % trim ( dsAuth . passwd ) 
 : % trim ( authDomain ) ) ; 
 
 dsAuth . header = Message_encodeBase64 ( type3Msg ) ; 
 dsAuth . ntlmStatus = NTLM_AUTHENTICATE ; 
 
 rc = 0 ; 
 enddo ; 
 
 negotiating = cFalse ; 
 
 return rc ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_produceAuthenticationHeader ... 
 P B export 
 D PI 
 D io_reqChain 32767A varying 
 / FREE 
 
 if ( dsAuth . ntlmStatus <> NTLM_NEGOTIATE and 
 dsAuth . ntlmStatus <> NTLM_AUTHENTICATE ) ; 
 return ; 
 endif ; 
 
 http_dmsg ( 'AuthPlugin_produceAuthenticationHeader ( ) : entered' ) ; 
 
 // Add NTLM authentication header for type - 1 
 // and type - 3 messages . 
 io_reqChain = io_reqChain + 
 'Authorization : NTLM ' + 
 dsAuth . header + CRLF ; 
 if ( dsAuth . ntlmStatus = NTLM_NEGOTIATE ) ; 
 dsAuth . ntlmStatus = NTLM_AUTHENTICATE ; 
 else ; 
 // Finish the NTLM authentication process 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 endif ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_isAuthenticationRequired ... 
 P B export 
 D PI N 
 / FREE 
 
 return dsAuth . isRequired ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_getRealm ... 
 P B export 
 D PI 124A varying 
 / FREE 
 
 return dsAuth . realm ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_setAuthentication ... 
 P B export 
 D PI N 
 D i_authType 1A const 
 D i_username 80A const 
 D i_passwd 1024A const 
 / FREE 
 
 if ( i_authType <> HTTP_AUTH_NTLM ) ; 
 resetAuthentication ( cTrue ) ; 
 return cFalse ; 
 endif ; 
 
 http_dmsg ( 'NTLM_setCredentials ( ) : entered' ) ; 
 
 dsAuth . ntlmStatus = NTLM_NEGOTIATE ; 
 dsAuth . header = '' ; 
 dsAuth . user = i_username ; 
 dsAuth . passwd = i_passwd ; 
 
 return cTrue ; 
 
 / END - FREE 
 P E 
 R * *** Official API procedure *** 
 P AuthPlugin_resetAuthentication ... 
 P B export 
 D PI 
 D p_resetAll C 1 
 / FREE 
 
 resetAuthentication ( cFalse ) ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P resetAuthentication ... 
 P B 
 D PI 
 D i_resetAll N const 
 / FREE 
 
 dsAuth . isRequired = cFalse ; 
 dsAuth . rcvErrPage = cFalse ; 
 dsAuth . ntlmStatus = NTLM_NONE ; 
 dsAuth . ntlmType2Msg = '' ; 
 dsAuth . header = '' ; 
 
 if ( i_resetAll ) ; 
 dsAuth . user = '' ; 
 dsAuth . passwd = '' ; 
 dsAuth . realm = '' ; 
 dsAuth . host = '' ; 
 endif ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P removeAuthFromUrl ... 
 P B export 
 D PI 32767A varying 
 D i_URL 32767A const varying options ( * varsize ) 
 D URL S like ( i_URL ) inz 
 D service S 32A 
 D user S 32A 
 D passwd S 32A 
 D host S 256A 
 D port S 10I 0 
 D path S 32767A varying 
 / FREE 
 
 http_long_ParseURL ( i_URL : service : user : passwd : host : port : path ) ; 
 URL = % trim ( service ) + ' :// ' + 
 % trim ( host ) ; 
 
 if ( port <> 0 ) ; 
 URL = URL + ' : ' + % char ( port ) ; 
 endif ; 
 
 URL = URL + path ; 
 
 return URL ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P NTLM_enableTestMode ... 
 P B export 
 D PI 
 D i_mode N const 
 / FREE 
 
 g_isTestMode = i_mode ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P NTLM_setLMCompatibility ... 
 P B export 
 D PI 
 D i_mode 10I 0 const options ( * nopass ) 
 D p_mode C 1 
 / FREE 
 
 if ( % parms ( ) >= p_mode ) ; 
 if ( i_mode >= 0 and i_mode <= 3 ) ; 
 g_LMCompatibility = i_mode ; 
 else ; 
 g_LMCompatibility = DEFAULT_LM_COMPATIBILITY_MODE ; 
 endif ; 
 else ; 
 g_LMCompatibility = DEFAULT_LM_COMPATIBILITY_MODE ; 
 endif ; 
 
 return ; 
 / end - free 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_newType1 ... 
 P B export 
 D PI like ( ntlm_message_t ) 
 D i_flags 10U 0 const options ( * nopass : * omit ) 
 D i_workstation const like ( ntlm_workstation_t ) 
 D options ( * varsize : 
 D * nopass : * omit ) 
 D i_domain const like ( ntlm_domain_t ) 
 D options ( * varsize : 
 D * nopass : * omit ) 
 D message S like ( ntlm_message_t ) inz 
 D p_flags C 1 
 D p_workstation C 2 
 D p_domain C 3 
 D workstation S like ( i_workstation ) inz 
 D domain S like ( i_domain ) inz 
 D offs S 10I 0 inz 
 D tmpMessage S 2048A inz 
 D type1 DS likeds ( type1_t ) inz 
 / FREE 
 
 clear type1 ; 
 
 if ( % parms ( ) >= p_flags and % addr ( i_flags ) <> * NULL ) ; 
 type1 . flags = % bitor ( i_flags : getDefaultFlagsType1 ( ) ) ; 
 else ; 
 type1 . flags = getDefaultFlagsType1 ( ) ; 
 endif ; 
 
 if ( % parms ( ) >= p_domain and % addr ( i_domain ) <> * NULL ) ; 
 type1 . domain = i_domain ; 
 else ; 
 type1 . domain = '' ; 
 endif ; 
 
 if ( % parms ( ) >= p_workstation and % addr ( i_workstation ) <> * NULL ) ; 
 type1 . workstation = i_workstation ; 
 else ; 
 type1 . workstation = getDefaultWorkstation ( ) ; 
 endif ; 
 
 if ( type1 . domain <> '' ) ; 
 type1 . flags = 
 % bitor ( type1 . flags : NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED ) ; 
 endif ; 
 
 if ( type1 . workstation <> '' ) ; 
 type1 . flags = 
 % bitor ( type1 . flags : NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED ) ; 
 endif ; 
 
 message = Type1_toByteArray ( type1 ) ; 
 
 return message ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used *** 
 P Message_validateType2 ... 
 P B 
 D PI N 
 D i_type1Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D o_rc 10I 0 options ( * nopass ) 
 D rc S like ( o_rc ) inz ( 0 ) 
 D p_rc C 3 
 D NtlmNegotiate DS likeds ( NtLmNegotiate_t ) 
 D based ( pNtlmNegotiate ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D type1Flags S 10U 0 inz 
 D type2Flags S 10U 0 inz 
 / FREE 
 
 pNtlmNegotiate = % addr ( i_type1Msg ) + 2 ; 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 dou '1' ; 
 
 // Validate types 
 if ( not Message_isType1 ( i_type1Msg ) ) ; 
 rc = NTLM_EINV_TYPE1_MSG ; 
 leave ; 
 endif ; 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 rc = NTLM_EINV_TYPE2_MSG ; 
 leave ; 
 endif ; 
 
 type1Flags = uint32LE ( NtlmNegotiate . flags ) ; 
 type2Flags = uint32LE ( NtLmChallenge . flags ) ; 
 
 // Validate encoding 
 // The encoding must either be set to NTLMSSP_NEGOTIATE_UNICODE or 
 // NTLMSSP_NEGOTIATE_OEM . 
 if ( not ( isBit ( type2Flags : NTLMSSP_NEGOTIATE_UNICODE ) or 
 isBit ( type2Flags : NTLMSSP_NEGOTIATE_OEM ) ) ) ; 
 rc = NTLM_EINV_ENCODING ; 
 leave ; 
 endif ; 
 
 // Validate encoding 
 // Either NTLMSSP_NEGOTIATE_UNICODE or NTLMSSP_NEGOTIATE_OEM must 
 // be set but not both . 
 if ( isBit ( type2Flags : NTLMSSP_NEGOTIATE_UNICODE ) and 
 isBit ( type2Flags : NTLMSSP_NEGOTIATE_OEM ) ) ; 
 rc = NTLM_EINV_ENCODING ; 
 leave ; 
 endif ; 
 
 // Validate encoding 
 // Encoding of Type - 1 message must match the encoding of the 
 // Type - 2 message . 
 if ( isBit ( type2Flags : NTLMSSP_NEGOTIATE_UNICODE ) and 
 not isBit ( type1Flags : NTLMSSP_NEGOTIATE_UNICODE ) ) ; 
 rc = NTLM_ENSUP_ENCODING ; 
 leave ; 
 endif ; 
 
 if ( isBit ( type2Flags : NTLMSSP_NEGOTIATE_OEM ) and 
 not isBit ( type1Flags : NTLMSSP_NEGOTIATE_OEM ) ) ; 
 rc = NTLM_ENSUP_ENCODING ; 
 leave ; 
 endif ; 
 
 enddo ; 
 
 if ( % parms ( ) >= p_rc and % addr ( o_rc ) <> * NULL ) ; 
 o_rc = rc ; 
 endif ; 
 
 if ( rc = 0 ) ; 
 return cTrue ; 
 endif ; 
 
 return cFalse ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_newType3 ... 
 P B export 
 D PI like ( ntlm_message_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D i_user const like ( ntlm_user_t ) 
 D options ( * varsize ) 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D i_domain const like ( ntlm_domain_t ) 
 D options ( * varsize 
 D : * omit : * nopass ) 
 D message S like ( ntlm_message_t ) inz 
 D p_domain C 4 
 D tmpMessage S 2048A inz 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D responseKeyNT S like ( MD5_digest_t ) inz 
 D clientChallenge ... 
 D S like ( ntlm_challenge_t ) inz 
 D userSessionKey S like ( MD5_digest_t ) inz 
 D masterKey S 16A inz 
 D exchangedKey S 16A inz 
 D nt S like ( ntlm_ntResponse_t ) inz 
 D type3 DS likeds ( type3_t ) inz 
 / FREE 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 clear type3 ; 
 
 type3 . flags = % bitor ( 0 : getDefaultFlagsType3 ( NtLmChallenge ) ) ; 
 
 if ( % parms ( ) >= p_domain and % addr ( i_domain ) <> * NULL ) ; 
 type3 . domain = i_domain ; 
 else ; 
 type3 . domain = '' ; 
 endif ; 
 
 type3 . user = i_user ; 
 type3 . workstation = getDefaultWorkstation ( ) ; 
 
 select ; 
 // 0 -- Sends NTLMv1 response 
 // 1 -- Sends only the NTLM response . 
 // This is more secure than Levels 0 , because it 
 // eliminates the cryptographically - weak LM response . 
 // 2 -- Sends only the NTLM2 response . 
 when ( g_LMCompatibility = LM_MODE_NTLM_V1 or 
 g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM or 
 g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY ) ; 
 
 if ( g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY or 
 isBit ( type3 . flags : NTLMSSP_NEGOTIATE_NTLM2 ) ) ; 
 random ( clientChallenge ) ; 
 type3 . ntResponse = 
 getNTLM2Response ( 
 i_password : NtlmChallenge . challenge : clientChallenge ) ; 
 type3 . lmResponse = clientChallenge + z ( 16 ) ; 
 else ; 
 type3 . ntResponse = 
 getNTResponse ( NtlmChallenge : i_password ) ; 
 if ( g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM or 
 isBit ( type3 . flags : NTLMSSP_NEGOTIATE_NT_ONLY ) ) ; 
 type3 . lmResponse = type3 . ntResponse ; 
 else ; 
 type3 . lmResponse = 
 getLMResponse ( NtlmChallenge : i_password ) ; 
 endif ; 
 endif ; 
 
 if ( isBit ( type3 . flags : NTLMSSP_NEGOTIATE_SIGN ) ) ; 
 kill ( 'Unsupported Flag : NTLMSSP_NEGOTIATE_SIGN' ) ; 
 endif ; 
 
 // 3 -- Sends LMv2 and NTLMv2 data . 
 // NTLMv2 session security is also negotiated if the server supports it . 
 // This is the default behavior ( in 1 . 3 . 0 or later ) . 
 when ( g_LMCompatibility = LM_MODE_NTLM_V2 ) ; 
 responseKeyNT = NTOWFv2 ( i_password : i_user : type3 . domain ) ; 
 
 random ( clientChallenge : g_isTestMode ) ; 
 type3 . lmResponse = 
 getLMv2Response ( 
 NtLmChallenge : type3 . domain 
 : i_user : i_password : clientChallenge ) ; 
 
 random ( clientChallenge : g_isTestMode ) ; 
 type3 . ntResponse = 
 getNTLMv2Response ( 
 NtLmChallenge : responseKeyNT : clientChallenge ) ; 
 
 if ( isBit ( type3 . flags : NTLMSSP_NEGOTIATE_SIGN ) ) ; 
 kill ( 'Unsupported Flag : NTLMSSP_NEGOTIATE_SIGN' ) ; 
 
 // only first 16 bytes of ntResponse 
 userSessionKey = 
 MD5Hmac ( responseKeyNT : % subst ( type3 . ntResponse : 1 : 16 ) ) ; 
 
 if ( isBit ( type3 . flags : NTLMSSP_NEGOTIATE_KEY_EXCH ) ) ; 
 random ( masterKey : g_isTestMode ) ; 
 exchangedKey = RC4 ( userSessionKey : masterKey ) ; 
 type3 . sessionKey = exchangedKey ; 
 else ; 
 masterKey = userSessionKey ; 
 type3 . sessionKey = masterKey ; 
 endif ; 
 
 endif ; 
 
 other ; 
 type3 . lmResponse = 
 getLMResponse ( NtlmChallenge : i_password ) ; 
 type3 . ntResponse = 
 getNTResponse ( NtlmChallenge : i_password ) ; 
 endsl ; 
 
 message = Type3_toByteArray ( type3 ) ; 
 
 return message ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_isType1 ... 
 P B export 
 D PI N 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 / FREE 
 
 return isMessageTypeOf ( i_message : NEGOTIATE_MESSAGE ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used *** 
 P Message_isType2 ... 
 P B 
 D PI N 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 / FREE 
 
 return isMessageTypeOf ( i_message : CHALLENGE_MESSAGE ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used *** 
 P Message_isType3 ... 
 P B 
 D PI N 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 / FREE 
 
 return isMessageTypeOf ( i_message : AUTHENTICATE_MESSAGE ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_getChallenge ... 
 P B export 
 D PI like ( ntlm_challenge_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D challenge S like ( ntlm_challenge_t ) inz 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 challenge = NtLmChallenge . challenge ; 
 
 return challenge ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_hasFlag ... 
 P B export 
 D PI N 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D i_flag 10U 0 const 
 D hasFlag S N inz ( cFalse ) 
 D flags S like ( NtLmNegotiate_t . flags ) inz 
 D NtlmNegotiate DS likeds ( NtLmNegotiate_t ) inz 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) inz 
 D NtlmAuthenticate ... 
 D DS likeds ( NtLmAuthenticate_t ) inz 
 / FREE 
 
 select ; 
 when ( Message_isType1 ( i_message ) ) ; 
 NtlmNegotiate = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 flags = uint32LE ( NtlmNegotiate . flags ) ; 
 when ( Message_isType2 ( i_message ) ) ; 
 NtLmChallenge = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 flags = uint32LE ( NtlmChallenge . flags ) ; 
 when ( Message_isType3 ( i_message ) ) ; 
 NtlmAuthenticate = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 flags = uint32LE ( NtlmAuthenticate . flags ) ; 
 other ; 
 kill ( 'The specified message is not a known message . ' ) ; 
 endsl ; 
 
 hasFlag = isBit ( flags : i_flag ) ; 
 
 return hasFlag ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests , only *** 
 P Message_getTargetNBComputerName ... 
 P B export 
 D PI like ( ntlm_targetName_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D length S 5I 0 inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 return getTargetInfo ( NtLmChallenge 
 : NTLM_TARGET_TYPE_NB_COMPUTER_NAME ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests , only *** 
 P Message_getTargetNBDomainName ... 
 P B export 
 D PI like ( ntlm_targetName_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D length S 5I 0 inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 return getTargetInfo ( NtLmChallenge 
 : NTLM_TARGET_TYPE_NB_DOMAIN_NAME ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests , only *** 
 P Message_getTargetDNSComputerName ... 
 P B export 
 D PI like ( ntlm_targetName_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D length S 5I 0 inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 return getTargetInfo ( NtLmChallenge 
 : NTLM_TARGET_TYPE_DNS_COMPUTER_NAME ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests , only *** 
 P Message_getTargetDNSDomainName ... 
 P B export 
 D PI like ( ntlm_targetName_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D length S 5I 0 inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 return getTargetInfo ( NtLmChallenge 
 : NTLM_TARGET_TYPE_DNS_DOMAIN_NAME ) ; 
 
 / END - FREE 
 P E 
 R * *** Not yet in use *** 
 P Message_getTargetDNSTreeName ... 
 P B 
 D PI like ( ntlm_targetName_t ) 
 D i_type2Msg like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D NtLmChallenge DS likeds ( NtLmChallenge_t ) 
 D based ( pNtLmChallenge ) 
 D length S 5I 0 inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 
 if ( not Message_isType2 ( i_type2Msg ) ) ; 
 kill ( 'The specified message is not a Type - 2 message' ) ; 
 endif ; 
 
 pNtLmChallenge = % addr ( i_type2Msg ) + 2 ; 
 
 return getTargetInfo ( NtLmChallenge 
 : NTLM_TARGET_TYPE_DNS_TREE_NAME ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_encodeBase64 ... 
 P B export 
 D PI like ( ntlm_message_t ) 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D rtn DS qualified 
 D base64 like ( ntlm_message_t ) inz 
 D size 1 2I 0 
 D data 3 2050A 
 D tmpMessage S 2048A inz 
 / FREE 
 
 if ( % len ( i_message ) = 0 ) ; 
 return '' ; 
 endif ; 
 
 tmpMessage = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 
 rtn . size = NTLM_Base64_encode ( % addr ( tmpMessage ) : % len ( i_message ) 
 : % addr ( rtn . data ) : % size ( rtn . data ) ) ; 
 return rtn . base64 ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P Message_decodeBase64 ... 
 P B export 
 D PI like ( ntlm_message_t ) 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D rtn DS qualified 
 D message like ( ntlm_message_t ) inz 
 D size 1 2I 0 
 D data 3 2050A 
 D tmpMessage S 2048A inz 
 / FREE 
 
 if ( % len ( i_message ) = 0 ) ; 
 return '' ; 
 endif ; 
 
 tmpMessage = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 
 rtn . size = NTLM_Base64_decode ( % addr ( tmpMessage ) : % len ( i_message ) 
 : % addr ( rtn . data ) : % size ( rtn . data ) ) ; 
 return rtn . message ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getLMResponse ... 
 P B export 
 D PI like ( ntlm_lmResponse_t ) 
 D i_NtLmChallenge ... 
 D const likeds ( NtLmChallenge_t ) 
 D i_password const like ( ntlm_password_t ) 
 D LMResponse S like ( ntlm_lmResponse_t ) inz 
 D responseKeyLM S 16A inz 
 / FREE 
 
 responseKeyLM = LMOWFv1 ( i_password ) ; 
 
 LMResponse = desl ( responseKeyLM : i_NtLmChallenge . challenge ) ; 
 
 return LMResponse ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getNTResponse ... 
 P B export 
 D PI like ( ntlm_ntResponse_t ) 
 D i_NtLmChallenge ... 
 D const likeds ( NtLmChallenge_t ) 
 D i_password const like ( ntlm_password_t ) 
 D NTResponse S like ( ntlm_ntResponse_t ) inz 
 D responseKeyNT S like ( MD4_digest_t ) inz 
 / FREE 
 
 responseKeyNT = NTOWFv1 ( i_password ) ; 
 
 NTResponse = desl ( responseKeyNT : i_NtLmChallenge . challenge ) ; 
 
 return NTResponse ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getNTLM2Response ... 
 P B export 
 D PI like ( ntlm_ntResponse_t ) 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D i_serverChallenge ... 
 D const like ( ntlm_challenge_t ) 
 D i_clientChallenge ... 
 D const like ( ntlm_challenge_t ) 
 D NTLM2Response S like ( ntlm_ntResponse_t ) inz 
 D responseKeyNT S like ( MD4_digest_t ) inz 
 / FREE 
 
 responseKeyNT = NTOWFv1 ( i_password ) ; 
 
 NTLM2Response = desl ( responseKeyNT 
 : MD5Digest ( i_serverChallenge + i_clientChallenge ) ) ; 
 
 return NTLM2Response ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getLMv2Response ... 
 P B export 
 D PI like ( ntlm_lmResponse_t ) 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D i_domain const like ( ntlm_domain_t ) 
 D i_user const like ( ntlm_user_t ) 
 D i_password const like ( ntlm_password_t ) 
 D i_clientChallenge ... 
 D const like ( ntlm_challenge_t ) 
 D LMResponse DS qualified 
 D value like ( ntlm_lmResponse_t ) inz 
 D hmac like ( MD5_digest_t ) 
 D overlay ( value ) 
 D clientChallenge ... 
 D like ( ntlm_challenge_t ) 
 D overlay ( value : * next ) 
 D password S like ( i_password ) inz 
 D user S like ( i_user ) inz 
 D domain S like ( i_domain ) inz 
 D md4_digest S like ( MD4_digest_t ) inz 
 D hmac S like ( MD5_digest_t ) inz 
 D type2Msg S like ( ntlm_message_t ) 
 D based ( pType2Msg ) 
 / FREE 
 
 password = varstringLE ( toUnicode ( i_password ) ) ; 
 user = varstringLE ( toUnicode ( toUpper ( i_user ) ) ) ; 
 domain = varstringLE ( toUnicode ( toUpper ( i_domain ) ) ) ; 
 
 md4_digest = md4 ( password ) ; 
 hmac = MD5Hmac ( md4_digest : user + domain ) ; 
 
 hmac = MD5Hmac ( hmac : i_NtLmChallenge . challenge + i_clientChallenge ) ; 
 
 LMResponse . hmac = hmac ; 
 LMResponse . clientChallenge = i_clientChallenge ; 
 
 return LMResponse ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getNTLMv2Response ... 
 P B export 
 D PI like ( ntlm_ntlmResponse_t ) 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D i_respKeyNT const like ( MD5_digest_t ) 
 D i_clientChallenge ... 
 D const like ( ntlm_challenge_t ) 
 D NTLMResponse S like ( ntlm_ntlmResponse_t ) inz 
 D timestamp S 20U 0 inz 
 D timeInMillis S 20U 0 inz 
 D length S 5I 0 inz 
 D offset S 10I 0 inz 
 D pNtLmChallenge S * inz 
 D targetInfo S 2048A based ( pTargetInfo ) 
 D serverChallenge ... 
 D S like ( ntlm_challenge_t ) inz 
 D tempLength S 10I 0 inz 
 D tempBuffer S 2048A based ( pTemp ) 
 D temp DS qualified based ( pTemp ) 
 D respType 1A 
 D hiRespType 1A 
 D reserved_1 2A 
 D reserved_2 4A 
 D timestamp 20U 0 
 D clientChallenge ... 
 D 8A 
 D reserved_3 4A 
 D temp_targetInfo ... 
 D S 2020A based ( pTemp_TargetInfo ) 
 / FREE 
 
 if ( g_isTestMode ) ; 
 timeInMillis = 1334670690000 ; 
 else ; 
 timeInMillis = getCurrentTimeMillis ( ) ; // time in nano seconds 
 endif ; 
 
 timestamp = ( timeInMillis + MILLISECONFS_BETWEEN_1970_AND_1601 ) * 10000 ; 
 
 // Get length and offset of target name 
 length = uint16LE ( i_NtLmChallenge . targetInfo . length ) ; 
 offset = uint32LE ( i_NtLmChallenge . targetInfo . offset ) ; 
 
 // Go to the first target information block 
 pNtLmChallenge = % addr ( i_NtLmChallenge ) ; 
 pTargetInfo = pNtLmChallenge + offset ; 
 
 tempLength = % size ( temp ) + length + 4 ; 
 pTemp = % alloc ( tempLength ) ; 
 
 temp = * ALLx'00' ; 
 temp . respType = x'01' ; 
 temp . hiRespType = x'01' ; 
 temp . reserved_1 = * ALLx'00' ; 
 temp . reserved_2 = * ALLx'00' ; 
 temp . timestamp = uint64LE ( timestamp ) ; 
 temp . clientChallenge = i_clientChallenge ; 
 temp . reserved_3 = * ALLx'00' ; 
 
 pTemp_TargetInfo = % addr ( temp ) + % size ( temp ) ; 
 % subst ( temp_targetInfo : 1 : length ) = % subst ( targetInfo : 1 : length ) ; 
 
 serverChallenge = i_NtLmChallenge . challenge ; 
 NTLMResponse = 
 computeResponse ( 
 i_respKeyNT : serverChallenge : tempBuffer : tempLength ) ; 
 
 dealloc ( N ) pTemp ; 
 
 return NTLMResponse ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P computeResponse ... 
 P B export 
 D PI like ( ntlm_ntlmResponse_t ) 
 D i_respKeyNT const like ( MD5_digest_t ) 
 D i_serverChallenge ... 
 D const like ( ntlm_challenge_t ) 
 D i_clientData 2048A const 
 D i_length 10I 0 const 
 D NTLMResponse S like ( ntlm_ntlmResponse_t ) inz 
 D hmac S like ( MD5_digest_t ) inz 
 / FREE 
 
 hmac = MD5Hmac ( i_respKeyNT : i_serverChallenge + 
 % subst ( i_clientData : 1 : i_length ) ) ; 
 
 NTLMResponse = hmac + % subst ( i_clientData : 1 : i_length ) ; 
 
 return % subst ( NTLMResponse : 1 : % len ( hmac ) + i_length ) ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P LMOWFv1 ... 
 P B 
 D PI 16A 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D responseKeyLM DS 16 qualified 
 D first 8A inz ( * ALLx'00' ) 
 D second 8A inz ( * ALLx'00' ) 
 D password S like ( i_password ) inz 
 D tmpKey DS 21 qualified 
 D first 7A inz ( * ALLx'00' ) 
 D second 7A inz ( * ALLx'00' ) 
 / FREE 
 
 responseKeyLM = * ALLx'00' ; 
 
 if ( % len ( i_password ) = 0 ) ; 
 return responseKeyLM ; 
 endif ; 
 
 password = toAscii ( toUpper ( i_password ) ) ; 
 
 tmpKey = * ALLx'00' ; 
 if ( password <> '' ) ; 
 % subst ( tmpKey : 1 : % len ( password ) ) = 
 % subst ( password : 1 : % len ( password ) ) ; 
 endif ; 
 
 responseKeyLM . first = des ( ASCII_STRING : DES_produceKey ( tmpKey . first ) ) ; 
 responseKeyLM . second = des ( ASCII_STRING : DES_produceKey ( tmpKey . second ) ) ; 
 
 return responseKeyLM ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P NTOWFv1 ... 
 P B export 
 D PI like ( MD4_digest_t ) 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D digest S like ( MD4_digest_t ) inz ( * ALLx'00' ) 
 D password S like ( i_password ) inz 
 D md4_digest S like ( MD4_digest_t ) inz 
 D hmac S like ( MD5_digest_t ) inz 
 / FREE 
 
 if ( % len ( i_password ) = 0 ) ; 
 return digest ; 
 endif ; 
 
 password = varstringLE ( toUnicode ( i_password ) ) ; 
 
 md4_digest = md4 ( password ) ; 
 
 digest = md4_digest ; 
 
 return digest ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P NTOWFv2 ... 
 P B export 
 D PI like ( MD5_digest_t ) 
 D i_password const like ( ntlm_password_t ) 
 D options ( * varsize ) 
 D i_user const like ( ntlm_user_t ) 
 D options ( * varsize ) 
 D i_domain const like ( ntlm_domain_t ) 
 D options ( * varsize ) 
 D digest S like ( MD5_digest_t ) inz ( * ALLx'00' ) 
 D password S like ( i_password ) inz 
 D user S like ( i_user ) inz 
 D domain S like ( i_domain ) inz 
 D md4_digest S like ( MD4_digest_t ) inz 
 D hmac S like ( MD5_digest_t ) inz 
 / FREE 
 
 if ( % len ( i_password ) = 0 ) ; 
 return digest ; 
 endif ; 
 
 password = varstringLE ( toUnicode ( i_password ) ) ; 
 user = varstringLE ( toUnicode ( toUpper ( i_user ) ) ) ; 
 domain = varstringLE ( toUnicode ( i_domain ) ) ; 
 
 md4_digest = md4 ( password ) ; 
 hmac = MD5Hmac ( md4_digest : user + domain ) ; 
 
 digest = hmac ; 
 
 return digest ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P parseUrl ... 
 P B 
 D PI 
 D i_URL 32767A const varying options ( * varsize ) 
 D o_service 32A varying 
 D o_host 256A varying 
 D URL S like ( i_URL ) inz 
 D service S 32A 
 D user S 32A 
 D passwd S 32A 
 D host S 256A 
 D port S 10I 0 
 D path S 32767A varying 
 / FREE 
 
 http_long_ParseURL ( i_URL : service : user : passwd : host : port : path ) ; 
 
 o_service = service ; 
 o_host = host ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P isMessageTypeOf ... 
 P B 
 D PI N 
 D i_message const like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D i_type const like ( NtlmMessage_t . type ) 
 D type S like ( NtlmMessage_t . type ) inz 
 D tmpMessage DS likeds ( NtLmMessage_t ) inz 
 / FREE 
 
 if ( % len ( i_message ) < % len ( NtLmMessage_t ) ) ; 
 return cFalse ; 
 endif ; 
 
 tmpMessage = % subst ( i_message : 1 : % len ( i_message ) ) ; 
 
 type = uint32LE ( tmpMessage . type ) ; 
 
 if ( type <> i_type ) ; 
 return cFalse ; 
 endif ; 
 
 return cTrue ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getTargetInfo ... 
 P B 
 D PI like ( ntlm_targetName_t ) 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D i_type 5I 0 const 
 D targetInfo DS likeds ( targetNameChars_t ) 
 D type S 5I 0 inz 
 D length S 5I 0 inz 
 D offset S 10I 0 inz 
 D pNtLmChallenge S * inz 
 D tmpTargetInfo DS likeds ( targetInfo_t ) 
 D based ( pTmpTargetInfo ) 
 / FREE 
 // R 
 // Get length and offset of target info 
 length = uint16LE ( i_NtLmChallenge . targetInfo . length ) ; 
 offset = uint32LE ( i_NtLmChallenge . targetInfo . offset ) ; 
 
 if ( length = 0 ) ; 
 return u'' ; 
 endif ; 
 
 // Go to the first target information block 
 pNtLmChallenge = % addr ( i_NtLmChallenge ) ; 
 pTmpTargetInfo = pNtLmChallenge + offset ; 
 
 // Spin through the target information blocks 
 type = uint16LE ( tmpTargetInfo . type ) ; 
 dow ( type <> 0 ) ; 
 length = uint16LE ( tmptargetInfo . length ) ; 
 if ( type <> i_type ) ; 
 pTmpTargetInfo = pTmpTargetInfo + length + // RADDAT 
 % size ( tmpTargetInfo . type ) + // RADDAT 
 % size ( tmpTargetInfo . length ) ; 
 type = uint16LE ( tmptargetInfo . type ) ; 
 else ; 
 targetInfo = stringLE ( tmpTargetInfo . value : length ) ; 
 return % subst ( targetInfo . unicode : 1 : % int ( length / 2 ) ) ; 
 endif ; 
 enddo ; 
 
 return u'' ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Type1_toByteArray ... 
 P B 
 D PI like ( ntlm_message_t ) 
 D i_type1 likeds ( type1_t ) 
 D message S like ( ntlm_message_t ) inz ( * ALLx'00' ) 
 D isUnicode S N inz ( cTrue ) 
 D isHostInfo S N inz ( cFalse ) 
 D domain S like ( i_type1 . domain ) inz 
 D workstation S like ( i_type1 . workstation ) inz 
 D length S 10I 0 inz 
 D NtLmNegotiate ... 
 D DS likeds ( NtLmNegotiate_t ) 
 D based ( pNtLmNegotiate ) 
 D offset S 10I 0 inz 
 / FREE 
 
 isUnicode = isBit ( i_type1 . flags : NTLMSSP_NEGOTIATE_UNICODE ) ; 
 
 if ( % len ( i_type1 . domain ) > 0 ) ; 
 domain = toAscii ( i_type1 . domain ) ; 
 isHostInfo = cTrue ; 
 endif ; 
 
 if ( % len ( i_type1 . workstation ) > 0 ) ; 
 workstation = toAscii ( i_type1 . workstation ) ; 
 isHostInfo = cTrue ; 
 endif ; 
 
 if ( isHostInfo ) ; 
 length = 32 + % len ( domain ) + % len ( workstation ) ; 
 else ; 
 length = 16 ; 
 endif ; 
 
 pNtLmNegotiate = % addr ( message ) + 2 ; 
 
 NtLmNegotiate . signature = NTLMSSP_SIGNATURE ; 
 NtLmNegotiate . type = uint32LE ( NEGOTIATE_MESSAGE ) ; 
 
 if ( isHostInfo ) ; 
 offset = 32 ; 
 NtLmNegotiate . domain = writeSecurityBuffer ( message : offset : domain ) ; 
 NtLmNegotiate . workstation = writeSecurityBuffer ( 
 message : offset : workstation ) ; 
 endif ; 
 
 NtLmNegotiate . flags = uint32LE ( i_type1 . flags ) ; 
 
 return % subst ( message : 1 : length ) ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Type3_toByteArray ... 
 P B 
 D PI like ( ntlm_message_t ) 
 D i_type3 likeds ( type3_t ) 
 D message S like ( ntlm_message_t ) inz ( * ALLx'00' ) 
 D isUnicode S N inz ( cTrue ) 
 D domain S like ( i_type3 . domain ) inz 
 D user S like ( i_type3 . user ) inz 
 D workstation S like ( i_type3 . workstation ) inz 
 D length S 10I 0 inz 
 D NtLmAuthenticate ... 
 D DS likeds ( NtLmAuthenticate_t ) 
 D based ( pNtLmAuthenticate ) 
 D offset S 10I 0 inz 
 / FREE 
 
 isUnicode = isBit ( i_type3 . flags : NTLMSSP_NEGOTIATE_UNICODE ) ; 
 
 if ( % len ( i_type3 . domain ) > 0 ) ; 
 domain = transcode ( i_type3 . domain : isUnicode ) ; 
 endif ; 
 
 if ( % len ( i_type3 . user ) > 0 ) ; 
 if ( isUnicode ) ; 
 user = transcode ( i_type3 . user : isUnicode ) ; 
 else ; 
 user = transcode ( toUpper ( i_type3 . user ) : isUnicode ) ; 
 endif ; 
 endif ; 
 
 if ( % len ( i_type3 . workstation ) > 0 ) ; 
 if ( isUnicode ) ; 
 workstation = transcode ( i_type3 . workstation : isUnicode ) ; 
 else ; 
 workstation = transcode ( toUpper ( i_type3 . workstation ) : isUnicode ) ; 
 endif ; 
 endif ; 
 
 if ( isUnicode ) ; 
 domain = varstringLE ( domain ) ; 
 user = varstringLE ( user ) ; 
 workstation = varstringLE ( workstation ) ; 
 endif ; 
 
 length = 64 + % len ( domain ) + % len ( user ) + % len ( workstation ) + 
 % len ( i_type3 . lmResponse ) + % len ( i_type3 . ntResponse ) + 
 % len ( i_type3 . sessionKey ) ; 
 
 pNtLmAuthenticate = % addr ( message ) + 2 ; 
 
 NtLmAuthenticate . signature = NTLMSSP_SIGNATURE ; 
 NtLmAuthenticate . type = uint32LE ( AUTHENTICATE_MESSAGE ) ; 
 
 offset = 64 ; 
 NtLmAuthenticate . LM_resp = writeSecurityBuffer ( 
 message : offset : i_type3 . lmResponse ) ; 
 NtLmAuthenticate . NTLM_resp = writeSecurityBuffer ( 
 message : offset : i_type3 . ntResponse ) ; 
 NtLmAuthenticate . targetName = writeSecurityBuffer ( 
 message : offset : domain ) ; 
 NtLmAuthenticate . userName = writeSecurityBuffer ( 
 message : offset : user ) ; 
 NtLmAuthenticate . workstation = writeSecurityBuffer ( 
 message : offset : workstation ) ; 
 NtLmAuthenticate . sessionKey = writeSecurityBuffer ( 
 message : offset : i_type3 . sessionKey ) ; 
 NtLmAuthenticate . flags = uint32LE ( i_type3 . flags ) ; 
 
 return % subst ( message : 1 : length ) ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P NTLMSSP_SIGNATURE ... 
 P B 
 D PI like ( NtLmMessage_t . signature ) 
 / FREE 
 
 return toAscii ( 'NTLMSSP' + x'00' ) ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P writeSecurityBuffer ... 
 P B 
 D PI likeds ( ntlm_securityBuffer_t ) 
 D io_message like ( ntlm_message_t ) 
 D options ( * varsize ) 
 D io_offset 10I 0 
 D i_data 2048A const varying options ( * varsize ) 
 D securityBuffer DS likeds ( ntlm_securityBuffer_t ) inz 
 / FREE 
 
 if ( % len ( i_data ) = 0 ) ; 
 return securityBuffer ; 
 endif ; 
 
 securityBuffer . length = uint16LE ( % len ( i_data ) ) ; 
 securityBuffer . maxLen = uint16LE ( % len ( i_data ) ) ; 
 securityBuffer . offset = uint32LE ( io_offset ) ; 
 
 % subst ( io_message : io_offset + 1 : % len ( i_data ) ) = i_data ; 
 
 io_offset = io_offset + % len ( i_data ) ; 
 
 return securityBuffer ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P transcode ... 
 P B 
 D PI 4096A varying 
 D i_ebcdic 2048A const varying 
 D i_isUnicode N const 
 D transcoded S 4096A varying inz 
 D hTranscoder S like ( hTranscoder_t ) inz 
 / FREE 
 
 if ( % len ( i_ebcdic ) = 0 ) ; 
 return '' ; 
 endif ; 
 
 if ( i_isUnicode ) ; 
 transcoded = toUnicode ( i_ebcdic ) ; 
 else ; 
 transcoded = toAscii ( i_ebcdic ) ; 
 endif ; 
 
 return transcoded ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getDefaultDomain ... 
 P B 
 D PI like ( ntlm_domain_t ) 
 D domain S like ( ntlm_domain_t ) inz 
 D rcvVar S 256A inz 
 D attributes DS likeds ( QWCRNETA_returned ) 
 D based ( pAttributes ) 
 D attr DS likeds ( QWCRNETA_attr ) 
 D based ( pAttr ) 
 D errCode DS likeds ( errCode_t ) inz 
 / FREE 
 
 pAttributes = % addr ( rcvVar ) ; 
 clear errCode ; 
 
 QWCRNETA ( rcvVar : % size ( rcvVar ) : 1 : 'NWSDOMAIN' : errCode ) ; 
 
 pAttr = pAttributes + attributes . offsAttr ; 
 domain = % subst ( attr . data_char : 1 : attr . length ) ; 
 
 return domain ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getDefaultWorkstation ... 
 P B 
 D PI like ( ntlm_workstation_t ) 
 D workstation S like ( ntlm_workstation_t ) inz 
 / FREE 
 
 if ( g_isTestMode ) ; 
 return 'WORKSTATION' ; 
 endif ; 
 
 workstation = sds . job ; 
 
 return workstation ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getDefaultFlags ... 
 P B 
 D PI 10U 0 
 D flags S 10U 0 inz 
 / FREE 
 
 // Default flags as used by Firefox 
 // See : http :// mxr . mozilla . org / mozilla / source / 
 // security / manager / ssl / src / nsNTLMAuthModule . cpp 
 // Note : We do not yet support NTLMSSP_NEGOTIATE_ALWAYS_SIGN 
 flags = NTLMSSP_NEGOTIATE_UNICODE + 
 NTLMSSP_NEGOTIATE_OEM + 
 NTLMSSP_REQUEST_TARGET + 
 NTLMSSP_NEGOTIATE_NTLM ; 
 
 select ; 
 when ( g_LMCompatibility = LM_MODE_NTLM_V1 ) ; // NTLMv1 
 flags = flags + NTLMSSP_NEGOTIATE_NT_ONLY // RADDAT 
 + NTLMSSP_NEGOTIATE_NTLM2 ; 
 
 when ( g_LMCompatibility = LM_MODE_NTLM_V1_NO_LM ) ; // NTLMv1 ( no LM response ) 
 flags = flags + NTLMSSP_NEGOTIATE_NT_ONLY 
 + NTLMSSP_NEGOTIATE_NTLM2 ; 
 
 when ( g_LMCompatibility = LM_MODE_NTLM_V1_NTLM2_ONLY ) ; // NTLMv1 ( NTLM2 only ) 
 flags = flags + NTLMSSP_NEGOTIATE_NTLM2 ; 
 
 when ( g_LMCompatibility = LM_MODE_NTLM_V2 ) ; // NTLMv2 
 
 endsl ; 
 
 // Set flags to match the flags at : 
 // http :// davenport . sourceforge . net / ntlm . html # type3MessageExample 
 if ( g_isTestMode ) ; 
 flags = NTLMSSP_NEGOTIATE_UNICODE + 
 NTLMSSP_NEGOTIATE_NTLM ; 
 endif ; 
 
 return flags ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getDefaultFlagsType1 ... 
 P B 
 D PI 10U 0 
 D flags S 10U 0 inz 
 / FREE 
 
 flags = getDefaultFlags ( ) ; 
 
 return flags ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getDefaultFlagsType3 ... 
 P B 
 D PI 10U 0 
 D i_NtLmChallenge ... 
 D likeds ( NtLmChallenge_t ) 
 D options ( * varsize : * nopass ) 
 D flags S 10U 0 inz 
 D p_NtLmChallenge ... 
 D C 1 
 D type2Flags S 10U 0 inz 
 / FREE 
 
 flags = getDefaultFlags ( ) ; 
 
 if ( % parms ( ) < p_NtLmChallenge ) ; 
 if ( g_preferUnicode ) ; 
 return % bitor ( flags : NTLMSSP_NEGOTIATE_UNICODE ) ; 
 else ; 
 return % bitor ( flags : NTLMSSP_NEGOTIATE_OEM ) ; 
 endif ; 
 endif ; 
 
 type2Flags = uint32LE ( i_NtLmChallenge . flags ) ; 
 
 flags = bitand ( type2Flags : getDefaultFlagsType1 ( ) ) ; 
 
 return flags ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getTranscoderToAscii ... 
 P B 
 D PI like ( hTranscoder_t ) 
 / FREE 
 
 if ( Transcoder_isNull ( g_htoAscii ) ) ; 
 g_hToAscii = Transcoder_new ( 850 : 0 ) ; 
 endif ; 
 
 return g_hToAscii ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getTranscoderToUnicode ... 
 P B 
 D PI like ( hTranscoder_t ) 
 / FREE 
 
 if ( Transcoder_isNull ( g_htoUnicode ) ) ; 
 g_hToUnicode = Transcoder_new ( 1200 : 0 ) ; 
 endif ; 
 
 return g_hToUnicode ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P toAscii ... 
 P B export 
 D PI 2048A varying 
 D i_ebcdic 2048A const varying 
 D ascii S 2048A varying inz 
 D hToAscii S like ( hTranscoder_t ) inz 
 / FREE 
 
 if ( % len ( i_ebcdic ) = 0 ) ; 
 return '' ; 
 endif ; 
 
 hToAscii = getTranscoderToAscii ( ) ; 
 ascii = Transcoder_xlateString ( hToAscii : i_ebcdic ) ; 
 
 return ascii ; 
 
 / END - FREE 
 P E 
 R * *** Not yet in use *** 
 P freeAsciiTranscoder ... 
 P B 
 D PI 
 / FREE 
 
 if ( not Transcoder_isNull ( g_htoAscii ) ) ; 
 Transcoder_delete ( g_hToAscii ) ; 
 endif ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P toUnicode ... 
 P B export 
 D PI 4096A varying 
 D i_ebcdic 2048A const varying 
 D unicode S 4096A varying inz 
 D hToUnicode S like ( hTranscoder_t ) inz 
 / FREE 
 
 if ( % len ( i_ebcdic ) = 0 ) ; 
 return '' ; 
 endif ; 
 
 hToUnicode = getTranscoderToUnicode ( ) ; 
 unicode = Transcoder_xlateString ( hToUnicode : i_ebcdic ) ; 
 
 return unicode ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P freeUnicodeTranscoder ... 
 P B export 
 D PI 
 / FREE 
 
 if ( not Transcoder_isNull ( g_htoUnicode ) ) ; 
 Transcoder_delete ( g_hToUnicode ) ; 
 endif ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P c_clearErrno ... 
 P B 
 D PI 
 / FREE 
 
 c_errno ( 0 ) ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P c_errno ... 
 P B 
 D PI 10I 0 
 D i_errno 10I 0 const options ( * nopass ) 
 D p_errno C 1 
 D runTimeError S 10I 0 based ( pRunTimeError ) 
 / FREE 
 
 pRunTimeError = errno ( ) ; 
 
 if ( % parms ( ) >= p_errno ) ; 
 runTimeError = i_errno ; 
 endif ; 
 
 return runTimeError ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P c_strerror ... 
 P B 
 D PI 128A varying 
 D i_errno 10I 0 const 
 D errText S 128A inz varying 
 D pErrText S * inz 
 / FREE 
 
 pErrText = strerror ( i_errno ) ; 
 if pErrText = * NULL ; 
 errText = '' ; 
 else ; 
 errText = % str ( pErrText ) ; 
 endif ; 
 
 return errText ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P isBit ... 
 P B export 
 D PI N 
 D i_value 20U 0 const 
 D i_bit 20U 0 const 
 D isSet S N inz ( cFalse ) 
 / FREE 
 
 if ( i_value = 0 ) ; 
 isSet = cFalse ; 
 else ; 
 isSet = ( bitand ( i_value : i_bit ) = i_bit ) ; 
 endif ; 
 
 return isSet ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by ENCRYPTR4 , RPGUNIT tests *** 
 R * Backward compatibility to V5R1 . 
 P bitand ... 
 P B export 
 D PI 20U 0 
 D i_source1 20U 0 value 
 D i_source2 20U 0 value 
 D result S 20U 0 inz 
 / FREE 
 
 ANDSTR ( % addr ( result ) 
 : % addr ( i_source1 ) : % addr ( i_source2 ) : % size ( i_source2 ) ) ; 
 
 return result ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by ENCRYPTR4 , RPGUNIT tests *** 
 R * Backward compatibility to V5R1 . 
 P byteand ... 
 P B export 
 D PI 1A 
 D i_source1 1A value 
 D i_source2 1A value 
 D result S 1A inz 
 / FREE 
 
 ANDSTR ( % addr ( result ) 
 : % addr ( i_source1 ) : % addr ( i_source2 ) : % size ( i_source2 ) ) ; 
 
 return result ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 R * Backward compatibility to V5R1 . 
 P bitor ... 
 P B export 
 D PI 20U 0 
 D i_source1 20U 0 value 
 D i_source2 20U 0 value 
 D result S 20U 0 inz 
 / FREE 
 
 ORSTR ( % addr ( result ) 
 : % addr ( i_source1 ) : % addr ( i_source2 ) : % size ( i_source2 ) ) ; 
 
 return result ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by ENCRYPTR4 , RPGUNIT tests *** 
 R * Backward compatibility to V5R1 . 
 P byteor ... 
 P B export 
 D PI 1A 
 D i_source1 1A value 
 D i_source2 1A value 
 D result S 1A inz 
 / FREE 
 
 ORSTR ( % addr ( result ) 
 : % addr ( i_source1 ) : % addr ( i_source2 ) : % size ( i_source2 ) ) ; 
 
 return result ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P kill ... 
 P B 
 D PI 
 D i_text 128A const varying 
 D msgKey S 4A inz 
 D qMsgF DS qualified inz 
 D name 10A 
 D lib 10A 
 D errCode DS qualified inz 
 D bytPrv 10I 0 
 D bytAvl 10I 0 
 D QMHSNDPM PR extpgm ( 'QMHSNDPM' ) 
 D i_msgID 7A const 
 D i_qMsgF 20A const 
 D i_msgData 32767A const options ( * varsize ) 
 D i_length 10I 0 const 
 D i_msgType 10A const 
 D i_callStkE 32767A const options ( * varsize ) 
 D i_callStkC 10I 0 const 
 D o_msgKey 4A 
 D io_ErrCode 32767A options ( * varsize ) 
 D i_lenStkE 10I 0 const options ( * nopass ) 
 D i_callStkEQ 20A const options ( * nopass ) 
 D i_wait 10I 0 const options ( * nopass ) 
 D i_callStkEDT 10A const options ( * nopass ) 
 D i_ccsid 10I 0 const options ( * nopass ) 
 / FREE 
 
 clear qMsgF ; 
 qMsgF . name = 'QCPFMSG' ; 
 qMsgF . lib = ' * LIBL' ; 
 
 clear errCode ; 
 errCode . bytPrv = % size ( errCode ) ; 
 
 QMHSNDPM ( 'CPF9898' : qMsgF : i_text : % len ( i_text ) : ' * ESCAPE' 
 : ' * ' : 1 : msgKey : errCode ) ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P uint16LE ... 
 P B export 
 D PI 5U 0 
 D i_int2 5U 0 const 
 D rtn DS qualified 
 D int2 5U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 D input DS qualified 
 D int2 5U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 / FREE 
 
 input . int2 = i_int2 ; 
 
 rtn . byte1 = input . byte2 ; 
 rtn . byte2 = input . byte1 ; 
 
 return rtn . int2 ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P uint32LE ... 
 P B export 
 D PI 10U 0 
 D i_int4 10U 0 const 
 D rtn DS qualified 
 D int4 10U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 D byte3 3 3U 0 
 D byte4 4 4U 0 
 D input DS qualified 
 D int4 10U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 D byte3 3 3U 0 
 D byte4 4 4U 0 
 / FREE 
 
 input . int4 = i_int4 ; 
 
 rtn . byte1 = input . byte4 ; 
 rtn . byte2 = input . byte3 ; 
 rtn . byte3 = input . byte2 ; 
 rtn . byte4 = input . byte1 ; 
 
 return rtn . int4 ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P uint64LE ... 
 P B export 
 D PI 20U 0 
 D i_int8 20U 0 const 
 D rtn DS qualified 
 D int8 20U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 D byte3 3 3U 0 
 D byte4 4 4U 0 
 D byte5 5 5U 0 
 D byte6 6 6U 0 
 D byte7 7 7U 0 
 D byte8 8 8U 0 
 D input DS qualified 
 D int8 20U 0 
 D byte1 1 1U 0 
 D byte2 2 2U 0 
 D byte3 3 3U 0 
 D byte4 4 4U 0 
 D byte5 5 5U 0 
 D byte6 6 6U 0 
 D byte7 7 7U 0 
 D byte8 8 8U 0 
 / FREE 
 
 input . int8 = i_int8 ; 
 
 rtn . byte1 = input . byte8 ; 
 rtn . byte2 = input . byte7 ; 
 rtn . byte3 = input . byte6 ; 
 rtn . byte4 = input . byte5 ; 
 rtn . byte5 = input . byte4 ; 
 rtn . byte6 = input . byte3 ; 
 rtn . byte7 = input . byte2 ; 
 rtn . byte8 = input . byte1 ; 
 
 return rtn . int8 ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P stringLE ... 
 P B export 
 D PI 1024A varying 
 D i_string 1024A options ( * varsize ) 
 D i_length 10I 0 const 
 D rtn S 1024A varying inz 
 D x S 10I 0 inz 
 / FREE 
 
 % len ( rtn ) = i_length ; 
 
 for x = 2 to i_length by 2 ; 
 % subst ( rtn : x - 1 : 1 ) = % subst ( i_string : x : 1 ) ; 
 % subst ( rtn : x : 1 ) = % subst ( i_string : x - 1 : 1 ) ; 
 endfor ; 
 
 return rtn ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P varstringLE ... 
 P B export 
 D PI 1024A varying 
 D i_string 1024A const varying options ( * varsize ) 
 D rtn S 1024A varying inz 
 D x S 10I 0 inz 
 / FREE 
 
 % len ( rtn ) = % len ( i_string ) ; 
 
 for x = 2 to % len ( i_string ) by 2 ; 
 % subst ( rtn : x - 1 : 1 ) = % subst ( i_string : x : 1 ) ; 
 % subst ( rtn : x : 1 ) = % subst ( i_string : x - 1 : 1 ) ; 
 endfor ; 
 
 return rtn ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P random ... 
 P B export 
 D PI opdesc 
 D o_random 128A options ( * varsize ) 
 D i_isTestMode N const options ( * nopass ) 
 D p_random C 1 
 D p_isTestMode C 2 
 D isTestMode S like ( i_isTestMode ) inz 
 D isInit S N inz ( cFalse ) static 
 D randInf DS likeds ( strInf_t ) inz 
 D offs S 10I 0 inz 
 D i S 3U 0 inz 
 D p S 3U 0 inz 
 D randNum DS qualified 
 D int4 1 4U 0 
 D chars 3 4A 
 D int1 3 4U 0 dim ( 2 ) 
 / FREE 
 
 if ( % parms ( ) >= p_isTestMode ) ; 
 isTestMode = i_isTestMode ; 
 else ; 
 isTestMode = cFalse ; 
 endif ; 
 
 if ( not isInit ) ; 
 srand ( time ( * null ) ) ; 
 isInit = cTrue ; 
 endif ; 
 
 CEEGSI ( p_random : randInf . dataType 
 : randInf . curlen : randInf . maxLen : * omit ) ; 
 
 // rand ( ) returns a number between 0 and RAND_MAX ( qsysinc / h . stdlib ) 
 // where RAND_MAX is 32767 . 
 offs = 0 ; 
 i = 1 ; 
 dow ( offs < randInf . curlen ) ; 
 if ( not isTestMode ) ; 
 randNum . int4 = rand ( ) ; 
 else ; 
 for p = 1 to % size ( randNum . chars ) ; 
 randNum . int1 ( p ) = i ; 
 i = i + 1 ; 
 endfor ; 
 endif ; 
 
 if ( offs + % size ( randNum . chars ) <= randInf . curlen ) ; 
 % subst ( o_random : offs + 1 : % size ( randNum . chars ) ) = randNum . chars ; 
 else ; 
 % subst ( o_random : offs + 1 ) = randNum . chars ; 
 endif ; 
 offs = offs + % size ( randNum . chars ) ; 
 enddo ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P toUpper ... 
 P B export 
 D PI 1024A varying 
 D i_string 1024A const varying 
 D upper S 1024A varying inz 
 D tmpBuffer S 1024A inz 
 D reqCtrlBlk DS likeds ( QLGCNVCS_reqCtrlBlk_t ) inz 
 D errCode DS likeds ( errCode_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return i_string ; 
 endif ; 
 
 reqCtrlBlk . type = CVTCASE_TYPE_CCSID ; 
 reqCtrlBlk . CCSID = CVTCASE_CCSID_JOB ; 
 reqCtrlBlk . case = CVTCASE_TO_UPPER ; 
 reqCtrlBlk . reserved = * ALLx'00' ; 
 clear errCode ; 
 QlgConvertCase ( reqCtrlBlk : 
 i_string : tmpBuffer : % len ( i_string ) : errCode ) ; 
 upper = % subst ( tmpBuffer : 1 : % len ( i_string ) ) ; 
 
 return upper ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P toLower ... 
 P B export 
 D PI 1024A varying 
 D i_string 1024A const varying 
 D lower S 1024A varying inz 
 D tmpBuffer S 1024A inz 
 D reqCtrlBlk DS likeds ( QLGCNVCS_reqCtrlBlk_t ) inz 
 D errCode DS likeds ( errCode_t ) inz 
 / FREE 
 
 if ( i_string = '' ) ; 
 return i_string ; 
 endif ; 
 
 reqCtrlBlk . type = CVTCASE_TYPE_CCSID ; 
 reqCtrlBlk . CCSID = CVTCASE_CCSID_JOB ; 
 reqCtrlBlk . case = CVTCASE_TO_LOWER ; 
 reqCtrlBlk . reserved = * ALLx'00' ; 
 clear errCode ; 
 QlgConvertCase ( reqCtrlBlk : 
 i_string : tmpBuffer : % len ( i_string ) : errCode ) ; 
 lower = % subst ( tmpBuffer : 1 : % len ( i_string ) ) ; 
 
 return lower ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P desl ... 
 P B 
 D PI 24A 
 D i_key 16A const 
 D i_data 8A const 
 D digest DS 24 qualified 
 D first 8A inz ( * ALLx'00' ) 
 D second 8A inz ( * ALLx'00' ) 
 D third 8A inz ( * ALLx'00' ) 
 D tmpKey DS 21 qualified 
 D first 7A inz ( * ALLx'00' ) 
 D second 7A inz ( * ALLx'00' ) 
 D third 7A inz ( * ALLx'00' ) 
 / FREE 
 
 % subst ( tmpKey : 1 : % len ( i_key ) ) = i_key ; 
 digest . first = des ( i_data : DES_produceKey ( tmpKey . first ) ) ; 
 digest . second = des ( i_data : DES_produceKey ( tmpKey . second ) ) ; 
 digest . third = des ( i_data : DES_produceKey ( tmpKey . third ) ) ; 
 
 return digest ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P z ... 
 P B 
 D PI 128A varying 
 D i_n 10I 0 const 
 D zeroBytes S 128A varying inz ( * ALLx'00' ) 
 / FREE 
 
 % len ( zeroBytes ) = i_n ; 
 
 return zeroBytes ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P getCurrentTimeMillis ... 
 P B 
 D PI 20U 0 
 D timeInMillis S 20U 0 inz 
 / FREE 
 
 timeInMillis = time ( * null ) * 10000 ; 
 
 return timeInMillis ; 
 
 / END - FREE 
 P E 
 R * *** Exported because , internally used by RPGUNIT tests *** 
 P getToken ... 
 P B export 
 D PI 2048A varying 
 D i_tokens 2048A const varying options ( * omit ) 
 D i_delimiters 16A const varying 
 D token S 2048A varying inz 
 D p_tokens C 1 
 D start S 10I 0 inz 
 D tokens S like ( i_tokens ) inz static 
 D offs S 10I 0 inz static 
 / FREE 
 
 if ( % parms ( ) >= p_tokens and % addr ( i_tokens ) <> * NULL ) ; 
 tokens = i_tokens ; 
 offs = 0 ; 
 endif ; 
 
 token = '' ; 
 
 // Skip leading delimiters 
 dow ( offs < % len ( tokens ) and 
 % scan ( % subst ( tokens : offs + 1 : 1 ) : i_delimiters ) > 0 ) ; 
 offs = offs + 1 ; 
 enddo ; 
 
 start = offs ; 
 
 // Get next token 
 dow ( offs < % len ( tokens ) and 
 % scan ( % subst ( tokens : offs + 1 : 1 ) : i_delimiters ) = 0 ) ; 
 offs = offs + 1 ; 
 enddo ; 
 
 if ( offs - start > 0 ) ; 
 token = % subst ( tokens : start + 1 : offs - start ) ; 
 endif ; 
 
 return token ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P nullWrite ... 
 P B 
 D PI 10I 0 
 D i_fd 10I 0 value 
 D i_data * value 
 D i_length 10I 0 value 
 / FREE 
 
 return i_length ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P NTLM_Base64_encode ... 
 P B 
 D PI 10U 0 
 D Input * value 
 D InputLen 10U 0 value 
 D Output * value 
 D OutputSize 10U 0 value 
 
 D DS 
 D Numb 1 2U 0 inz ( 0 ) 
 D Byte 2 2A 
 
 D data DS based ( Input ) 
 D B1 1A 
 D B2 1A 
 D B3 1A 
 
 D OutData S 4A based ( Output ) 
 D Temp S 4A 
 D Pos S 10I 0 
 D OutLen S 10I 0 
 D Save s 1A 
 
 / free 
 
 Pos = 1 ; 
 
 dow ( Pos <= InputLen ) ; 
 
 // ------------------------------------------------- 
 // First output byte comes from bits 1 - 6 of input 
 // ------------------------------------------------- 
 
 Byte = byteand ( B1 : x'FC' ) ; 
 Numb /= 4 ; 
 % subst ( Temp : 1 ) = base64f ( Numb + 1 ) ; 
 
 // ------------------------------------------------- 
 // Second output byte comes from bits 7 - 8 of byte 1 
 // and bits 1 - 4 of byte 2 
 // ------------------------------------------------- 
 Byte = byteand ( B1 : x'03' ) ; 
 Numb *= 16 ; 
 
 if ( Pos + 1 <= InputLen ) ; 
 Save = Byte ; 
 Byte = byteand ( B2 : x'F0' ) ; 
 Numb /= 16 ; 
 Byte = % bitor ( Save : Byte ) ; 
 endif ; 
 
 % subst ( Temp : 2 ) = base64f ( Numb + 1 ) ; 
 
 // ------------------------------------------------- 
 // Third output byte comes from bits 5 - 8 of byte 2 
 // and bits 1 - 2 of byte 3 
 // ( or is set to ' = ' if there was only one byte ) 
 // ------------------------------------------------- 
 
 if ( Pos + 1 > InputLen ) ; 
 % subst ( Temp : 3 ) = ' = ' ; 
 else ; 
 Byte = byteand ( B2 : x'0F' ) ; 
 Numb *= 4 ; 
 
 if ( Pos + 2 <= InputLen ) ; 
 Save = Byte ; 
 Byte = byteand ( B3 : x'C0' ) ; 
 Numb /= 64 ; 
 Byte = % bitor ( Save : Byte ) ; 
 endif ; 
 
 % subst ( Temp : 3 ) = base64f ( Numb + 1 ) ; 
 endif ; 
 
 // ------------------------------------------------- 
 // Fourth output byte comes from bits 3 - 8 of byte 3 
 // ( or is set to ' = ' if there was only one / two bytes ) 
 // ------------------------------------------------- 
 
 if ( Pos + 2 > InputLen ) ; 
 % subst ( Temp : 4 : 1 ) = ' = ' ; 
 else ; 
 Byte = byteand ( B3 : x'3F' ) ; 
 % subst ( Temp : 4 ) = base64f ( Numb + 1 ) ; 
 endif ; 
 
 // ------------------------------------------------- 
 // Advance to next chunk of data . 
 // ------------------------------------------------- 
 
 Input += % size ( data ) ; 
 Pos += % size ( data ) ; 
 OutLen += % size ( Temp ) ; 
 
 if ( OutLen <= OutputSize ) ; 
 OutData = Temp ; 
 Output += % size ( Temp ) ; 
 endif ; 
 
 enddo ; 
 
 return OutLen ; 
 
 / end - free 
 P E 
 R * *** private *** 
 P NTLM_Base64_decode ... 
 P B 
 D PI 10U 0 
 D Input * value 
 D InputLen 10U 0 value 
 D Output * value 
 D OutputSize 10U 0 value 
 
 D DS 
 D Numb 1 2U 0 inz ( 0 ) 
 D Byte 2 2A 
 
 D data DS based ( Input ) 
 D B1 3U 0 
 D B2 3U 0 
 D B3 3U 0 
 D B4 3U 0 
 
 D OutData S 3A based ( Output ) 
 D temp S 3A varying 
 D Pos S 10I 0 
 D OutLen S 10I 0 
 
 / free 
 
 Pos = 1 ; 
 
 dow ( Pos <= InputLen ) ; 
 
 if ( base64r ( B1 ) = x'FF' ) ; 
 invalidChar ( Pos : B1 ) ; 
 endif ; 
 if ( base64r ( B2 ) = x'FF' ) ; 
 invalidChar ( Pos + 1 : B2 ) ; 
 endif ; 
 if ( base64r ( B3 ) = x'FF' and B3 <> 126 ) ; 
 invalidChar ( Pos + 2 : B3 ) ; 
 endif ; 
 if ( base64r ( B4 ) = x'FF' and B4 <> 126 ) ; 
 invalidChar ( Pos + 3 : B4 ) ; 
 endif ; 
 
 // ------------------------------------------------- 
 // First output byte comes from bits 3 - 8 of byte 1 
 // and bits 3 - 4 of byte 2 
 // ------------------------------------------------- 
 
 Numb = base64r ( B1 ) * 4 
 + base64r ( B2 ) / 16 ; 
 Temp = Byte ; 
 
 // ------------------------------------------------- 
 // Second output byte comes from bits 5 - 8 of byte 2 
 // and bits 3 - 6 of byte 3 
 // ------------------------------------------------- 
 if % subst ( data : 3 : 1 ) <> ' = ' ; 
 numb = bitand ( base64r ( B2 ) : x'0f' ) * 16 
 + base64r ( B3 ) / 4 ; 
 Temp += Byte ; 
 endif ; 
 
 // ------------------------------------------------- 
 // Third output byte comes from bits 7 - 8 of byte 3 
 // and bits 3 - 8 of byte 4 
 // ( or is set to ' = ' if there was only one byte ) 
 // ------------------------------------------------- 
 if % subst ( data : 4 : 1 ) <> ' = ' ; 
 numb = bitand ( base64r ( B3 ) : x'03' ) * 64 
 + base64r ( B4 ) ; 
 Temp += Byte ; 
 endif ; 
 
 // ------------------------------------------------- 
 // Advance to next chunk of data . 
 // ------------------------------------------------- 
 
 Input += % size ( data ) ; 
 Pos += % size ( data ) ; 
 OutLen += % len ( Temp ) ; 
 
 if ( OutLen <= OutputSize ) ; 
 OutData = Temp ; 
 Output += % len ( Temp ) ; 
 endif ; 
 
 enddo ; 
 
 return OutLen ; 
 
 / end - free 
 P E 
 R * *** private *** 
 P invalidChar ... 
 P B 
 D PI 
 D CharPos 10i 0 value 
 D Char 3u 0 value 
 
 D QMHSNDPM PR ExtPgm ( 'QMHSNDPM' ) 
 D MessageID 7A Const 
 D QualMsgF 20A Const 
 D MsgData 32767a Const options ( * varsize ) 
 D MsgDtaLen 10I 0 Const 
 D MsgType 10A Const 
 D CallStkEnt 10A Const 
 D CallStkCnt 10I 0 Const 
 D MessageKey 4A 
 D ErrorCode 8192A options ( * varsize ) 
 
 D ErrorCode DS qualified 
 D BytesProv 1 4I 0 inz ( 0 ) 
 D BytesAvail 5 8I 0 inz ( 0 ) 
 
 D cvthc PR ExtProc ( 'cvthc' ) 
 D target 2A options ( * varsize ) 
 D src_bits 3u 0 const 
 D tgt_length 10I 0 value 
 
 D Hex s 2a 
 D MsgKey S 4A 
 D MsgDta s 100a varying 
 
 / free 
 
 cvthc ( hex : char :% size ( hex ) ) ; 
 
 MsgDta = 'Unable to decode character at position ' 
 + % char ( CharPos ) + ' . ( Char = x''' + hex + ''' ) ' ; 
 
 QMHSNDPM ( 'CPF9897' 
 : 'QCPFMSG * LIBL' 
 : MsgDta 
 : % len ( MsgDta ) 
 : ' * ESCAPE' 
 : ' * PGMBDY' 
 : 2 
 : MsgKey 
 : ErrorCode ) ; 
 
 / end - free 
 P E 
 R * *** private *** 
 P Transcoder_new ... 
 P B 
 D PI like ( hTranscoder_t ) 
 D i_toCcsid 10U 0 const 
 D i_fromCcsid 10U 0 const 
 D hTranscoder S like ( hTranscoder_t ) inz 
 D toCode DS likeds ( QtqCode_t ) inz 
 D fromCode DS likeds ( QtqCode_t ) inz 
 D hIconv DS likeds ( iconv_t ) inz 
 D transcoder DS likeds ( transcoder_t ) 
 D based ( pTranscoder ) 
 / FREE 
 
 clear fromCode ; 
 fromCode . ccsid = i_fromCcsid ; 
 fromCode . conversionA = 0 ; 
 fromCode . substitutionA = 0 ; 
 fromCode . shiftStateA = 0 ; 
 fromCode . inpLenOpt = 0 ; 
 fromCode . errOptMxdDta = 1 ; 
 fromCode . reserved = * ALLx'00' ; 
 
 clear toCode ; 
 toCode . ccsid = i_toCcsid ; 
 toCode . conversionA = 0 ; 
 toCode . substitutionA = 0 ; 
 toCode . shiftStateA = 0 ; 
 toCode . inpLenOpt = 0 ; 
 toCode . errOptMxdDta = 0 ; 
 toCode . reserved = * ALLx'00' ; 
 
 hIconv = QtqIconv_open ( toCode : fromCode ) ; 
 if ( hIconv . return_value = - 1 ) ; 
 kill ( 'Failed to initialize character : ' + 
 c_strerror ( c_errno ( ) ) ) ; 
 endif ; 
 
 pTranscoder = % alloc ( % size ( transcoder ) ) ; 
 
 clear transcoder ; 
 transcoder . fromCcsid = i_fromCcsid ; 
 transcoder . toCcsid = i_toCcsid ; 
 transcoder . hIconv = hIconv ; 
 
 hTranscoder = pTranscoder ; 
 
 return hTranscoder ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Transcoder_xlateString ... 
 P B 
 D PI 32767A opdesc varying 
 D i_hTranscoder const like ( hTranscoder_t ) 
 D i_string 32767A const varying options ( * varsize ) 
 D rtn DS qualified 
 D string 32767A varying 
 D len 1 2I 0 
 D data 3 32767A 
 D tRc S 10U 0 inz 
 D pInBuf S * inz 
 D pOutBuf S * inz 
 D transcoder DS likeds ( transcoder_t ) 
 D based ( i_hTranscoder ) 
 / FREE 
 
 rtn . string = i_string ; 
 
 pInBuf = % addr ( rtn . data ) ; 
 pOutBuf = * NULL ; 
 
 tRc = performTranslation ( i_hTranscoder 
 : pInBuf 
 : % len ( i_string ) 
 : pOutBuf 
 : % size ( rtn . data ) ) ; 
 
 if ( tRc = ICONV_ERROR ) ; 
 rtn . len = 0 ; 
 else ; 
 rtn . len = tRc ; 
 memcpy2 ( % addr ( rtn . data ) : pOutBuf : rtn . len ) ; 
 endif ; 
 
 if ( pOutBuf <> * NULL ) ; 
 dealloc ( N ) pOutBuf ; 
 endif ; 
 
 return rtn . string ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Transcoder_delete ... 
 P B 
 D PI 
 D io_hTranscoder ... 
 D like ( hTranscoder_t ) 
 D transcoder DS likeds ( transcoder_t ) 
 D based ( io_hTranscoder ) 
 / FREE 
 
 iconv_close ( transcoder . hIconv ) ; 
 io_hTranscoder = Transcoder_null ( ) ; 
 
 return ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Transcoder_isNull ... 
 P B 
 D PI N 
 D i_hTranscoder const like ( hTranscoder_t ) 
 / FREE 
 
 if ( i_hTranscoder = Transcoder_null ( ) ) ; 
 return cTrue ; 
 else ; 
 return cFalse ; 
 endif ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P Transcoder_null ... 
 P B 
 D PI like ( hTranscoder_t ) 
 / FREE 
 
 return * NULL ; 
 
 / END - FREE 
 P E 
 R * *** private *** 
 P performTranslation ... 
 P B 
 D PI 10U 0 
 D i_hTranscoder const like ( hTranscoder_t ) 
 D i_pInBuf * value 
 D i_length 10I 0 const 
 D o_pOutBuf * 
 D i_maxSize 10I 0 const 
 D length S 10U 0 inz 
 D rc S 10U 0 inz 
 D bytPrv S 10U 0 inz 
 D bytLeft S 10U 0 inz 
 D bufSize S 10I 0 inz 
 D pInBuf S * inz 
 D pOutBuf S * inz 
 D inpBuf S 32767A based ( i_pInBuf ) 
 D extendSize S 10I 0 inz 
 D isMaxSize S N inz ( cFalse ) 
 D MAX_SIZE C - 1 
 D transcoder DS likeds ( transcoder_t ) 
 D based ( i_hTranscoder ) 
 / FREE 
 
 bytPrv = i_length ; 
 bytLeft = i_length ; 
 bufSize = i_length ; 
 pInBuf = i_pInBuf ; 
 length = 0 ; 
 
 if ( o_pOutBuf = * NULL ) ; 
 o_pOutBuf = % alloc ( bufSize ) ; 
 else ; 
 kill ( 'o_pOutBuf must be * NULL' ) ; 
 endif ; 
 
 if ( i_maxSize = - 1 ) ; 
 isMaxSize = cFalse ; 
 else ; 
 isMaxSize = cTrue ; 
 endif ; 
 
 c_clearErrno ( ) ; 
 dou ( rc <> ICONV_ERROR ) or ( c_errno ( ) <> E2BIG_C or 
 ( isMaxSize and bufSize >= i_maxSize ) ) ; 
 
 if ( c_errno ( ) = E2BIG_C ) ; 
 if ( isMaxSize and bufSize >= i_maxSize ) ; 
 leave ; 
 endif ; 
 if ( pInBuf = i_pInBuf ) ; 
 // No bytes have been transcoded . Reset values . 
 bytPrv = i_length ; 
 bytLeft = bufSize ; 
 length = 0 ; 
 endif ; 
 extendSize = bytPrv * 2 ; 
 if ( MAX_SIZE > 0 and extendSize > MAX_SIZE ) ; 
 extendSize = MAX_SIZE - bufSize ; 
 endif ; 
 if ( isMaxSize and ( bufSize + extendSize ) > i_maxSize ) ; 
 extendSize = i_maxSize - bufSize ; 
 endif ; 
 bufSize = bufSize + extendSize ; 
 bytLeft = bytLeft + extendSize ; 
 o_pOutBuf = % realloc ( o_pOutBuf : bufSize ) ; 
 endif ; 
 
 pOutBuf = o_pOutBuf + length ; 
 length = length + bytLeft ; 
 rc = iconv ( transcoder . hIconv : pInBuf : bytPrv : pOutBuf : bytLeft ) ; 
 length = length - bytLeft ; 
 
 enddo ; 
 
 if ( rc = ICONV_ERROR ) ; 
 length = rc ; 
 if ( c_errno ( ) = E2BIG_C ) ; 
 kill ( 'Target buffer too small to hold result . ' ) ; 
 else ; 
 kill ( 'Failed to transcode characters : ' + 
 c_strerror ( c_errno ( ) ) ) ; 
 endif ; 
 endif ; 
 
 return length ; 
 
 / END - FREE 
 P E 
 H NOMAIN 
 
 / define HTTP_ORIG_SOAPACTION 
 / copy httpapi_h 
 / copy private_h 
 
 D setErrorNotSupported ... 
 D PR 10i 0 
 
 P http_url_get_xml ... 
 P B export 
 D http_url_get_xml ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_url_post_xml ... 
 P B export 
 D http_url_post_xml ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 P http_url_post_stmf_xml ... 
 P B export 
 D http_url_post_stmf_xml ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostFile 32767A varying const options ( * varsize ) 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_parse_xml_stmf ... 
 P B export 
 D http_parse_xml_stmf ... 
 D PI 10I 0 
 D peFile 32767A varying const options ( * varsize ) 
 D peCCSID 10I 0 value 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_get_xmltf ... 
 P B export 
 D http_get_xmltf ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peModTime Z const options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_post_xmltf ... 
 P B export 
 D http_post_xmltf ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostData * value 
 D pePostDataLen 10I 0 value 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_post_stmf_xmltf ... 
 P B export 
 D http_post_stmf_xmltf ... 
 D PI 10I 0 
 D peURL 32767A varying const options ( * varsize ) 
 D pePostFile 32767A varying const options ( * varsize ) 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 D peTimeout 10I 0 value options ( * nopass ) 
 / if defined ( HTTP_ORIG_SHORTFIELD ) 
 D peUserAgent 64A const options ( * nopass :* omit ) 
 D peContentType 64A const options ( * nopass :* omit ) 
 D peSOAPAction 64A const options ( * nopass :* omit ) 
 / else 
 D peUserAgent 16384A varying const 
 D options ( * nopass :* omit ) 
 D peContentType 16384A varying const 
 D options ( * nopass :* omit ) 
 D peSOAPAction 16384A varying const 
 D options ( * nopass :* omit ) 
 / endif 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_xmlns B export 
 D http_xmlns PI 
 D peEnable 1N const 
 c callp setErrorNotSupported ( ) 
 P E 
 
 
 P http_XmlReturnPtr ... 
 P B export 
 D http_XmlReturnPtr ... 
 D PI 
 D peEnable 1N const 
 c callp setErrorNotSupported ( ) 
 P E 
 
 
 P http_XmlStripCRLF ... 
 P B export 
 D http_XmlStripCRLF ... 
 D PI 
 D peEnable 1N const 
 c callp setErrorNotSupported ( ) 
 P E 
 
 
 P http_parser_switch_cb ... 
 P B export 
 D http_parser_switch_cb ... 
 D PI 10I 0 
 D peUsrDta * value 
 D peStartProc * value procptr 
 D peEndProc * value procptr options ( * nopass ) 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_parser_get_start_cb ... 
 P B export 
 D http_parser_get_start_cb ... 
 D PI * procptr 
 c callp setErrorNotSupported ( ) 
 c return * null 
 P E 
 
 
 P http_parser_get_end_cb ... 
 P B export 
 D http_parser_get_end_cb ... 
 D PI * procptr 
 c callp setErrorNotSupported ( ) 
 c return * null 
 P E 
 
 
 P http_parser_get_userdata ... 
 P B export 
 D http_parser_get_userdata ... 
 D PI * 
 c callp setErrorNotSupported ( ) 
 c return * null 
 P E 
 
 
 P http_parse_xml_string ... 
 P B export 
 D http_parse_xml_string ... 
 D PI 10i 0 
 D peString * value 
 D peLen 10I 0 value 
 D peCCSID 10I 0 value 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P HTTP_nextXmlAttr ... 
 P B EXPORT 
 D HTTP_nextXmlAttr ... 
 D PI 1N 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 D num 10i 0 
 D name 1024a varying 
 D val 65535a varying 
 c callp setErrorNotSupported ( ) 
 c return * OFF 
 P E 
 
 
 P http_EscapeXml B export 
 D http_EscapeXml PI 4096a varying 
 D peString 4096a varying const 
 c callp setErrorNotSupported ( ) 
 c return peString 
 P E 
 
 
 P http_XmlReturnUCS ... 
 P B export 
 D http_XmlReturnUCS ... 
 D PI 
 D peEnable 1N const 
 c callp setErrorNotSupported ( ) 
 P E 
 
 
 P http_parser_init ... 
 P B export 
 D http_parser_init ... 
 D PI 
 D peCCSID 10I 0 const options ( * omit ) 
 D peStartProc * value procptr 
 D peEndProc * value procptr 
 D peUsrDta * value 
 c callp setErrorNotSupported ( ) 
 P E 
 
 
 P http_parser_parseChunk ... 
 P B export 
 D http_parser_parseChunk ... 
 D PI 10I 0 
 D peFD 10I 0 value 
 D peData * value options ( * string ) 
 D peLength 10I 0 value 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P http_parser_free ... 
 P B export 
 D http_parser_free ... 
 D PI 10I 0 
 D peUpdError N const options ( * nopass : * omit ) 
 c return setErrorNotSupported ( ) 
 P E 
 
 
 P HTTP_nextXmlAttrUCS ... 
 P B EXPORT 
 D HTTP_nextXmlAttrUCS ... 
 D PI 1N 
 D attrs * dim ( 32767 ) 
 D const options ( * varsize ) 
 D num 10i 0 
 D name 1024c varying 
 D val 65535c varying 
 c callp setErrorNotSupported ( ) 
 c return * off 
 P E 
 
 
 P setErrorNotSupported ... 
 P B 
 D pi 10i 0 
 c callp seterror ( HTTP_NOTSUPP 
 c : 'HTTPAPI was not built ' 
 c + 'with XML support . ' ) 
 c return - 1 
 P E 

